"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@hello-pangea";
exports.ids = ["vendor-chunks/@hello-pangea"];
exports.modules = {

/***/ "(ssr)/./node_modules/@hello-pangea/dnd/dist/dnd.esm.js":
/*!********************************************************!*\
  !*** ./node_modules/@hello-pangea/dnd/dist/dnd.esm.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DragDropContext: () => (/* binding */ DragDropContext),\n/* harmony export */   Draggable: () => (/* binding */ PublicDraggable),\n/* harmony export */   Droppable: () => (/* binding */ ConnectedDroppable$1),\n/* harmony export */   resetServerContext: () => (/* binding */ resetServerContext),\n/* harmony export */   useKeyboardSensor: () => (/* binding */ useKeyboardSensor),\n/* harmony export */   useMouseSensor: () => (/* binding */ useMouseSensor),\n/* harmony export */   useTouchSensor: () => (/* binding */ useTouchSensor)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var redux__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! redux */ \"(ssr)/./node_modules/redux/es/redux.js\");\n/* harmony import */ var react_redux__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-redux */ \"(ssr)/./node_modules/react-redux/es/index.js\");\n/* harmony import */ var use_memo_one__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! use-memo-one */ \"(ssr)/./node_modules/use-memo-one/dist/use-memo-one.esm.js\");\n/* harmony import */ var css_box_model__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! css-box-model */ \"(ssr)/./node_modules/css-box-model/dist/css-box-model.esm.js\");\n/* harmony import */ var memoize_one__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! memoize-one */ \"(ssr)/./node_modules/memoize-one/dist/memoize-one.esm.js\");\n/* harmony import */ var raf_schd__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! raf-schd */ \"(ssr)/./node_modules/raf-schd/dist/raf-schd.esm.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n\n\n\n\n\n\n\n\n\nconst isProduction$1 = \"development\" === \"production\";\nconst spacesAndTabs = /[ \\t]{2,}/g;\nconst lineStartWithSpaces = /^[ \\t]*/gm;\nconst clean$2 = (value)=>value.replace(spacesAndTabs, \" \").replace(lineStartWithSpaces, \"\").trim();\nconst getDevMessage = (message)=>clean$2(`\n  %c@hello-pangea/dnd\n\n  %c${clean$2(message)}\n\n  %cðŸ‘·â€ This is a development only message. It will be removed in production builds.\n`);\nconst getFormattedMessage = (message)=>[\n        getDevMessage(message),\n        \"color: #00C584; font-size: 1.2em; font-weight: bold;\",\n        \"line-height: 1.5\",\n        \"color: #723874;\"\n    ];\nconst isDisabledFlag = \"__@hello-pangea/dnd-disable-dev-warnings\";\nfunction log(type, message) {\n    if (isProduction$1) {\n        return;\n    }\n    if (false) {}\n    console[type](...getFormattedMessage(message));\n}\nconst warning = log.bind(null, \"warn\");\nconst error = log.bind(null, \"error\");\nfunction noop$2() {}\nfunction getOptions(shared, fromBinding) {\n    return {\n        ...shared,\n        ...fromBinding\n    };\n}\nfunction bindEvents(el, bindings, sharedOptions) {\n    const unbindings = bindings.map((binding)=>{\n        const options = getOptions(sharedOptions, binding.options);\n        el.addEventListener(binding.eventName, binding.fn, options);\n        return function unbind() {\n            el.removeEventListener(binding.eventName, binding.fn, options);\n        };\n    });\n    return function unbindAll() {\n        unbindings.forEach((unbind)=>{\n            unbind();\n        });\n    };\n}\nconst isProduction = \"development\" === \"production\";\nconst prefix$1 = \"Invariant failed\";\nclass RbdInvariant extends Error {\n}\nRbdInvariant.prototype.toString = function toString() {\n    return this.message;\n};\nfunction invariant(condition, message) {\n    if (condition) {\n        return;\n    }\n    if (isProduction) {\n        throw new RbdInvariant(prefix$1);\n    } else {\n        throw new RbdInvariant(`${prefix$1}: ${message || \"\"}`);\n    }\n}\nclass ErrorBoundary extends (react__WEBPACK_IMPORTED_MODULE_0___default().Component) {\n    constructor(...args){\n        super(...args);\n        this.callbacks = null;\n        this.unbind = noop$2;\n        this.onWindowError = (event)=>{\n            const callbacks = this.getCallbacks();\n            if (callbacks.isDragging()) {\n                callbacks.tryAbort();\n                 true ? warning(`\n        An error was caught by our window 'error' event listener while a drag was occurring.\n        The active drag has been aborted.\n      `) : 0;\n            }\n            const err = event.error;\n            if (err instanceof RbdInvariant) {\n                event.preventDefault();\n                if (true) {\n                    error(err.message);\n                }\n            }\n        };\n        this.getCallbacks = ()=>{\n            if (!this.callbacks) {\n                throw new Error(\"Unable to find AppCallbacks in <ErrorBoundary/>\");\n            }\n            return this.callbacks;\n        };\n        this.setCallbacks = (callbacks)=>{\n            this.callbacks = callbacks;\n        };\n    }\n    componentDidMount() {\n        this.unbind = bindEvents(window, [\n            {\n                eventName: \"error\",\n                fn: this.onWindowError\n            }\n        ]);\n    }\n    componentDidCatch(err) {\n        if (err instanceof RbdInvariant) {\n            if (true) {\n                error(err.message);\n            }\n            this.setState({});\n            return;\n        }\n        throw err;\n    }\n    componentWillUnmount() {\n        this.unbind();\n    }\n    render() {\n        return this.props.children(this.setCallbacks);\n    }\n}\nconst dragHandleUsageInstructions = `\n  Press space bar to start a drag.\n  When dragging you can use the arrow keys to move the item around and escape to cancel.\n  Some screen readers may require you to be in focus mode or to use your pass through key\n`;\nconst position = (index)=>index + 1;\nconst onDragStart = (start)=>`\n  You have lifted an item in position ${position(start.source.index)}\n`;\nconst withLocation = (source, destination)=>{\n    const isInHomeList = source.droppableId === destination.droppableId;\n    const startPosition = position(source.index);\n    const endPosition = position(destination.index);\n    if (isInHomeList) {\n        return `\n      You have moved the item from position ${startPosition}\n      to position ${endPosition}\n    `;\n    }\n    return `\n    You have moved the item from position ${startPosition}\n    in list ${source.droppableId}\n    to list ${destination.droppableId}\n    in position ${endPosition}\n  `;\n};\nconst withCombine = (id, source, combine)=>{\n    const inHomeList = source.droppableId === combine.droppableId;\n    if (inHomeList) {\n        return `\n      The item ${id}\n      has been combined with ${combine.draggableId}`;\n    }\n    return `\n      The item ${id}\n      in list ${source.droppableId}\n      has been combined with ${combine.draggableId}\n      in list ${combine.droppableId}\n    `;\n};\nconst onDragUpdate = (update)=>{\n    const location = update.destination;\n    if (location) {\n        return withLocation(update.source, location);\n    }\n    const combine = update.combine;\n    if (combine) {\n        return withCombine(update.draggableId, update.source, combine);\n    }\n    return \"You are over an area that cannot be dropped on\";\n};\nconst returnedToStart = (source)=>`\n  The item has returned to its starting position\n  of ${position(source.index)}\n`;\nconst onDragEnd = (result)=>{\n    if (result.reason === \"CANCEL\") {\n        return `\n      Movement cancelled.\n      ${returnedToStart(result.source)}\n    `;\n    }\n    const location = result.destination;\n    const combine = result.combine;\n    if (location) {\n        return `\n      You have dropped the item.\n      ${withLocation(result.source, location)}\n    `;\n    }\n    if (combine) {\n        return `\n      You have dropped the item.\n      ${withCombine(result.draggableId, result.source, combine)}\n    `;\n    }\n    return `\n    The item has been dropped while not over a drop area.\n    ${returnedToStart(result.source)}\n  `;\n};\nconst preset = {\n    dragHandleUsageInstructions,\n    onDragStart,\n    onDragUpdate,\n    onDragEnd\n};\nvar preset$1 = preset;\nconst origin = {\n    x: 0,\n    y: 0\n};\nconst add = (point1, point2)=>({\n        x: point1.x + point2.x,\n        y: point1.y + point2.y\n    });\nconst subtract = (point1, point2)=>({\n        x: point1.x - point2.x,\n        y: point1.y - point2.y\n    });\nconst isEqual$1 = (point1, point2)=>point1.x === point2.x && point1.y === point2.y;\nconst negate = (point)=>({\n        x: point.x !== 0 ? -point.x : 0,\n        y: point.y !== 0 ? -point.y : 0\n    });\nconst patch = (line, value, otherValue = 0)=>{\n    if (line === \"x\") {\n        return {\n            x: value,\n            y: otherValue\n        };\n    }\n    return {\n        x: otherValue,\n        y: value\n    };\n};\nconst distance = (point1, point2)=>Math.sqrt((point2.x - point1.x) ** 2 + (point2.y - point1.y) ** 2);\nconst closest$1 = (target, points)=>Math.min(...points.map((point)=>distance(target, point)));\nconst apply = (fn)=>(point)=>({\n            x: fn(point.x),\n            y: fn(point.y)\n        });\nvar executeClip = (frame, subject)=>{\n    const result = (0,css_box_model__WEBPACK_IMPORTED_MODULE_4__.getRect)({\n        top: Math.max(subject.top, frame.top),\n        right: Math.min(subject.right, frame.right),\n        bottom: Math.min(subject.bottom, frame.bottom),\n        left: Math.max(subject.left, frame.left)\n    });\n    if (result.width <= 0 || result.height <= 0) {\n        return null;\n    }\n    return result;\n};\nconst offsetByPosition = (spacing, point)=>({\n        top: spacing.top + point.y,\n        left: spacing.left + point.x,\n        bottom: spacing.bottom + point.y,\n        right: spacing.right + point.x\n    });\nconst getCorners = (spacing)=>[\n        {\n            x: spacing.left,\n            y: spacing.top\n        },\n        {\n            x: spacing.right,\n            y: spacing.top\n        },\n        {\n            x: spacing.left,\n            y: spacing.bottom\n        },\n        {\n            x: spacing.right,\n            y: spacing.bottom\n        }\n    ];\nconst noSpacing = {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n};\nconst scroll$1 = (target, frame)=>{\n    if (!frame) {\n        return target;\n    }\n    return offsetByPosition(target, frame.scroll.diff.displacement);\n};\nconst increase = (target, axis, withPlaceholder)=>{\n    if (withPlaceholder && withPlaceholder.increasedBy) {\n        return {\n            ...target,\n            [axis.end]: target[axis.end] + withPlaceholder.increasedBy[axis.line]\n        };\n    }\n    return target;\n};\nconst clip = (target, frame)=>{\n    if (frame && frame.shouldClipSubject) {\n        return executeClip(frame.pageMarginBox, target);\n    }\n    return (0,css_box_model__WEBPACK_IMPORTED_MODULE_4__.getRect)(target);\n};\nvar getSubject = ({ page, withPlaceholder, axis, frame })=>{\n    const scrolled = scroll$1(page.marginBox, frame);\n    const increased = increase(scrolled, axis, withPlaceholder);\n    const clipped = clip(increased, frame);\n    return {\n        page,\n        withPlaceholder,\n        active: clipped\n    };\n};\nvar scrollDroppable = (droppable, newScroll)=>{\n    !droppable.frame ?  true ? invariant(false) : 0 : void 0;\n    const scrollable = droppable.frame;\n    const scrollDiff = subtract(newScroll, scrollable.scroll.initial);\n    const scrollDisplacement = negate(scrollDiff);\n    const frame = {\n        ...scrollable,\n        scroll: {\n            initial: scrollable.scroll.initial,\n            current: newScroll,\n            diff: {\n                value: scrollDiff,\n                displacement: scrollDisplacement\n            },\n            max: scrollable.scroll.max\n        }\n    };\n    const subject = getSubject({\n        page: droppable.subject.page,\n        withPlaceholder: droppable.subject.withPlaceholder,\n        axis: droppable.axis,\n        frame\n    });\n    const result = {\n        ...droppable,\n        frame,\n        subject\n    };\n    return result;\n};\nconst toDroppableMap = (0,memoize_one__WEBPACK_IMPORTED_MODULE_5__[\"default\"])((droppables)=>droppables.reduce((previous, current)=>{\n        previous[current.descriptor.id] = current;\n        return previous;\n    }, {}));\nconst toDraggableMap = (0,memoize_one__WEBPACK_IMPORTED_MODULE_5__[\"default\"])((draggables)=>draggables.reduce((previous, current)=>{\n        previous[current.descriptor.id] = current;\n        return previous;\n    }, {}));\nconst toDroppableList = (0,memoize_one__WEBPACK_IMPORTED_MODULE_5__[\"default\"])((droppables)=>Object.values(droppables));\nconst toDraggableList = (0,memoize_one__WEBPACK_IMPORTED_MODULE_5__[\"default\"])((draggables)=>Object.values(draggables));\nvar getDraggablesInsideDroppable = (0,memoize_one__WEBPACK_IMPORTED_MODULE_5__[\"default\"])((droppableId, draggables)=>{\n    const result = toDraggableList(draggables).filter((draggable)=>droppableId === draggable.descriptor.droppableId).sort((a, b)=>a.descriptor.index - b.descriptor.index);\n    return result;\n});\nfunction tryGetDestination(impact) {\n    if (impact.at && impact.at.type === \"REORDER\") {\n        return impact.at.destination;\n    }\n    return null;\n}\nfunction tryGetCombine(impact) {\n    if (impact.at && impact.at.type === \"COMBINE\") {\n        return impact.at.combine;\n    }\n    return null;\n}\nvar removeDraggableFromList = (0,memoize_one__WEBPACK_IMPORTED_MODULE_5__[\"default\"])((remove, list)=>list.filter((item)=>item.descriptor.id !== remove.descriptor.id));\nvar moveToNextCombine = ({ isMovingForward, draggable, destination, insideDestination, previousImpact })=>{\n    if (!destination.isCombineEnabled) {\n        return null;\n    }\n    const location = tryGetDestination(previousImpact);\n    if (!location) {\n        return null;\n    }\n    function getImpact(target) {\n        const at = {\n            type: \"COMBINE\",\n            combine: {\n                draggableId: target,\n                droppableId: destination.descriptor.id\n            }\n        };\n        return {\n            ...previousImpact,\n            at\n        };\n    }\n    const all = previousImpact.displaced.all;\n    const closestId = all.length ? all[0] : null;\n    if (isMovingForward) {\n        return closestId ? getImpact(closestId) : null;\n    }\n    const withoutDraggable = removeDraggableFromList(draggable, insideDestination);\n    if (!closestId) {\n        if (!withoutDraggable.length) {\n            return null;\n        }\n        const last = withoutDraggable[withoutDraggable.length - 1];\n        return getImpact(last.descriptor.id);\n    }\n    const indexOfClosest = withoutDraggable.findIndex((d)=>d.descriptor.id === closestId);\n    !(indexOfClosest !== -1) ?  true ? invariant(false, \"Could not find displaced item in set\") : 0 : void 0;\n    const proposedIndex = indexOfClosest - 1;\n    if (proposedIndex < 0) {\n        return null;\n    }\n    const before = withoutDraggable[proposedIndex];\n    return getImpact(before.descriptor.id);\n};\nvar isHomeOf = (draggable, destination)=>draggable.descriptor.droppableId === destination.descriptor.id;\nconst noDisplacedBy = {\n    point: origin,\n    value: 0\n};\nconst emptyGroups = {\n    invisible: {},\n    visible: {},\n    all: []\n};\nconst noImpact = {\n    displaced: emptyGroups,\n    displacedBy: noDisplacedBy,\n    at: null\n};\nvar noImpact$1 = noImpact;\nvar isWithin = (lowerBound, upperBound)=>(value)=>lowerBound <= value && value <= upperBound;\nvar isPartiallyVisibleThroughFrame = (frame)=>{\n    const isWithinVertical = isWithin(frame.top, frame.bottom);\n    const isWithinHorizontal = isWithin(frame.left, frame.right);\n    return (subject)=>{\n        const isContained = isWithinVertical(subject.top) && isWithinVertical(subject.bottom) && isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);\n        if (isContained) {\n            return true;\n        }\n        const isPartiallyVisibleVertically = isWithinVertical(subject.top) || isWithinVertical(subject.bottom);\n        const isPartiallyVisibleHorizontally = isWithinHorizontal(subject.left) || isWithinHorizontal(subject.right);\n        const isPartiallyContained = isPartiallyVisibleVertically && isPartiallyVisibleHorizontally;\n        if (isPartiallyContained) {\n            return true;\n        }\n        const isBiggerVertically = subject.top < frame.top && subject.bottom > frame.bottom;\n        const isBiggerHorizontally = subject.left < frame.left && subject.right > frame.right;\n        const isTargetBiggerThanFrame = isBiggerVertically && isBiggerHorizontally;\n        if (isTargetBiggerThanFrame) {\n            return true;\n        }\n        const isTargetBiggerOnOneAxis = isBiggerVertically && isPartiallyVisibleHorizontally || isBiggerHorizontally && isPartiallyVisibleVertically;\n        return isTargetBiggerOnOneAxis;\n    };\n};\nvar isTotallyVisibleThroughFrame = (frame)=>{\n    const isWithinVertical = isWithin(frame.top, frame.bottom);\n    const isWithinHorizontal = isWithin(frame.left, frame.right);\n    return (subject)=>{\n        const isContained = isWithinVertical(subject.top) && isWithinVertical(subject.bottom) && isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);\n        return isContained;\n    };\n};\nconst vertical = {\n    direction: \"vertical\",\n    line: \"y\",\n    crossAxisLine: \"x\",\n    start: \"top\",\n    end: \"bottom\",\n    size: \"height\",\n    crossAxisStart: \"left\",\n    crossAxisEnd: \"right\",\n    crossAxisSize: \"width\"\n};\nconst horizontal = {\n    direction: \"horizontal\",\n    line: \"x\",\n    crossAxisLine: \"y\",\n    start: \"left\",\n    end: \"right\",\n    size: \"width\",\n    crossAxisStart: \"top\",\n    crossAxisEnd: \"bottom\",\n    crossAxisSize: \"height\"\n};\nvar isTotallyVisibleThroughFrameOnAxis = (axis)=>(frame)=>{\n        const isWithinVertical = isWithin(frame.top, frame.bottom);\n        const isWithinHorizontal = isWithin(frame.left, frame.right);\n        return (subject)=>{\n            if (axis === vertical) {\n                return isWithinVertical(subject.top) && isWithinVertical(subject.bottom);\n            }\n            return isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);\n        };\n    };\nconst getDroppableDisplaced = (target, destination)=>{\n    const displacement = destination.frame ? destination.frame.scroll.diff.displacement : origin;\n    return offsetByPosition(target, displacement);\n};\nconst isVisibleInDroppable = (target, destination, isVisibleThroughFrameFn)=>{\n    if (!destination.subject.active) {\n        return false;\n    }\n    return isVisibleThroughFrameFn(destination.subject.active)(target);\n};\nconst isVisibleInViewport = (target, viewport, isVisibleThroughFrameFn)=>isVisibleThroughFrameFn(viewport)(target);\nconst isVisible$1 = ({ target: toBeDisplaced, destination, viewport, withDroppableDisplacement, isVisibleThroughFrameFn })=>{\n    const displacedTarget = withDroppableDisplacement ? getDroppableDisplaced(toBeDisplaced, destination) : toBeDisplaced;\n    return isVisibleInDroppable(displacedTarget, destination, isVisibleThroughFrameFn) && isVisibleInViewport(displacedTarget, viewport, isVisibleThroughFrameFn);\n};\nconst isPartiallyVisible = (args)=>isVisible$1({\n        ...args,\n        isVisibleThroughFrameFn: isPartiallyVisibleThroughFrame\n    });\nconst isTotallyVisible = (args)=>isVisible$1({\n        ...args,\n        isVisibleThroughFrameFn: isTotallyVisibleThroughFrame\n    });\nconst isTotallyVisibleOnAxis = (args)=>isVisible$1({\n        ...args,\n        isVisibleThroughFrameFn: isTotallyVisibleThroughFrameOnAxis(args.destination.axis)\n    });\nconst getShouldAnimate = (id, last, forceShouldAnimate)=>{\n    if (typeof forceShouldAnimate === \"boolean\") {\n        return forceShouldAnimate;\n    }\n    if (!last) {\n        return true;\n    }\n    const { invisible, visible } = last;\n    if (invisible[id]) {\n        return false;\n    }\n    const previous = visible[id];\n    return previous ? previous.shouldAnimate : true;\n};\nfunction getTarget(draggable, displacedBy) {\n    const marginBox = draggable.page.marginBox;\n    const expandBy = {\n        top: displacedBy.point.y,\n        right: 0,\n        bottom: 0,\n        left: displacedBy.point.x\n    };\n    return (0,css_box_model__WEBPACK_IMPORTED_MODULE_4__.getRect)((0,css_box_model__WEBPACK_IMPORTED_MODULE_4__.expand)(marginBox, expandBy));\n}\nfunction getDisplacementGroups({ afterDragging, destination, displacedBy, viewport, forceShouldAnimate, last }) {\n    return afterDragging.reduce(function process(groups, draggable) {\n        const target = getTarget(draggable, displacedBy);\n        const id = draggable.descriptor.id;\n        groups.all.push(id);\n        const isVisible = isPartiallyVisible({\n            target,\n            destination,\n            viewport,\n            withDroppableDisplacement: true\n        });\n        if (!isVisible) {\n            groups.invisible[draggable.descriptor.id] = true;\n            return groups;\n        }\n        const shouldAnimate = getShouldAnimate(id, last, forceShouldAnimate);\n        const displacement = {\n            draggableId: id,\n            shouldAnimate\n        };\n        groups.visible[id] = displacement;\n        return groups;\n    }, {\n        all: [],\n        visible: {},\n        invisible: {}\n    });\n}\nfunction getIndexOfLastItem(draggables, options) {\n    if (!draggables.length) {\n        return 0;\n    }\n    const indexOfLastItem = draggables[draggables.length - 1].descriptor.index;\n    return options.inHomeList ? indexOfLastItem : indexOfLastItem + 1;\n}\nfunction goAtEnd({ insideDestination, inHomeList, displacedBy, destination }) {\n    const newIndex = getIndexOfLastItem(insideDestination, {\n        inHomeList\n    });\n    return {\n        displaced: emptyGroups,\n        displacedBy,\n        at: {\n            type: \"REORDER\",\n            destination: {\n                droppableId: destination.descriptor.id,\n                index: newIndex\n            }\n        }\n    };\n}\nfunction calculateReorderImpact({ draggable, insideDestination, destination, viewport, displacedBy, last, index, forceShouldAnimate }) {\n    const inHomeList = isHomeOf(draggable, destination);\n    if (index == null) {\n        return goAtEnd({\n            insideDestination,\n            inHomeList,\n            displacedBy,\n            destination\n        });\n    }\n    const match = insideDestination.find((item)=>item.descriptor.index === index);\n    if (!match) {\n        return goAtEnd({\n            insideDestination,\n            inHomeList,\n            displacedBy,\n            destination\n        });\n    }\n    const withoutDragging = removeDraggableFromList(draggable, insideDestination);\n    const sliceFrom = insideDestination.indexOf(match);\n    const impacted = withoutDragging.slice(sliceFrom);\n    const displaced = getDisplacementGroups({\n        afterDragging: impacted,\n        destination,\n        displacedBy,\n        last,\n        viewport: viewport.frame,\n        forceShouldAnimate\n    });\n    return {\n        displaced,\n        displacedBy,\n        at: {\n            type: \"REORDER\",\n            destination: {\n                droppableId: destination.descriptor.id,\n                index\n            }\n        }\n    };\n}\nfunction didStartAfterCritical(draggableId, afterCritical) {\n    return Boolean(afterCritical.effected[draggableId]);\n}\nvar fromCombine = ({ isMovingForward, destination, draggables, combine, afterCritical })=>{\n    if (!destination.isCombineEnabled) {\n        return null;\n    }\n    const combineId = combine.draggableId;\n    const combineWith = draggables[combineId];\n    const combineWithIndex = combineWith.descriptor.index;\n    const didCombineWithStartAfterCritical = didStartAfterCritical(combineId, afterCritical);\n    if (didCombineWithStartAfterCritical) {\n        if (isMovingForward) {\n            return combineWithIndex;\n        }\n        return combineWithIndex - 1;\n    }\n    if (isMovingForward) {\n        return combineWithIndex + 1;\n    }\n    return combineWithIndex;\n};\nvar fromReorder = ({ isMovingForward, isInHomeList, insideDestination, location })=>{\n    if (!insideDestination.length) {\n        return null;\n    }\n    const currentIndex = location.index;\n    const proposedIndex = isMovingForward ? currentIndex + 1 : currentIndex - 1;\n    const firstIndex = insideDestination[0].descriptor.index;\n    const lastIndex = insideDestination[insideDestination.length - 1].descriptor.index;\n    const upperBound = isInHomeList ? lastIndex : lastIndex + 1;\n    if (proposedIndex < firstIndex) {\n        return null;\n    }\n    if (proposedIndex > upperBound) {\n        return null;\n    }\n    return proposedIndex;\n};\nvar moveToNextIndex = ({ isMovingForward, isInHomeList, draggable, draggables, destination, insideDestination, previousImpact, viewport, afterCritical })=>{\n    const wasAt = previousImpact.at;\n    !wasAt ?  true ? invariant(false, \"Cannot move in direction without previous impact location\") : 0 : void 0;\n    if (wasAt.type === \"REORDER\") {\n        const newIndex = fromReorder({\n            isMovingForward,\n            isInHomeList,\n            location: wasAt.destination,\n            insideDestination\n        });\n        if (newIndex == null) {\n            return null;\n        }\n        return calculateReorderImpact({\n            draggable,\n            insideDestination,\n            destination,\n            viewport,\n            last: previousImpact.displaced,\n            displacedBy: previousImpact.displacedBy,\n            index: newIndex\n        });\n    }\n    const newIndex = fromCombine({\n        isMovingForward,\n        destination,\n        displaced: previousImpact.displaced,\n        draggables,\n        combine: wasAt.combine,\n        afterCritical\n    });\n    if (newIndex == null) {\n        return null;\n    }\n    return calculateReorderImpact({\n        draggable,\n        insideDestination,\n        destination,\n        viewport,\n        last: previousImpact.displaced,\n        displacedBy: previousImpact.displacedBy,\n        index: newIndex\n    });\n};\nvar getCombinedItemDisplacement = ({ displaced, afterCritical, combineWith, displacedBy })=>{\n    const isDisplaced = Boolean(displaced.visible[combineWith] || displaced.invisible[combineWith]);\n    if (didStartAfterCritical(combineWith, afterCritical)) {\n        return isDisplaced ? origin : negate(displacedBy.point);\n    }\n    return isDisplaced ? displacedBy.point : origin;\n};\nvar whenCombining = ({ afterCritical, impact, draggables })=>{\n    const combine = tryGetCombine(impact);\n    !combine ?  true ? invariant(false) : 0 : void 0;\n    const combineWith = combine.draggableId;\n    const center = draggables[combineWith].page.borderBox.center;\n    const displaceBy = getCombinedItemDisplacement({\n        displaced: impact.displaced,\n        afterCritical,\n        combineWith,\n        displacedBy: impact.displacedBy\n    });\n    return add(center, displaceBy);\n};\nconst distanceFromStartToBorderBoxCenter = (axis, box)=>box.margin[axis.start] + box.borderBox[axis.size] / 2;\nconst distanceFromEndToBorderBoxCenter = (axis, box)=>box.margin[axis.end] + box.borderBox[axis.size] / 2;\nconst getCrossAxisBorderBoxCenter = (axis, target, isMoving)=>target[axis.crossAxisStart] + isMoving.margin[axis.crossAxisStart] + isMoving.borderBox[axis.crossAxisSize] / 2;\nconst goAfter = ({ axis, moveRelativeTo, isMoving })=>patch(axis.line, moveRelativeTo.marginBox[axis.end] + distanceFromStartToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveRelativeTo.marginBox, isMoving));\nconst goBefore = ({ axis, moveRelativeTo, isMoving })=>patch(axis.line, moveRelativeTo.marginBox[axis.start] - distanceFromEndToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveRelativeTo.marginBox, isMoving));\nconst goIntoStart = ({ axis, moveInto, isMoving })=>patch(axis.line, moveInto.contentBox[axis.start] + distanceFromStartToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveInto.contentBox, isMoving));\nvar whenReordering = ({ impact, draggable, draggables, droppable, afterCritical })=>{\n    const insideDestination = getDraggablesInsideDroppable(droppable.descriptor.id, draggables);\n    const draggablePage = draggable.page;\n    const axis = droppable.axis;\n    if (!insideDestination.length) {\n        return goIntoStart({\n            axis,\n            moveInto: droppable.page,\n            isMoving: draggablePage\n        });\n    }\n    const { displaced, displacedBy } = impact;\n    const closestAfter = displaced.all[0];\n    if (closestAfter) {\n        const closest = draggables[closestAfter];\n        if (didStartAfterCritical(closestAfter, afterCritical)) {\n            return goBefore({\n                axis,\n                moveRelativeTo: closest.page,\n                isMoving: draggablePage\n            });\n        }\n        const withDisplacement = (0,css_box_model__WEBPACK_IMPORTED_MODULE_4__.offset)(closest.page, displacedBy.point);\n        return goBefore({\n            axis,\n            moveRelativeTo: withDisplacement,\n            isMoving: draggablePage\n        });\n    }\n    const last = insideDestination[insideDestination.length - 1];\n    if (last.descriptor.id === draggable.descriptor.id) {\n        return draggablePage.borderBox.center;\n    }\n    if (didStartAfterCritical(last.descriptor.id, afterCritical)) {\n        const page = (0,css_box_model__WEBPACK_IMPORTED_MODULE_4__.offset)(last.page, negate(afterCritical.displacedBy.point));\n        return goAfter({\n            axis,\n            moveRelativeTo: page,\n            isMoving: draggablePage\n        });\n    }\n    return goAfter({\n        axis,\n        moveRelativeTo: last.page,\n        isMoving: draggablePage\n    });\n};\nvar withDroppableDisplacement = (droppable, point)=>{\n    const frame = droppable.frame;\n    if (!frame) {\n        return point;\n    }\n    return add(point, frame.scroll.diff.displacement);\n};\nconst getResultWithoutDroppableDisplacement = ({ impact, draggable, droppable, draggables, afterCritical })=>{\n    const original = draggable.page.borderBox.center;\n    const at = impact.at;\n    if (!droppable) {\n        return original;\n    }\n    if (!at) {\n        return original;\n    }\n    if (at.type === \"REORDER\") {\n        return whenReordering({\n            impact,\n            draggable,\n            draggables,\n            droppable,\n            afterCritical\n        });\n    }\n    return whenCombining({\n        impact,\n        draggables,\n        afterCritical\n    });\n};\nvar getPageBorderBoxCenterFromImpact = (args)=>{\n    const withoutDisplacement = getResultWithoutDroppableDisplacement(args);\n    const droppable = args.droppable;\n    const withDisplacement = droppable ? withDroppableDisplacement(droppable, withoutDisplacement) : withoutDisplacement;\n    return withDisplacement;\n};\nvar scrollViewport = (viewport, newScroll)=>{\n    const diff = subtract(newScroll, viewport.scroll.initial);\n    const displacement = negate(diff);\n    const frame = (0,css_box_model__WEBPACK_IMPORTED_MODULE_4__.getRect)({\n        top: newScroll.y,\n        bottom: newScroll.y + viewport.frame.height,\n        left: newScroll.x,\n        right: newScroll.x + viewport.frame.width\n    });\n    const updated = {\n        frame,\n        scroll: {\n            initial: viewport.scroll.initial,\n            max: viewport.scroll.max,\n            current: newScroll,\n            diff: {\n                value: diff,\n                displacement\n            }\n        }\n    };\n    return updated;\n};\nfunction getDraggables$1(ids, draggables) {\n    return ids.map((id)=>draggables[id]);\n}\nfunction tryGetVisible(id, groups) {\n    for(let i = 0; i < groups.length; i++){\n        const displacement = groups[i].visible[id];\n        if (displacement) {\n            return displacement;\n        }\n    }\n    return null;\n}\nvar speculativelyIncrease = ({ impact, viewport, destination, draggables, maxScrollChange })=>{\n    const scrolledViewport = scrollViewport(viewport, add(viewport.scroll.current, maxScrollChange));\n    const scrolledDroppable = destination.frame ? scrollDroppable(destination, add(destination.frame.scroll.current, maxScrollChange)) : destination;\n    const last = impact.displaced;\n    const withViewportScroll = getDisplacementGroups({\n        afterDragging: getDraggables$1(last.all, draggables),\n        destination,\n        displacedBy: impact.displacedBy,\n        viewport: scrolledViewport.frame,\n        last,\n        forceShouldAnimate: false\n    });\n    const withDroppableScroll = getDisplacementGroups({\n        afterDragging: getDraggables$1(last.all, draggables),\n        destination: scrolledDroppable,\n        displacedBy: impact.displacedBy,\n        viewport: viewport.frame,\n        last,\n        forceShouldAnimate: false\n    });\n    const invisible = {};\n    const visible = {};\n    const groups = [\n        last,\n        withViewportScroll,\n        withDroppableScroll\n    ];\n    last.all.forEach((id)=>{\n        const displacement = tryGetVisible(id, groups);\n        if (displacement) {\n            visible[id] = displacement;\n            return;\n        }\n        invisible[id] = true;\n    });\n    const newImpact = {\n        ...impact,\n        displaced: {\n            all: last.all,\n            invisible,\n            visible\n        }\n    };\n    return newImpact;\n};\nvar withViewportDisplacement = (viewport, point)=>add(viewport.scroll.diff.displacement, point);\nvar getClientFromPageBorderBoxCenter = ({ pageBorderBoxCenter, draggable, viewport })=>{\n    const withoutPageScrollChange = withViewportDisplacement(viewport, pageBorderBoxCenter);\n    const offset = subtract(withoutPageScrollChange, draggable.page.borderBox.center);\n    return add(draggable.client.borderBox.center, offset);\n};\nvar isTotallyVisibleInNewLocation = ({ draggable, destination, newPageBorderBoxCenter, viewport, withDroppableDisplacement, onlyOnMainAxis = false })=>{\n    const changeNeeded = subtract(newPageBorderBoxCenter, draggable.page.borderBox.center);\n    const shifted = offsetByPosition(draggable.page.borderBox, changeNeeded);\n    const args = {\n        target: shifted,\n        destination,\n        withDroppableDisplacement,\n        viewport\n    };\n    return onlyOnMainAxis ? isTotallyVisibleOnAxis(args) : isTotallyVisible(args);\n};\nvar moveToNextPlace = ({ isMovingForward, draggable, destination, draggables, previousImpact, viewport, previousPageBorderBoxCenter, previousClientSelection, afterCritical })=>{\n    if (!destination.isEnabled) {\n        return null;\n    }\n    const insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);\n    const isInHomeList = isHomeOf(draggable, destination);\n    const impact = moveToNextCombine({\n        isMovingForward,\n        draggable,\n        destination,\n        insideDestination,\n        previousImpact\n    }) || moveToNextIndex({\n        isMovingForward,\n        isInHomeList,\n        draggable,\n        draggables,\n        destination,\n        insideDestination,\n        previousImpact,\n        viewport,\n        afterCritical\n    });\n    if (!impact) {\n        return null;\n    }\n    const pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({\n        impact,\n        draggable,\n        droppable: destination,\n        draggables,\n        afterCritical\n    });\n    const isVisibleInNewLocation = isTotallyVisibleInNewLocation({\n        draggable,\n        destination,\n        newPageBorderBoxCenter: pageBorderBoxCenter,\n        viewport: viewport.frame,\n        withDroppableDisplacement: false,\n        onlyOnMainAxis: true\n    });\n    if (isVisibleInNewLocation) {\n        const clientSelection = getClientFromPageBorderBoxCenter({\n            pageBorderBoxCenter,\n            draggable,\n            viewport\n        });\n        return {\n            clientSelection,\n            impact,\n            scrollJumpRequest: null\n        };\n    }\n    const distance = subtract(pageBorderBoxCenter, previousPageBorderBoxCenter);\n    const cautious = speculativelyIncrease({\n        impact,\n        viewport,\n        destination,\n        draggables,\n        maxScrollChange: distance\n    });\n    return {\n        clientSelection: previousClientSelection,\n        impact: cautious,\n        scrollJumpRequest: distance\n    };\n};\nconst getKnownActive = (droppable)=>{\n    const rect = droppable.subject.active;\n    !rect ?  true ? invariant(false, \"Cannot get clipped area from droppable\") : 0 : void 0;\n    return rect;\n};\nvar getBestCrossAxisDroppable = ({ isMovingForward, pageBorderBoxCenter, source, droppables, viewport })=>{\n    const active = source.subject.active;\n    if (!active) {\n        return null;\n    }\n    const axis = source.axis;\n    const isBetweenSourceClipped = isWithin(active[axis.start], active[axis.end]);\n    const candidates = toDroppableList(droppables).filter((droppable)=>droppable !== source).filter((droppable)=>droppable.isEnabled).filter((droppable)=>Boolean(droppable.subject.active)).filter((droppable)=>isPartiallyVisibleThroughFrame(viewport.frame)(getKnownActive(droppable))).filter((droppable)=>{\n        const activeOfTarget = getKnownActive(droppable);\n        if (isMovingForward) {\n            return active[axis.crossAxisEnd] < activeOfTarget[axis.crossAxisEnd];\n        }\n        return activeOfTarget[axis.crossAxisStart] < active[axis.crossAxisStart];\n    }).filter((droppable)=>{\n        const activeOfTarget = getKnownActive(droppable);\n        const isBetweenDestinationClipped = isWithin(activeOfTarget[axis.start], activeOfTarget[axis.end]);\n        return isBetweenSourceClipped(activeOfTarget[axis.start]) || isBetweenSourceClipped(activeOfTarget[axis.end]) || isBetweenDestinationClipped(active[axis.start]) || isBetweenDestinationClipped(active[axis.end]);\n    }).sort((a, b)=>{\n        const first = getKnownActive(a)[axis.crossAxisStart];\n        const second = getKnownActive(b)[axis.crossAxisStart];\n        if (isMovingForward) {\n            return first - second;\n        }\n        return second - first;\n    }).filter((droppable, index, array)=>getKnownActive(droppable)[axis.crossAxisStart] === getKnownActive(array[0])[axis.crossAxisStart]);\n    if (!candidates.length) {\n        return null;\n    }\n    if (candidates.length === 1) {\n        return candidates[0];\n    }\n    const contains = candidates.filter((droppable)=>{\n        const isWithinDroppable = isWithin(getKnownActive(droppable)[axis.start], getKnownActive(droppable)[axis.end]);\n        return isWithinDroppable(pageBorderBoxCenter[axis.line]);\n    });\n    if (contains.length === 1) {\n        return contains[0];\n    }\n    if (contains.length > 1) {\n        return contains.sort((a, b)=>getKnownActive(a)[axis.start] - getKnownActive(b)[axis.start])[0];\n    }\n    return candidates.sort((a, b)=>{\n        const first = closest$1(pageBorderBoxCenter, getCorners(getKnownActive(a)));\n        const second = closest$1(pageBorderBoxCenter, getCorners(getKnownActive(b)));\n        if (first !== second) {\n            return first - second;\n        }\n        return getKnownActive(a)[axis.start] - getKnownActive(b)[axis.start];\n    })[0];\n};\nconst getCurrentPageBorderBoxCenter = (draggable, afterCritical)=>{\n    const original = draggable.page.borderBox.center;\n    return didStartAfterCritical(draggable.descriptor.id, afterCritical) ? subtract(original, afterCritical.displacedBy.point) : original;\n};\nconst getCurrentPageBorderBox = (draggable, afterCritical)=>{\n    const original = draggable.page.borderBox;\n    return didStartAfterCritical(draggable.descriptor.id, afterCritical) ? offsetByPosition(original, negate(afterCritical.displacedBy.point)) : original;\n};\nvar getClosestDraggable = ({ pageBorderBoxCenter, viewport, destination, insideDestination, afterCritical })=>{\n    const sorted = insideDestination.filter((draggable)=>isTotallyVisible({\n            target: getCurrentPageBorderBox(draggable, afterCritical),\n            destination,\n            viewport: viewport.frame,\n            withDroppableDisplacement: true\n        })).sort((a, b)=>{\n        const distanceToA = distance(pageBorderBoxCenter, withDroppableDisplacement(destination, getCurrentPageBorderBoxCenter(a, afterCritical)));\n        const distanceToB = distance(pageBorderBoxCenter, withDroppableDisplacement(destination, getCurrentPageBorderBoxCenter(b, afterCritical)));\n        if (distanceToA < distanceToB) {\n            return -1;\n        }\n        if (distanceToB < distanceToA) {\n            return 1;\n        }\n        return a.descriptor.index - b.descriptor.index;\n    });\n    return sorted[0] || null;\n};\nvar getDisplacedBy = (0,memoize_one__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(function getDisplacedBy(axis, displaceBy) {\n    const displacement = displaceBy[axis.line];\n    return {\n        value: displacement,\n        point: patch(axis.line, displacement)\n    };\n});\nconst getRequiredGrowthForPlaceholder = (droppable, placeholderSize, draggables)=>{\n    const axis = droppable.axis;\n    if (droppable.descriptor.mode === \"virtual\") {\n        return patch(axis.line, placeholderSize[axis.line]);\n    }\n    const availableSpace = droppable.subject.page.contentBox[axis.size];\n    const insideDroppable = getDraggablesInsideDroppable(droppable.descriptor.id, draggables);\n    const spaceUsed = insideDroppable.reduce((sum, dimension)=>sum + dimension.client.marginBox[axis.size], 0);\n    const requiredSpace = spaceUsed + placeholderSize[axis.line];\n    const needsToGrowBy = requiredSpace - availableSpace;\n    if (needsToGrowBy <= 0) {\n        return null;\n    }\n    return patch(axis.line, needsToGrowBy);\n};\nconst withMaxScroll = (frame, max)=>({\n        ...frame,\n        scroll: {\n            ...frame.scroll,\n            max\n        }\n    });\nconst addPlaceholder = (droppable, draggable, draggables)=>{\n    const frame = droppable.frame;\n    !!isHomeOf(draggable, droppable) ?  true ? invariant(false, \"Should not add placeholder space to home list\") : 0 : void 0;\n    !!droppable.subject.withPlaceholder ?  true ? invariant(false, \"Cannot add placeholder size to a subject when it already has one\") : 0 : void 0;\n    const placeholderSize = getDisplacedBy(droppable.axis, draggable.displaceBy).point;\n    const requiredGrowth = getRequiredGrowthForPlaceholder(droppable, placeholderSize, draggables);\n    const added = {\n        placeholderSize,\n        increasedBy: requiredGrowth,\n        oldFrameMaxScroll: droppable.frame ? droppable.frame.scroll.max : null\n    };\n    if (!frame) {\n        const subject = getSubject({\n            page: droppable.subject.page,\n            withPlaceholder: added,\n            axis: droppable.axis,\n            frame: droppable.frame\n        });\n        return {\n            ...droppable,\n            subject\n        };\n    }\n    const maxScroll = requiredGrowth ? add(frame.scroll.max, requiredGrowth) : frame.scroll.max;\n    const newFrame = withMaxScroll(frame, maxScroll);\n    const subject = getSubject({\n        page: droppable.subject.page,\n        withPlaceholder: added,\n        axis: droppable.axis,\n        frame: newFrame\n    });\n    return {\n        ...droppable,\n        subject,\n        frame: newFrame\n    };\n};\nconst removePlaceholder = (droppable)=>{\n    const added = droppable.subject.withPlaceholder;\n    !added ?  true ? invariant(false, \"Cannot remove placeholder form subject when there was none\") : 0 : void 0;\n    const frame = droppable.frame;\n    if (!frame) {\n        const subject = getSubject({\n            page: droppable.subject.page,\n            axis: droppable.axis,\n            frame: null,\n            withPlaceholder: null\n        });\n        return {\n            ...droppable,\n            subject\n        };\n    }\n    const oldMaxScroll = added.oldFrameMaxScroll;\n    !oldMaxScroll ?  true ? invariant(false, \"Expected droppable with frame to have old max frame scroll when removing placeholder\") : 0 : void 0;\n    const newFrame = withMaxScroll(frame, oldMaxScroll);\n    const subject = getSubject({\n        page: droppable.subject.page,\n        axis: droppable.axis,\n        frame: newFrame,\n        withPlaceholder: null\n    });\n    return {\n        ...droppable,\n        subject,\n        frame: newFrame\n    };\n};\nvar moveToNewDroppable = ({ previousPageBorderBoxCenter, moveRelativeTo, insideDestination, draggable, draggables, destination, viewport, afterCritical })=>{\n    if (!moveRelativeTo) {\n        if (insideDestination.length) {\n            return null;\n        }\n        const proposed = {\n            displaced: emptyGroups,\n            displacedBy: noDisplacedBy,\n            at: {\n                type: \"REORDER\",\n                destination: {\n                    droppableId: destination.descriptor.id,\n                    index: 0\n                }\n            }\n        };\n        const proposedPageBorderBoxCenter = getPageBorderBoxCenterFromImpact({\n            impact: proposed,\n            draggable,\n            droppable: destination,\n            draggables,\n            afterCritical\n        });\n        const withPlaceholder = isHomeOf(draggable, destination) ? destination : addPlaceholder(destination, draggable, draggables);\n        const isVisibleInNewLocation = isTotallyVisibleInNewLocation({\n            draggable,\n            destination: withPlaceholder,\n            newPageBorderBoxCenter: proposedPageBorderBoxCenter,\n            viewport: viewport.frame,\n            withDroppableDisplacement: false,\n            onlyOnMainAxis: true\n        });\n        return isVisibleInNewLocation ? proposed : null;\n    }\n    const isGoingBeforeTarget = Boolean(previousPageBorderBoxCenter[destination.axis.line] <= moveRelativeTo.page.borderBox.center[destination.axis.line]);\n    const proposedIndex = (()=>{\n        const relativeTo = moveRelativeTo.descriptor.index;\n        if (moveRelativeTo.descriptor.id === draggable.descriptor.id) {\n            return relativeTo;\n        }\n        if (isGoingBeforeTarget) {\n            return relativeTo;\n        }\n        return relativeTo + 1;\n    })();\n    const displacedBy = getDisplacedBy(destination.axis, draggable.displaceBy);\n    return calculateReorderImpact({\n        draggable,\n        insideDestination,\n        destination,\n        viewport,\n        displacedBy,\n        last: emptyGroups,\n        index: proposedIndex\n    });\n};\nvar moveCrossAxis = ({ isMovingForward, previousPageBorderBoxCenter, draggable, isOver, draggables, droppables, viewport, afterCritical })=>{\n    const destination = getBestCrossAxisDroppable({\n        isMovingForward,\n        pageBorderBoxCenter: previousPageBorderBoxCenter,\n        source: isOver,\n        droppables,\n        viewport\n    });\n    if (!destination) {\n        return null;\n    }\n    const insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);\n    const moveRelativeTo = getClosestDraggable({\n        pageBorderBoxCenter: previousPageBorderBoxCenter,\n        viewport,\n        destination,\n        insideDestination,\n        afterCritical\n    });\n    const impact = moveToNewDroppable({\n        previousPageBorderBoxCenter,\n        destination,\n        draggable,\n        draggables,\n        moveRelativeTo,\n        insideDestination,\n        viewport,\n        afterCritical\n    });\n    if (!impact) {\n        return null;\n    }\n    const pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({\n        impact,\n        draggable,\n        droppable: destination,\n        draggables,\n        afterCritical\n    });\n    const clientSelection = getClientFromPageBorderBoxCenter({\n        pageBorderBoxCenter,\n        draggable,\n        viewport\n    });\n    return {\n        clientSelection,\n        impact,\n        scrollJumpRequest: null\n    };\n};\nvar whatIsDraggedOver = (impact)=>{\n    const at = impact.at;\n    if (!at) {\n        return null;\n    }\n    if (at.type === \"REORDER\") {\n        return at.destination.droppableId;\n    }\n    return at.combine.droppableId;\n};\nconst getDroppableOver$1 = (impact, droppables)=>{\n    const id = whatIsDraggedOver(impact);\n    return id ? droppables[id] : null;\n};\nvar moveInDirection = ({ state, type })=>{\n    const isActuallyOver = getDroppableOver$1(state.impact, state.dimensions.droppables);\n    const isMainAxisMovementAllowed = Boolean(isActuallyOver);\n    const home = state.dimensions.droppables[state.critical.droppable.id];\n    const isOver = isActuallyOver || home;\n    const direction = isOver.axis.direction;\n    const isMovingOnMainAxis = direction === \"vertical\" && (type === \"MOVE_UP\" || type === \"MOVE_DOWN\") || direction === \"horizontal\" && (type === \"MOVE_LEFT\" || type === \"MOVE_RIGHT\");\n    if (isMovingOnMainAxis && !isMainAxisMovementAllowed) {\n        return null;\n    }\n    const isMovingForward = type === \"MOVE_DOWN\" || type === \"MOVE_RIGHT\";\n    const draggable = state.dimensions.draggables[state.critical.draggable.id];\n    const previousPageBorderBoxCenter = state.current.page.borderBoxCenter;\n    const { draggables, droppables } = state.dimensions;\n    return isMovingOnMainAxis ? moveToNextPlace({\n        isMovingForward,\n        previousPageBorderBoxCenter,\n        draggable,\n        destination: isOver,\n        draggables,\n        viewport: state.viewport,\n        previousClientSelection: state.current.client.selection,\n        previousImpact: state.impact,\n        afterCritical: state.afterCritical\n    }) : moveCrossAxis({\n        isMovingForward,\n        previousPageBorderBoxCenter,\n        draggable,\n        isOver,\n        draggables,\n        droppables,\n        viewport: state.viewport,\n        afterCritical: state.afterCritical\n    });\n};\nfunction isMovementAllowed(state) {\n    return state.phase === \"DRAGGING\" || state.phase === \"COLLECTING\";\n}\nfunction isPositionInFrame(frame) {\n    const isWithinVertical = isWithin(frame.top, frame.bottom);\n    const isWithinHorizontal = isWithin(frame.left, frame.right);\n    return function run(point) {\n        return isWithinVertical(point.y) && isWithinHorizontal(point.x);\n    };\n}\nfunction getHasOverlap(first, second) {\n    return first.left < second.right && first.right > second.left && first.top < second.bottom && first.bottom > second.top;\n}\nfunction getFurthestAway({ pageBorderBox, draggable, candidates }) {\n    const startCenter = draggable.page.borderBox.center;\n    const sorted = candidates.map((candidate)=>{\n        const axis = candidate.axis;\n        const target = patch(candidate.axis.line, pageBorderBox.center[axis.line], candidate.page.borderBox.center[axis.crossAxisLine]);\n        return {\n            id: candidate.descriptor.id,\n            distance: distance(startCenter, target)\n        };\n    }).sort((a, b)=>b.distance - a.distance);\n    return sorted[0] ? sorted[0].id : null;\n}\nfunction getDroppableOver({ pageBorderBox, draggable, droppables }) {\n    const candidates = toDroppableList(droppables).filter((item)=>{\n        if (!item.isEnabled) {\n            return false;\n        }\n        const active = item.subject.active;\n        if (!active) {\n            return false;\n        }\n        if (!getHasOverlap(pageBorderBox, active)) {\n            return false;\n        }\n        if (isPositionInFrame(active)(pageBorderBox.center)) {\n            return true;\n        }\n        const axis = item.axis;\n        const childCenter = active.center[axis.crossAxisLine];\n        const crossAxisStart = pageBorderBox[axis.crossAxisStart];\n        const crossAxisEnd = pageBorderBox[axis.crossAxisEnd];\n        const isContained = isWithin(active[axis.crossAxisStart], active[axis.crossAxisEnd]);\n        const isStartContained = isContained(crossAxisStart);\n        const isEndContained = isContained(crossAxisEnd);\n        if (!isStartContained && !isEndContained) {\n            return true;\n        }\n        if (isStartContained) {\n            return crossAxisStart < childCenter;\n        }\n        return crossAxisEnd > childCenter;\n    });\n    if (!candidates.length) {\n        return null;\n    }\n    if (candidates.length === 1) {\n        return candidates[0].descriptor.id;\n    }\n    return getFurthestAway({\n        pageBorderBox,\n        draggable,\n        candidates\n    });\n}\nconst offsetRectByPosition = (rect, point)=>(0,css_box_model__WEBPACK_IMPORTED_MODULE_4__.getRect)(offsetByPosition(rect, point));\nvar withDroppableScroll = (droppable, area)=>{\n    const frame = droppable.frame;\n    if (!frame) {\n        return area;\n    }\n    return offsetRectByPosition(area, frame.scroll.diff.value);\n};\nfunction getIsDisplaced({ displaced, id }) {\n    return Boolean(displaced.visible[id] || displaced.invisible[id]);\n}\nfunction atIndex({ draggable, closest, inHomeList }) {\n    if (!closest) {\n        return null;\n    }\n    if (!inHomeList) {\n        return closest.descriptor.index;\n    }\n    if (closest.descriptor.index > draggable.descriptor.index) {\n        return closest.descriptor.index - 1;\n    }\n    return closest.descriptor.index;\n}\nvar getReorderImpact = ({ pageBorderBoxWithDroppableScroll: targetRect, draggable, destination, insideDestination, last, viewport, afterCritical })=>{\n    const axis = destination.axis;\n    const displacedBy = getDisplacedBy(destination.axis, draggable.displaceBy);\n    const displacement = displacedBy.value;\n    const targetStart = targetRect[axis.start];\n    const targetEnd = targetRect[axis.end];\n    const withoutDragging = removeDraggableFromList(draggable, insideDestination);\n    const closest = withoutDragging.find((child)=>{\n        const id = child.descriptor.id;\n        const childCenter = child.page.borderBox.center[axis.line];\n        const didStartAfterCritical$1 = didStartAfterCritical(id, afterCritical);\n        const isDisplaced = getIsDisplaced({\n            displaced: last,\n            id\n        });\n        if (didStartAfterCritical$1) {\n            if (isDisplaced) {\n                return targetEnd <= childCenter;\n            }\n            return targetStart < childCenter - displacement;\n        }\n        if (isDisplaced) {\n            return targetEnd <= childCenter + displacement;\n        }\n        return targetStart < childCenter;\n    }) || null;\n    const newIndex = atIndex({\n        draggable,\n        closest,\n        inHomeList: isHomeOf(draggable, destination)\n    });\n    return calculateReorderImpact({\n        draggable,\n        insideDestination,\n        destination,\n        viewport,\n        last,\n        displacedBy,\n        index: newIndex\n    });\n};\nconst combineThresholdDivisor = 4;\nvar getCombineImpact = ({ draggable, pageBorderBoxWithDroppableScroll: targetRect, previousImpact, destination, insideDestination, afterCritical })=>{\n    if (!destination.isCombineEnabled) {\n        return null;\n    }\n    const axis = destination.axis;\n    const displacedBy = getDisplacedBy(destination.axis, draggable.displaceBy);\n    const displacement = displacedBy.value;\n    const targetStart = targetRect[axis.start];\n    const targetEnd = targetRect[axis.end];\n    const withoutDragging = removeDraggableFromList(draggable, insideDestination);\n    const combineWith = withoutDragging.find((child)=>{\n        const id = child.descriptor.id;\n        const childRect = child.page.borderBox;\n        const childSize = childRect[axis.size];\n        const threshold = childSize / combineThresholdDivisor;\n        const didStartAfterCritical$1 = didStartAfterCritical(id, afterCritical);\n        const isDisplaced = getIsDisplaced({\n            displaced: previousImpact.displaced,\n            id\n        });\n        if (didStartAfterCritical$1) {\n            if (isDisplaced) {\n                return targetEnd > childRect[axis.start] + threshold && targetEnd < childRect[axis.end] - threshold;\n            }\n            return targetStart > childRect[axis.start] - displacement + threshold && targetStart < childRect[axis.end] - displacement - threshold;\n        }\n        if (isDisplaced) {\n            return targetEnd > childRect[axis.start] + displacement + threshold && targetEnd < childRect[axis.end] + displacement - threshold;\n        }\n        return targetStart > childRect[axis.start] + threshold && targetStart < childRect[axis.end] - threshold;\n    });\n    if (!combineWith) {\n        return null;\n    }\n    const impact = {\n        displacedBy,\n        displaced: previousImpact.displaced,\n        at: {\n            type: \"COMBINE\",\n            combine: {\n                draggableId: combineWith.descriptor.id,\n                droppableId: destination.descriptor.id\n            }\n        }\n    };\n    return impact;\n};\nvar getDragImpact = ({ pageOffset, draggable, draggables, droppables, previousImpact, viewport, afterCritical })=>{\n    const pageBorderBox = offsetRectByPosition(draggable.page.borderBox, pageOffset);\n    const destinationId = getDroppableOver({\n        pageBorderBox,\n        draggable,\n        droppables\n    });\n    if (!destinationId) {\n        return noImpact$1;\n    }\n    const destination = droppables[destinationId];\n    const insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);\n    const pageBorderBoxWithDroppableScroll = withDroppableScroll(destination, pageBorderBox);\n    return getCombineImpact({\n        pageBorderBoxWithDroppableScroll,\n        draggable,\n        previousImpact,\n        destination,\n        insideDestination,\n        afterCritical\n    }) || getReorderImpact({\n        pageBorderBoxWithDroppableScroll,\n        draggable,\n        destination,\n        insideDestination,\n        last: previousImpact.displaced,\n        viewport,\n        afterCritical\n    });\n};\nvar patchDroppableMap = (droppables, updated)=>({\n        ...droppables,\n        [updated.descriptor.id]: updated\n    });\nconst clearUnusedPlaceholder = ({ previousImpact, impact, droppables })=>{\n    const last = whatIsDraggedOver(previousImpact);\n    const now = whatIsDraggedOver(impact);\n    if (!last) {\n        return droppables;\n    }\n    if (last === now) {\n        return droppables;\n    }\n    const lastDroppable = droppables[last];\n    if (!lastDroppable.subject.withPlaceholder) {\n        return droppables;\n    }\n    const updated = removePlaceholder(lastDroppable);\n    return patchDroppableMap(droppables, updated);\n};\nvar recomputePlaceholders = ({ draggable, draggables, droppables, previousImpact, impact })=>{\n    const cleaned = clearUnusedPlaceholder({\n        previousImpact,\n        impact,\n        droppables\n    });\n    const isOver = whatIsDraggedOver(impact);\n    if (!isOver) {\n        return cleaned;\n    }\n    const droppable = droppables[isOver];\n    if (isHomeOf(draggable, droppable)) {\n        return cleaned;\n    }\n    if (droppable.subject.withPlaceholder) {\n        return cleaned;\n    }\n    const patched = addPlaceholder(droppable, draggable, draggables);\n    return patchDroppableMap(cleaned, patched);\n};\nvar update = ({ state, clientSelection: forcedClientSelection, dimensions: forcedDimensions, viewport: forcedViewport, impact: forcedImpact, scrollJumpRequest })=>{\n    const viewport = forcedViewport || state.viewport;\n    const dimensions = forcedDimensions || state.dimensions;\n    const clientSelection = forcedClientSelection || state.current.client.selection;\n    const offset = subtract(clientSelection, state.initial.client.selection);\n    const client = {\n        offset,\n        selection: clientSelection,\n        borderBoxCenter: add(state.initial.client.borderBoxCenter, offset)\n    };\n    const page = {\n        selection: add(client.selection, viewport.scroll.current),\n        borderBoxCenter: add(client.borderBoxCenter, viewport.scroll.current),\n        offset: add(client.offset, viewport.scroll.diff.value)\n    };\n    const current = {\n        client,\n        page\n    };\n    if (state.phase === \"COLLECTING\") {\n        return {\n            ...state,\n            dimensions,\n            viewport,\n            current\n        };\n    }\n    const draggable = dimensions.draggables[state.critical.draggable.id];\n    const newImpact = forcedImpact || getDragImpact({\n        pageOffset: page.offset,\n        draggable,\n        draggables: dimensions.draggables,\n        droppables: dimensions.droppables,\n        previousImpact: state.impact,\n        viewport,\n        afterCritical: state.afterCritical\n    });\n    const withUpdatedPlaceholders = recomputePlaceholders({\n        draggable,\n        impact: newImpact,\n        previousImpact: state.impact,\n        draggables: dimensions.draggables,\n        droppables: dimensions.droppables\n    });\n    const result = {\n        ...state,\n        current,\n        dimensions: {\n            draggables: dimensions.draggables,\n            droppables: withUpdatedPlaceholders\n        },\n        impact: newImpact,\n        viewport,\n        scrollJumpRequest: scrollJumpRequest || null,\n        forceShouldAnimate: scrollJumpRequest ? false : null\n    };\n    return result;\n};\nfunction getDraggables(ids, draggables) {\n    return ids.map((id)=>draggables[id]);\n}\nvar recompute = ({ impact, viewport, draggables, destination, forceShouldAnimate })=>{\n    const last = impact.displaced;\n    const afterDragging = getDraggables(last.all, draggables);\n    const displaced = getDisplacementGroups({\n        afterDragging,\n        destination,\n        displacedBy: impact.displacedBy,\n        viewport: viewport.frame,\n        forceShouldAnimate,\n        last\n    });\n    return {\n        ...impact,\n        displaced\n    };\n};\nvar getClientBorderBoxCenter = ({ impact, draggable, droppable, draggables, viewport, afterCritical })=>{\n    const pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({\n        impact,\n        draggable,\n        draggables,\n        droppable,\n        afterCritical\n    });\n    return getClientFromPageBorderBoxCenter({\n        pageBorderBoxCenter,\n        draggable,\n        viewport\n    });\n};\nvar refreshSnap = ({ state, dimensions: forcedDimensions, viewport: forcedViewport })=>{\n    !(state.movementMode === \"SNAP\") ?  true ? invariant(false) : 0 : void 0;\n    const needsVisibilityCheck = state.impact;\n    const viewport = forcedViewport || state.viewport;\n    const dimensions = forcedDimensions || state.dimensions;\n    const { draggables, droppables } = dimensions;\n    const draggable = draggables[state.critical.draggable.id];\n    const isOver = whatIsDraggedOver(needsVisibilityCheck);\n    !isOver ?  true ? invariant(false, \"Must be over a destination in SNAP movement mode\") : 0 : void 0;\n    const destination = droppables[isOver];\n    const impact = recompute({\n        impact: needsVisibilityCheck,\n        viewport,\n        destination,\n        draggables\n    });\n    const clientSelection = getClientBorderBoxCenter({\n        impact,\n        draggable,\n        droppable: destination,\n        draggables,\n        viewport,\n        afterCritical: state.afterCritical\n    });\n    return update({\n        impact,\n        clientSelection,\n        state,\n        dimensions,\n        viewport\n    });\n};\nvar getHomeLocation = (descriptor)=>({\n        index: descriptor.index,\n        droppableId: descriptor.droppableId\n    });\nvar getLiftEffect = ({ draggable, home, draggables, viewport })=>{\n    const displacedBy = getDisplacedBy(home.axis, draggable.displaceBy);\n    const insideHome = getDraggablesInsideDroppable(home.descriptor.id, draggables);\n    const rawIndex = insideHome.indexOf(draggable);\n    !(rawIndex !== -1) ?  true ? invariant(false, \"Expected draggable to be inside home list\") : 0 : void 0;\n    const afterDragging = insideHome.slice(rawIndex + 1);\n    const effected = afterDragging.reduce((previous, item)=>{\n        previous[item.descriptor.id] = true;\n        return previous;\n    }, {});\n    const afterCritical = {\n        inVirtualList: home.descriptor.mode === \"virtual\",\n        displacedBy,\n        effected\n    };\n    const displaced = getDisplacementGroups({\n        afterDragging,\n        destination: home,\n        displacedBy,\n        last: null,\n        viewport: viewport.frame,\n        forceShouldAnimate: false\n    });\n    const impact = {\n        displaced,\n        displacedBy,\n        at: {\n            type: \"REORDER\",\n            destination: getHomeLocation(draggable.descriptor)\n        }\n    };\n    return {\n        impact,\n        afterCritical\n    };\n};\nvar patchDimensionMap = (dimensions, updated)=>({\n        draggables: dimensions.draggables,\n        droppables: patchDroppableMap(dimensions.droppables, updated)\n    });\nconst start = (key)=>{\n    if (true) {\n        {\n            return;\n        }\n    }\n};\nconst finish = (key)=>{\n    if (true) {\n        {\n            return;\n        }\n    }\n};\nvar offsetDraggable = ({ draggable, offset: offset$1, initialWindowScroll })=>{\n    const client = (0,css_box_model__WEBPACK_IMPORTED_MODULE_4__.offset)(draggable.client, offset$1);\n    const page = (0,css_box_model__WEBPACK_IMPORTED_MODULE_4__.withScroll)(client, initialWindowScroll);\n    const moved = {\n        ...draggable,\n        placeholder: {\n            ...draggable.placeholder,\n            client\n        },\n        client,\n        page\n    };\n    return moved;\n};\nvar getFrame = (droppable)=>{\n    const frame = droppable.frame;\n    !frame ?  true ? invariant(false, \"Expected Droppable to have a frame\") : 0 : void 0;\n    return frame;\n};\nvar adjustAdditionsForScrollChanges = ({ additions, updatedDroppables, viewport })=>{\n    const windowScrollChange = viewport.scroll.diff.value;\n    return additions.map((draggable)=>{\n        const droppableId = draggable.descriptor.droppableId;\n        const modified = updatedDroppables[droppableId];\n        const frame = getFrame(modified);\n        const droppableScrollChange = frame.scroll.diff.value;\n        const totalChange = add(windowScrollChange, droppableScrollChange);\n        const moved = offsetDraggable({\n            draggable,\n            offset: totalChange,\n            initialWindowScroll: viewport.scroll.initial\n        });\n        return moved;\n    });\n};\nconst timingsKey = \"Processing dynamic changes\";\nvar publishWhileDraggingInVirtual = ({ state, published })=>{\n    start();\n    const withScrollChange = published.modified.map((update)=>{\n        const existing = state.dimensions.droppables[update.droppableId];\n        const scrolled = scrollDroppable(existing, update.scroll);\n        return scrolled;\n    });\n    const droppables = {\n        ...state.dimensions.droppables,\n        ...toDroppableMap(withScrollChange)\n    };\n    const updatedAdditions = toDraggableMap(adjustAdditionsForScrollChanges({\n        additions: published.additions,\n        updatedDroppables: droppables,\n        viewport: state.viewport\n    }));\n    const draggables = {\n        ...state.dimensions.draggables,\n        ...updatedAdditions\n    };\n    published.removals.forEach((id)=>{\n        delete draggables[id];\n    });\n    const dimensions = {\n        droppables,\n        draggables\n    };\n    const wasOverId = whatIsDraggedOver(state.impact);\n    const wasOver = wasOverId ? dimensions.droppables[wasOverId] : null;\n    const draggable = dimensions.draggables[state.critical.draggable.id];\n    const home = dimensions.droppables[state.critical.droppable.id];\n    const { impact: onLiftImpact, afterCritical } = getLiftEffect({\n        draggable,\n        home,\n        draggables,\n        viewport: state.viewport\n    });\n    const previousImpact = wasOver && wasOver.isCombineEnabled ? state.impact : onLiftImpact;\n    const impact = getDragImpact({\n        pageOffset: state.current.page.offset,\n        draggable: dimensions.draggables[state.critical.draggable.id],\n        draggables: dimensions.draggables,\n        droppables: dimensions.droppables,\n        previousImpact,\n        viewport: state.viewport,\n        afterCritical\n    });\n    finish(timingsKey);\n    const draggingState = {\n        ...state,\n        phase: \"DRAGGING\",\n        impact,\n        onLiftImpact,\n        dimensions,\n        afterCritical,\n        forceShouldAnimate: false\n    };\n    if (state.phase === \"COLLECTING\") {\n        return draggingState;\n    }\n    const dropPending = {\n        ...draggingState,\n        phase: \"DROP_PENDING\",\n        reason: state.reason,\n        isWaiting: false\n    };\n    return dropPending;\n};\nconst isSnapping = (state)=>state.movementMode === \"SNAP\";\nconst postDroppableChange = (state, updated, isEnabledChanging)=>{\n    const dimensions = patchDimensionMap(state.dimensions, updated);\n    if (!isSnapping(state) || isEnabledChanging) {\n        return update({\n            state,\n            dimensions\n        });\n    }\n    return refreshSnap({\n        state,\n        dimensions\n    });\n};\nfunction removeScrollJumpRequest(state) {\n    if (state.isDragging && state.movementMode === \"SNAP\") {\n        return {\n            ...state,\n            scrollJumpRequest: null\n        };\n    }\n    return state;\n}\nconst idle$2 = {\n    phase: \"IDLE\",\n    completed: null,\n    shouldFlush: false\n};\nvar reducer = (state = idle$2, action)=>{\n    if (action.type === \"FLUSH\") {\n        return {\n            ...idle$2,\n            shouldFlush: true\n        };\n    }\n    if (action.type === \"INITIAL_PUBLISH\") {\n        !(state.phase === \"IDLE\") ?  true ? invariant(false, \"INITIAL_PUBLISH must come after a IDLE phase\") : 0 : void 0;\n        const { critical, clientSelection, viewport, dimensions, movementMode } = action.payload;\n        const draggable = dimensions.draggables[critical.draggable.id];\n        const home = dimensions.droppables[critical.droppable.id];\n        const client = {\n            selection: clientSelection,\n            borderBoxCenter: draggable.client.borderBox.center,\n            offset: origin\n        };\n        const initial = {\n            client,\n            page: {\n                selection: add(client.selection, viewport.scroll.initial),\n                borderBoxCenter: add(client.selection, viewport.scroll.initial),\n                offset: add(client.selection, viewport.scroll.diff.value)\n            }\n        };\n        const isWindowScrollAllowed = toDroppableList(dimensions.droppables).every((item)=>!item.isFixedOnPage);\n        const { impact, afterCritical } = getLiftEffect({\n            draggable,\n            home,\n            draggables: dimensions.draggables,\n            viewport\n        });\n        const result = {\n            phase: \"DRAGGING\",\n            isDragging: true,\n            critical,\n            movementMode,\n            dimensions,\n            initial,\n            current: initial,\n            isWindowScrollAllowed,\n            impact,\n            afterCritical,\n            onLiftImpact: impact,\n            viewport,\n            scrollJumpRequest: null,\n            forceShouldAnimate: null\n        };\n        return result;\n    }\n    if (action.type === \"COLLECTION_STARTING\") {\n        if (state.phase === \"COLLECTING\" || state.phase === \"DROP_PENDING\") {\n            return state;\n        }\n        !(state.phase === \"DRAGGING\") ?  true ? invariant(false, `Collection cannot start from phase ${state.phase}`) : 0 : void 0;\n        const result = {\n            ...state,\n            phase: \"COLLECTING\"\n        };\n        return result;\n    }\n    if (action.type === \"PUBLISH_WHILE_DRAGGING\") {\n        !(state.phase === \"COLLECTING\" || state.phase === \"DROP_PENDING\") ?  true ? invariant(false, `Unexpected ${action.type} received in phase ${state.phase}`) : 0 : void 0;\n        return publishWhileDraggingInVirtual({\n            state,\n            published: action.payload\n        });\n    }\n    if (action.type === \"MOVE\") {\n        if (state.phase === \"DROP_PENDING\") {\n            return state;\n        }\n        !isMovementAllowed(state) ?  true ? invariant(false, `${action.type} not permitted in phase ${state.phase}`) : 0 : void 0;\n        const { client: clientSelection } = action.payload;\n        if (isEqual$1(clientSelection, state.current.client.selection)) {\n            return state;\n        }\n        return update({\n            state,\n            clientSelection,\n            impact: isSnapping(state) ? state.impact : null\n        });\n    }\n    if (action.type === \"UPDATE_DROPPABLE_SCROLL\") {\n        if (state.phase === \"DROP_PENDING\") {\n            return removeScrollJumpRequest(state);\n        }\n        if (state.phase === \"COLLECTING\") {\n            return removeScrollJumpRequest(state);\n        }\n        !isMovementAllowed(state) ?  true ? invariant(false, `${action.type} not permitted in phase ${state.phase}`) : 0 : void 0;\n        const { id, newScroll } = action.payload;\n        const target = state.dimensions.droppables[id];\n        if (!target) {\n            return state;\n        }\n        const scrolled = scrollDroppable(target, newScroll);\n        return postDroppableChange(state, scrolled, false);\n    }\n    if (action.type === \"UPDATE_DROPPABLE_IS_ENABLED\") {\n        if (state.phase === \"DROP_PENDING\") {\n            return state;\n        }\n        !isMovementAllowed(state) ?  true ? invariant(false, `Attempting to move in an unsupported phase ${state.phase}`) : 0 : void 0;\n        const { id, isEnabled } = action.payload;\n        const target = state.dimensions.droppables[id];\n        !target ?  true ? invariant(false, `Cannot find Droppable[id: ${id}] to toggle its enabled state`) : 0 : void 0;\n        !(target.isEnabled !== isEnabled) ?  true ? invariant(false, `Trying to set droppable isEnabled to ${String(isEnabled)}\n      but it is already ${String(target.isEnabled)}`) : 0 : void 0;\n        const updated = {\n            ...target,\n            isEnabled\n        };\n        return postDroppableChange(state, updated, true);\n    }\n    if (action.type === \"UPDATE_DROPPABLE_IS_COMBINE_ENABLED\") {\n        if (state.phase === \"DROP_PENDING\") {\n            return state;\n        }\n        !isMovementAllowed(state) ?  true ? invariant(false, `Attempting to move in an unsupported phase ${state.phase}`) : 0 : void 0;\n        const { id, isCombineEnabled } = action.payload;\n        const target = state.dimensions.droppables[id];\n        !target ?  true ? invariant(false, `Cannot find Droppable[id: ${id}] to toggle its isCombineEnabled state`) : 0 : void 0;\n        !(target.isCombineEnabled !== isCombineEnabled) ?  true ? invariant(false, `Trying to set droppable isCombineEnabled to ${String(isCombineEnabled)}\n      but it is already ${String(target.isCombineEnabled)}`) : 0 : void 0;\n        const updated = {\n            ...target,\n            isCombineEnabled\n        };\n        return postDroppableChange(state, updated, true);\n    }\n    if (action.type === \"MOVE_BY_WINDOW_SCROLL\") {\n        if (state.phase === \"DROP_PENDING\" || state.phase === \"DROP_ANIMATING\") {\n            return state;\n        }\n        !isMovementAllowed(state) ?  true ? invariant(false, `Cannot move by window in phase ${state.phase}`) : 0 : void 0;\n        !state.isWindowScrollAllowed ?  true ? invariant(false, \"Window scrolling is currently not supported for fixed lists\") : 0 : void 0;\n        const newScroll = action.payload.newScroll;\n        if (isEqual$1(state.viewport.scroll.current, newScroll)) {\n            return removeScrollJumpRequest(state);\n        }\n        const viewport = scrollViewport(state.viewport, newScroll);\n        if (isSnapping(state)) {\n            return refreshSnap({\n                state,\n                viewport\n            });\n        }\n        return update({\n            state,\n            viewport\n        });\n    }\n    if (action.type === \"UPDATE_VIEWPORT_MAX_SCROLL\") {\n        if (!isMovementAllowed(state)) {\n            return state;\n        }\n        const maxScroll = action.payload.maxScroll;\n        if (isEqual$1(maxScroll, state.viewport.scroll.max)) {\n            return state;\n        }\n        const withMaxScroll = {\n            ...state.viewport,\n            scroll: {\n                ...state.viewport.scroll,\n                max: maxScroll\n            }\n        };\n        return {\n            ...state,\n            viewport: withMaxScroll\n        };\n    }\n    if (action.type === \"MOVE_UP\" || action.type === \"MOVE_DOWN\" || action.type === \"MOVE_LEFT\" || action.type === \"MOVE_RIGHT\") {\n        if (state.phase === \"COLLECTING\" || state.phase === \"DROP_PENDING\") {\n            return state;\n        }\n        !(state.phase === \"DRAGGING\") ?  true ? invariant(false, `${action.type} received while not in DRAGGING phase`) : 0 : void 0;\n        const result = moveInDirection({\n            state,\n            type: action.type\n        });\n        if (!result) {\n            return state;\n        }\n        return update({\n            state,\n            impact: result.impact,\n            clientSelection: result.clientSelection,\n            scrollJumpRequest: result.scrollJumpRequest\n        });\n    }\n    if (action.type === \"DROP_PENDING\") {\n        const reason = action.payload.reason;\n        !(state.phase === \"COLLECTING\") ?  true ? invariant(false, \"Can only move into the DROP_PENDING phase from the COLLECTING phase\") : 0 : void 0;\n        const newState = {\n            ...state,\n            phase: \"DROP_PENDING\",\n            isWaiting: true,\n            reason\n        };\n        return newState;\n    }\n    if (action.type === \"DROP_ANIMATE\") {\n        const { completed, dropDuration, newHomeClientOffset } = action.payload;\n        !(state.phase === \"DRAGGING\" || state.phase === \"DROP_PENDING\") ?  true ? invariant(false, `Cannot animate drop from phase ${state.phase}`) : 0 : void 0;\n        const result = {\n            phase: \"DROP_ANIMATING\",\n            completed,\n            dropDuration,\n            newHomeClientOffset,\n            dimensions: state.dimensions\n        };\n        return result;\n    }\n    if (action.type === \"DROP_COMPLETE\") {\n        const { completed } = action.payload;\n        return {\n            phase: \"IDLE\",\n            completed,\n            shouldFlush: false\n        };\n    }\n    return state;\n};\nconst beforeInitialCapture = (args)=>({\n        type: \"BEFORE_INITIAL_CAPTURE\",\n        payload: args\n    });\nconst lift$1 = (args)=>({\n        type: \"LIFT\",\n        payload: args\n    });\nconst initialPublish = (args)=>({\n        type: \"INITIAL_PUBLISH\",\n        payload: args\n    });\nconst publishWhileDragging = (args)=>({\n        type: \"PUBLISH_WHILE_DRAGGING\",\n        payload: args\n    });\nconst collectionStarting = ()=>({\n        type: \"COLLECTION_STARTING\",\n        payload: null\n    });\nconst updateDroppableScroll = (args)=>({\n        type: \"UPDATE_DROPPABLE_SCROLL\",\n        payload: args\n    });\nconst updateDroppableIsEnabled = (args)=>({\n        type: \"UPDATE_DROPPABLE_IS_ENABLED\",\n        payload: args\n    });\nconst updateDroppableIsCombineEnabled = (args)=>({\n        type: \"UPDATE_DROPPABLE_IS_COMBINE_ENABLED\",\n        payload: args\n    });\nconst move = (args)=>({\n        type: \"MOVE\",\n        payload: args\n    });\nconst moveByWindowScroll = (args)=>({\n        type: \"MOVE_BY_WINDOW_SCROLL\",\n        payload: args\n    });\nconst updateViewportMaxScroll = (args)=>({\n        type: \"UPDATE_VIEWPORT_MAX_SCROLL\",\n        payload: args\n    });\nconst moveUp = ()=>({\n        type: \"MOVE_UP\",\n        payload: null\n    });\nconst moveDown = ()=>({\n        type: \"MOVE_DOWN\",\n        payload: null\n    });\nconst moveRight = ()=>({\n        type: \"MOVE_RIGHT\",\n        payload: null\n    });\nconst moveLeft = ()=>({\n        type: \"MOVE_LEFT\",\n        payload: null\n    });\nconst flush = ()=>({\n        type: \"FLUSH\",\n        payload: null\n    });\nconst animateDrop = (args)=>({\n        type: \"DROP_ANIMATE\",\n        payload: args\n    });\nconst completeDrop = (args)=>({\n        type: \"DROP_COMPLETE\",\n        payload: args\n    });\nconst drop$1 = (args)=>({\n        type: \"DROP\",\n        payload: args\n    });\nconst dropPending = (args)=>({\n        type: \"DROP_PENDING\",\n        payload: args\n    });\nconst dropAnimationFinished = ()=>({\n        type: \"DROP_ANIMATION_FINISHED\",\n        payload: null\n    });\nfunction checkIndexes(insideDestination) {\n    if (insideDestination.length <= 1) {\n        return;\n    }\n    const indexes = insideDestination.map((d)=>d.descriptor.index);\n    const errors = {};\n    for(let i = 1; i < indexes.length; i++){\n        const current = indexes[i];\n        const previous = indexes[i - 1];\n        if (current !== previous + 1) {\n            errors[current] = true;\n        }\n    }\n    if (!Object.keys(errors).length) {\n        return;\n    }\n    const formatted = indexes.map((index)=>{\n        const hasError = Boolean(errors[index]);\n        return hasError ? `[ðŸ”¥${index}]` : `${index}`;\n    }).join(\", \");\n     true ? warning(`\n    Detected non-consecutive <Draggable /> indexes.\n\n    (This can cause unexpected bugs)\n\n    ${formatted}\n  `) : 0;\n}\nfunction validateDimensions(critical, dimensions) {\n    if (true) {\n        const insideDestination = getDraggablesInsideDroppable(critical.droppable.id, dimensions.draggables);\n        checkIndexes(insideDestination);\n    }\n}\nvar lift = (marshal)=>({ getState, dispatch })=>(next)=>(action)=>{\n                if (action.type !== \"LIFT\") {\n                    next(action);\n                    return;\n                }\n                const { id, clientSelection, movementMode } = action.payload;\n                const initial = getState();\n                if (initial.phase === \"DROP_ANIMATING\") {\n                    dispatch(completeDrop({\n                        completed: initial.completed\n                    }));\n                }\n                !(getState().phase === \"IDLE\") ?  true ? invariant(false, \"Unexpected phase to start a drag\") : 0 : void 0;\n                dispatch(flush());\n                dispatch(beforeInitialCapture({\n                    draggableId: id,\n                    movementMode\n                }));\n                const scrollOptions = {\n                    shouldPublishImmediately: movementMode === \"SNAP\"\n                };\n                const request = {\n                    draggableId: id,\n                    scrollOptions\n                };\n                const { critical, dimensions, viewport } = marshal.startPublishing(request);\n                validateDimensions(critical, dimensions);\n                dispatch(initialPublish({\n                    critical,\n                    dimensions,\n                    clientSelection,\n                    movementMode,\n                    viewport\n                }));\n            };\nvar style = (marshal)=>()=>(next)=>(action)=>{\n                if (action.type === \"INITIAL_PUBLISH\") {\n                    marshal.dragging();\n                }\n                if (action.type === \"DROP_ANIMATE\") {\n                    marshal.dropping(action.payload.completed.result.reason);\n                }\n                if (action.type === \"FLUSH\" || action.type === \"DROP_COMPLETE\") {\n                    marshal.resting();\n                }\n                next(action);\n            };\nconst curves = {\n    outOfTheWay: \"cubic-bezier(0.2, 0, 0, 1)\",\n    drop: \"cubic-bezier(.2,1,.1,1)\"\n};\nconst combine = {\n    opacity: {\n        drop: 0,\n        combining: 0.7\n    },\n    scale: {\n        drop: 0.75\n    }\n};\nconst timings = {\n    outOfTheWay: 0.2,\n    minDropTime: 0.33,\n    maxDropTime: 0.55\n};\nconst outOfTheWayTiming = `${timings.outOfTheWay}s ${curves.outOfTheWay}`;\nconst transitions = {\n    fluid: `opacity ${outOfTheWayTiming}`,\n    snap: `transform ${outOfTheWayTiming}, opacity ${outOfTheWayTiming}`,\n    drop: (duration)=>{\n        const timing = `${duration}s ${curves.drop}`;\n        return `transform ${timing}, opacity ${timing}`;\n    },\n    outOfTheWay: `transform ${outOfTheWayTiming}`,\n    placeholder: `height ${outOfTheWayTiming}, width ${outOfTheWayTiming}, margin ${outOfTheWayTiming}`\n};\nconst moveTo = (offset)=>isEqual$1(offset, origin) ? undefined : `translate(${offset.x}px, ${offset.y}px)`;\nconst transforms = {\n    moveTo,\n    drop: (offset, isCombining)=>{\n        const translate = moveTo(offset);\n        if (!translate) {\n            return undefined;\n        }\n        if (!isCombining) {\n            return translate;\n        }\n        return `${translate} scale(${combine.scale.drop})`;\n    }\n};\nconst { minDropTime, maxDropTime } = timings;\nconst dropTimeRange = maxDropTime - minDropTime;\nconst maxDropTimeAtDistance = 1500;\nconst cancelDropModifier = 0.6;\nvar getDropDuration = ({ current, destination, reason })=>{\n    const distance$1 = distance(current, destination);\n    if (distance$1 <= 0) {\n        return minDropTime;\n    }\n    if (distance$1 >= maxDropTimeAtDistance) {\n        return maxDropTime;\n    }\n    const percentage = distance$1 / maxDropTimeAtDistance;\n    const duration = minDropTime + dropTimeRange * percentage;\n    const withDuration = reason === \"CANCEL\" ? duration * cancelDropModifier : duration;\n    return Number(withDuration.toFixed(2));\n};\nvar getNewHomeClientOffset = ({ impact, draggable, dimensions, viewport, afterCritical })=>{\n    const { draggables, droppables } = dimensions;\n    const droppableId = whatIsDraggedOver(impact);\n    const destination = droppableId ? droppables[droppableId] : null;\n    const home = droppables[draggable.descriptor.droppableId];\n    const newClientCenter = getClientBorderBoxCenter({\n        impact,\n        draggable,\n        draggables,\n        afterCritical,\n        droppable: destination || home,\n        viewport\n    });\n    const offset = subtract(newClientCenter, draggable.client.borderBox.center);\n    return offset;\n};\nvar getDropImpact = ({ draggables, reason, lastImpact, home, viewport, onLiftImpact })=>{\n    if (!lastImpact.at || reason !== \"DROP\") {\n        const recomputedHomeImpact = recompute({\n            draggables,\n            impact: onLiftImpact,\n            destination: home,\n            viewport,\n            forceShouldAnimate: true\n        });\n        return {\n            impact: recomputedHomeImpact,\n            didDropInsideDroppable: false\n        };\n    }\n    if (lastImpact.at.type === \"REORDER\") {\n        return {\n            impact: lastImpact,\n            didDropInsideDroppable: true\n        };\n    }\n    const withoutMovement = {\n        ...lastImpact,\n        displaced: emptyGroups\n    };\n    return {\n        impact: withoutMovement,\n        didDropInsideDroppable: true\n    };\n};\nconst dropMiddleware = ({ getState, dispatch })=>(next)=>(action)=>{\n            if (action.type !== \"DROP\") {\n                next(action);\n                return;\n            }\n            const state = getState();\n            const reason = action.payload.reason;\n            if (state.phase === \"COLLECTING\") {\n                dispatch(dropPending({\n                    reason\n                }));\n                return;\n            }\n            if (state.phase === \"IDLE\") {\n                return;\n            }\n            const isWaitingForDrop = state.phase === \"DROP_PENDING\" && state.isWaiting;\n            !!isWaitingForDrop ?  true ? invariant(false, \"A DROP action occurred while DROP_PENDING and still waiting\") : 0 : void 0;\n            !(state.phase === \"DRAGGING\" || state.phase === \"DROP_PENDING\") ?  true ? invariant(false, `Cannot drop in phase: ${state.phase}`) : 0 : void 0;\n            const critical = state.critical;\n            const dimensions = state.dimensions;\n            const draggable = dimensions.draggables[state.critical.draggable.id];\n            const { impact, didDropInsideDroppable } = getDropImpact({\n                reason,\n                lastImpact: state.impact,\n                afterCritical: state.afterCritical,\n                onLiftImpact: state.onLiftImpact,\n                home: state.dimensions.droppables[state.critical.droppable.id],\n                viewport: state.viewport,\n                draggables: state.dimensions.draggables\n            });\n            const destination = didDropInsideDroppable ? tryGetDestination(impact) : null;\n            const combine = didDropInsideDroppable ? tryGetCombine(impact) : null;\n            const source = {\n                index: critical.draggable.index,\n                droppableId: critical.droppable.id\n            };\n            const result = {\n                draggableId: draggable.descriptor.id,\n                type: draggable.descriptor.type,\n                source,\n                reason,\n                mode: state.movementMode,\n                destination,\n                combine\n            };\n            const newHomeClientOffset = getNewHomeClientOffset({\n                impact,\n                draggable,\n                dimensions,\n                viewport: state.viewport,\n                afterCritical: state.afterCritical\n            });\n            const completed = {\n                critical: state.critical,\n                afterCritical: state.afterCritical,\n                result,\n                impact\n            };\n            const isAnimationRequired = !isEqual$1(state.current.client.offset, newHomeClientOffset) || Boolean(result.combine);\n            if (!isAnimationRequired) {\n                dispatch(completeDrop({\n                    completed\n                }));\n                return;\n            }\n            const dropDuration = getDropDuration({\n                current: state.current.client.offset,\n                destination: newHomeClientOffset,\n                reason\n            });\n            const args = {\n                newHomeClientOffset,\n                dropDuration,\n                completed\n            };\n            dispatch(animateDrop(args));\n        };\nvar drop = dropMiddleware;\nvar getWindowScroll = ()=>({\n        x: window.pageXOffset,\n        y: window.pageYOffset\n    });\nfunction getWindowScrollBinding(update) {\n    return {\n        eventName: \"scroll\",\n        options: {\n            passive: true,\n            capture: false\n        },\n        fn: (event)=>{\n            if (event.target !== window && event.target !== window.document) {\n                return;\n            }\n            update();\n        }\n    };\n}\nfunction getScrollListener({ onWindowScroll }) {\n    function updateScroll() {\n        onWindowScroll(getWindowScroll());\n    }\n    const scheduled = (0,raf_schd__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(updateScroll);\n    const binding = getWindowScrollBinding(scheduled);\n    let unbind = noop$2;\n    function isActive() {\n        return unbind !== noop$2;\n    }\n    function start() {\n        !!isActive() ?  true ? invariant(false, \"Cannot start scroll listener when already active\") : 0 : void 0;\n        unbind = bindEvents(window, [\n            binding\n        ]);\n    }\n    function stop() {\n        !isActive() ?  true ? invariant(false, \"Cannot stop scroll listener when not active\") : 0 : void 0;\n        scheduled.cancel();\n        unbind();\n        unbind = noop$2;\n    }\n    return {\n        start,\n        stop,\n        isActive\n    };\n}\nconst shouldEnd = (action)=>action.type === \"DROP_COMPLETE\" || action.type === \"DROP_ANIMATE\" || action.type === \"FLUSH\";\nconst scrollListener = (store)=>{\n    const listener = getScrollListener({\n        onWindowScroll: (newScroll)=>{\n            store.dispatch(moveByWindowScroll({\n                newScroll\n            }));\n        }\n    });\n    return (next)=>(action)=>{\n            if (!listener.isActive() && action.type === \"INITIAL_PUBLISH\") {\n                listener.start();\n            }\n            if (listener.isActive() && shouldEnd(action)) {\n                listener.stop();\n            }\n            next(action);\n        };\n};\nvar scrollListener$1 = scrollListener;\nvar getExpiringAnnounce = (announce)=>{\n    let wasCalled = false;\n    let isExpired = false;\n    const timeoutId = setTimeout(()=>{\n        isExpired = true;\n    });\n    const result = (message)=>{\n        if (wasCalled) {\n             true ? warning(\"Announcement already made. Not making a second announcement\") : 0;\n            return;\n        }\n        if (isExpired) {\n             true ? warning(`\n        Announcements cannot be made asynchronously.\n        Default message has already been announced.\n      `) : 0;\n            return;\n        }\n        wasCalled = true;\n        announce(message);\n        clearTimeout(timeoutId);\n    };\n    result.wasCalled = ()=>wasCalled;\n    return result;\n};\nvar getAsyncMarshal = ()=>{\n    const entries = [];\n    const execute = (timerId)=>{\n        const index = entries.findIndex((item)=>item.timerId === timerId);\n        !(index !== -1) ?  true ? invariant(false, \"Could not find timer\") : 0 : void 0;\n        const [entry] = entries.splice(index, 1);\n        entry.callback();\n    };\n    const add = (fn)=>{\n        const timerId = setTimeout(()=>execute(timerId));\n        const entry = {\n            timerId,\n            callback: fn\n        };\n        entries.push(entry);\n    };\n    const flush = ()=>{\n        if (!entries.length) {\n            return;\n        }\n        const shallow = [\n            ...entries\n        ];\n        entries.length = 0;\n        shallow.forEach((entry)=>{\n            clearTimeout(entry.timerId);\n            entry.callback();\n        });\n    };\n    return {\n        add,\n        flush\n    };\n};\nconst areLocationsEqual = (first, second)=>{\n    if (first == null && second == null) {\n        return true;\n    }\n    if (first == null || second == null) {\n        return false;\n    }\n    return first.droppableId === second.droppableId && first.index === second.index;\n};\nconst isCombineEqual = (first, second)=>{\n    if (first == null && second == null) {\n        return true;\n    }\n    if (first == null || second == null) {\n        return false;\n    }\n    return first.draggableId === second.draggableId && first.droppableId === second.droppableId;\n};\nconst isCriticalEqual = (first, second)=>{\n    if (first === second) {\n        return true;\n    }\n    const isDraggableEqual = first.draggable.id === second.draggable.id && first.draggable.droppableId === second.draggable.droppableId && first.draggable.type === second.draggable.type && first.draggable.index === second.draggable.index;\n    const isDroppableEqual = first.droppable.id === second.droppable.id && first.droppable.type === second.droppable.type;\n    return isDraggableEqual && isDroppableEqual;\n};\nconst withTimings = (key, fn)=>{\n    start();\n    fn();\n    finish();\n};\nconst getDragStart = (critical, mode)=>({\n        draggableId: critical.draggable.id,\n        type: critical.droppable.type,\n        source: {\n            droppableId: critical.droppable.id,\n            index: critical.draggable.index\n        },\n        mode\n    });\nfunction execute(responder, data, announce, getDefaultMessage) {\n    if (!responder) {\n        announce(getDefaultMessage(data));\n        return;\n    }\n    const willExpire = getExpiringAnnounce(announce);\n    const provided = {\n        announce: willExpire\n    };\n    responder(data, provided);\n    if (!willExpire.wasCalled()) {\n        announce(getDefaultMessage(data));\n    }\n}\nvar getPublisher = (getResponders, announce)=>{\n    const asyncMarshal = getAsyncMarshal();\n    let dragging = null;\n    const beforeCapture = (draggableId, mode)=>{\n        !!dragging ?  true ? invariant(false, \"Cannot fire onBeforeCapture as a drag start has already been published\") : 0 : void 0;\n        withTimings(\"onBeforeCapture\", ()=>{\n            const fn = getResponders().onBeforeCapture;\n            if (fn) {\n                const before = {\n                    draggableId,\n                    mode\n                };\n                fn(before);\n            }\n        });\n    };\n    const beforeStart = (critical, mode)=>{\n        !!dragging ?  true ? invariant(false, \"Cannot fire onBeforeDragStart as a drag start has already been published\") : 0 : void 0;\n        withTimings(\"onBeforeDragStart\", ()=>{\n            const fn = getResponders().onBeforeDragStart;\n            if (fn) {\n                fn(getDragStart(critical, mode));\n            }\n        });\n    };\n    const start = (critical, mode)=>{\n        !!dragging ?  true ? invariant(false, \"Cannot fire onBeforeDragStart as a drag start has already been published\") : 0 : void 0;\n        const data = getDragStart(critical, mode);\n        dragging = {\n            mode,\n            lastCritical: critical,\n            lastLocation: data.source,\n            lastCombine: null\n        };\n        asyncMarshal.add(()=>{\n            withTimings(\"onDragStart\", ()=>execute(getResponders().onDragStart, data, announce, preset$1.onDragStart));\n        });\n    };\n    const update = (critical, impact)=>{\n        const location = tryGetDestination(impact);\n        const combine = tryGetCombine(impact);\n        !dragging ?  true ? invariant(false, \"Cannot fire onDragMove when onDragStart has not been called\") : 0 : void 0;\n        const hasCriticalChanged = !isCriticalEqual(critical, dragging.lastCritical);\n        if (hasCriticalChanged) {\n            dragging.lastCritical = critical;\n        }\n        const hasLocationChanged = !areLocationsEqual(dragging.lastLocation, location);\n        if (hasLocationChanged) {\n            dragging.lastLocation = location;\n        }\n        const hasGroupingChanged = !isCombineEqual(dragging.lastCombine, combine);\n        if (hasGroupingChanged) {\n            dragging.lastCombine = combine;\n        }\n        if (!hasCriticalChanged && !hasLocationChanged && !hasGroupingChanged) {\n            return;\n        }\n        const data = {\n            ...getDragStart(critical, dragging.mode),\n            combine,\n            destination: location\n        };\n        asyncMarshal.add(()=>{\n            withTimings(\"onDragUpdate\", ()=>execute(getResponders().onDragUpdate, data, announce, preset$1.onDragUpdate));\n        });\n    };\n    const flush = ()=>{\n        !dragging ?  true ? invariant(false, \"Can only flush responders while dragging\") : 0 : void 0;\n        asyncMarshal.flush();\n    };\n    const drop = (result)=>{\n        !dragging ?  true ? invariant(false, \"Cannot fire onDragEnd when there is no matching onDragStart\") : 0 : void 0;\n        dragging = null;\n        withTimings(\"onDragEnd\", ()=>execute(getResponders().onDragEnd, result, announce, preset$1.onDragEnd));\n    };\n    const abort = ()=>{\n        if (!dragging) {\n            return;\n        }\n        const result = {\n            ...getDragStart(dragging.lastCritical, dragging.mode),\n            combine: null,\n            destination: null,\n            reason: \"CANCEL\"\n        };\n        drop(result);\n    };\n    return {\n        beforeCapture,\n        beforeStart,\n        start,\n        update,\n        flush,\n        drop,\n        abort\n    };\n};\nvar responders = (getResponders, announce)=>{\n    const publisher = getPublisher(getResponders, announce);\n    return (store)=>(next)=>(action)=>{\n                if (action.type === \"BEFORE_INITIAL_CAPTURE\") {\n                    publisher.beforeCapture(action.payload.draggableId, action.payload.movementMode);\n                    return;\n                }\n                if (action.type === \"INITIAL_PUBLISH\") {\n                    const critical = action.payload.critical;\n                    publisher.beforeStart(critical, action.payload.movementMode);\n                    next(action);\n                    publisher.start(critical, action.payload.movementMode);\n                    return;\n                }\n                if (action.type === \"DROP_COMPLETE\") {\n                    const result = action.payload.completed.result;\n                    publisher.flush();\n                    next(action);\n                    publisher.drop(result);\n                    return;\n                }\n                next(action);\n                if (action.type === \"FLUSH\") {\n                    publisher.abort();\n                    return;\n                }\n                const state = store.getState();\n                if (state.phase === \"DRAGGING\") {\n                    publisher.update(state.critical, state.impact);\n                }\n            };\n};\nconst dropAnimationFinishMiddleware = (store)=>(next)=>(action)=>{\n            if (action.type !== \"DROP_ANIMATION_FINISHED\") {\n                next(action);\n                return;\n            }\n            const state = store.getState();\n            !(state.phase === \"DROP_ANIMATING\") ?  true ? invariant(false, \"Cannot finish a drop animating when no drop is occurring\") : 0 : void 0;\n            store.dispatch(completeDrop({\n                completed: state.completed\n            }));\n        };\nvar dropAnimationFinish = dropAnimationFinishMiddleware;\nconst dropAnimationFlushOnScrollMiddleware = (store)=>{\n    let unbind = null;\n    let frameId = null;\n    function clear() {\n        if (frameId) {\n            cancelAnimationFrame(frameId);\n            frameId = null;\n        }\n        if (unbind) {\n            unbind();\n            unbind = null;\n        }\n    }\n    return (next)=>(action)=>{\n            if (action.type === \"FLUSH\" || action.type === \"DROP_COMPLETE\" || action.type === \"DROP_ANIMATION_FINISHED\") {\n                clear();\n            }\n            next(action);\n            if (action.type !== \"DROP_ANIMATE\") {\n                return;\n            }\n            const binding = {\n                eventName: \"scroll\",\n                options: {\n                    capture: true,\n                    passive: false,\n                    once: true\n                },\n                fn: function flushDropAnimation() {\n                    const state = store.getState();\n                    if (state.phase === \"DROP_ANIMATING\") {\n                        store.dispatch(dropAnimationFinished());\n                    }\n                }\n            };\n            frameId = requestAnimationFrame(()=>{\n                frameId = null;\n                unbind = bindEvents(window, [\n                    binding\n                ]);\n            });\n        };\n};\nvar dropAnimationFlushOnScroll = dropAnimationFlushOnScrollMiddleware;\nvar dimensionMarshalStopper = (marshal)=>()=>(next)=>(action)=>{\n                if (action.type === \"DROP_COMPLETE\" || action.type === \"FLUSH\" || action.type === \"DROP_ANIMATE\") {\n                    marshal.stopPublishing();\n                }\n                next(action);\n            };\nvar focus = (marshal)=>{\n    let isWatching = false;\n    return ()=>(next)=>(action)=>{\n                if (action.type === \"INITIAL_PUBLISH\") {\n                    isWatching = true;\n                    marshal.tryRecordFocus(action.payload.critical.draggable.id);\n                    next(action);\n                    marshal.tryRestoreFocusRecorded();\n                    return;\n                }\n                next(action);\n                if (!isWatching) {\n                    return;\n                }\n                if (action.type === \"FLUSH\") {\n                    isWatching = false;\n                    marshal.tryRestoreFocusRecorded();\n                    return;\n                }\n                if (action.type === \"DROP_COMPLETE\") {\n                    isWatching = false;\n                    const result = action.payload.completed.result;\n                    if (result.combine) {\n                        marshal.tryShiftRecord(result.draggableId, result.combine.draggableId);\n                    }\n                    marshal.tryRestoreFocusRecorded();\n                }\n            };\n};\nconst shouldStop = (action)=>action.type === \"DROP_COMPLETE\" || action.type === \"DROP_ANIMATE\" || action.type === \"FLUSH\";\nvar autoScroll = (autoScroller)=>(store)=>(next)=>(action)=>{\n                if (shouldStop(action)) {\n                    autoScroller.stop();\n                    next(action);\n                    return;\n                }\n                if (action.type === \"INITIAL_PUBLISH\") {\n                    next(action);\n                    const state = store.getState();\n                    !(state.phase === \"DRAGGING\") ?  true ? invariant(false, \"Expected phase to be DRAGGING after INITIAL_PUBLISH\") : 0 : void 0;\n                    autoScroller.start(state);\n                    return;\n                }\n                next(action);\n                autoScroller.scroll(store.getState());\n            };\nconst pendingDrop = (store)=>(next)=>(action)=>{\n            next(action);\n            if (action.type !== \"PUBLISH_WHILE_DRAGGING\") {\n                return;\n            }\n            const postActionState = store.getState();\n            if (postActionState.phase !== \"DROP_PENDING\") {\n                return;\n            }\n            if (postActionState.isWaiting) {\n                return;\n            }\n            store.dispatch(drop$1({\n                reason: postActionState.reason\n            }));\n        };\nvar pendingDrop$1 = pendingDrop;\nconst composeEnhancers =  false ? 0 : redux__WEBPACK_IMPORTED_MODULE_7__.compose;\nvar createStore = ({ dimensionMarshal, focusMarshal, styleMarshal, getResponders, announce, autoScroller })=>(0,redux__WEBPACK_IMPORTED_MODULE_7__.createStore)(reducer, composeEnhancers((0,redux__WEBPACK_IMPORTED_MODULE_7__.applyMiddleware)(style(styleMarshal), dimensionMarshalStopper(dimensionMarshal), lift(dimensionMarshal), drop, dropAnimationFinish, dropAnimationFlushOnScroll, pendingDrop$1, autoScroll(autoScroller), scrollListener$1, focus(focusMarshal), responders(getResponders, announce))));\nconst clean$1 = ()=>({\n        additions: {},\n        removals: {},\n        modified: {}\n    });\nfunction createPublisher({ registry, callbacks }) {\n    let staging = clean$1();\n    let frameId = null;\n    const collect = ()=>{\n        if (frameId) {\n            return;\n        }\n        callbacks.collectionStarting();\n        frameId = requestAnimationFrame(()=>{\n            frameId = null;\n            start();\n            const { additions, removals, modified } = staging;\n            const added = Object.keys(additions).map((id)=>registry.draggable.getById(id).getDimension(origin)).sort((a, b)=>a.descriptor.index - b.descriptor.index);\n            const updated = Object.keys(modified).map((id)=>{\n                const entry = registry.droppable.getById(id);\n                const scroll = entry.callbacks.getScrollWhileDragging();\n                return {\n                    droppableId: id,\n                    scroll\n                };\n            });\n            const result = {\n                additions: added,\n                removals: Object.keys(removals),\n                modified: updated\n            };\n            staging = clean$1();\n            finish();\n            callbacks.publish(result);\n        });\n    };\n    const add = (entry)=>{\n        const id = entry.descriptor.id;\n        staging.additions[id] = entry;\n        staging.modified[entry.descriptor.droppableId] = true;\n        if (staging.removals[id]) {\n            delete staging.removals[id];\n        }\n        collect();\n    };\n    const remove = (entry)=>{\n        const descriptor = entry.descriptor;\n        staging.removals[descriptor.id] = true;\n        staging.modified[descriptor.droppableId] = true;\n        if (staging.additions[descriptor.id]) {\n            delete staging.additions[descriptor.id];\n        }\n        collect();\n    };\n    const stop = ()=>{\n        if (!frameId) {\n            return;\n        }\n        cancelAnimationFrame(frameId);\n        frameId = null;\n        staging = clean$1();\n    };\n    return {\n        add,\n        remove,\n        stop\n    };\n}\nvar getMaxScroll = ({ scrollHeight, scrollWidth, height, width })=>{\n    const maxScroll = subtract({\n        x: scrollWidth,\n        y: scrollHeight\n    }, {\n        x: width,\n        y: height\n    });\n    const adjustedMaxScroll = {\n        x: Math.max(0, maxScroll.x),\n        y: Math.max(0, maxScroll.y)\n    };\n    return adjustedMaxScroll;\n};\nvar getDocumentElement = ()=>{\n    const doc = document.documentElement;\n    !doc ?  true ? invariant(false, \"Cannot find document.documentElement\") : 0 : void 0;\n    return doc;\n};\nvar getMaxWindowScroll = ()=>{\n    const doc = getDocumentElement();\n    const maxScroll = getMaxScroll({\n        scrollHeight: doc.scrollHeight,\n        scrollWidth: doc.scrollWidth,\n        width: doc.clientWidth,\n        height: doc.clientHeight\n    });\n    return maxScroll;\n};\nvar getViewport = ()=>{\n    const scroll = getWindowScroll();\n    const maxScroll = getMaxWindowScroll();\n    const top = scroll.y;\n    const left = scroll.x;\n    const doc = getDocumentElement();\n    const width = doc.clientWidth;\n    const height = doc.clientHeight;\n    const right = left + width;\n    const bottom = top + height;\n    const frame = (0,css_box_model__WEBPACK_IMPORTED_MODULE_4__.getRect)({\n        top,\n        left,\n        right,\n        bottom\n    });\n    const viewport = {\n        frame,\n        scroll: {\n            initial: scroll,\n            current: scroll,\n            max: maxScroll,\n            diff: {\n                value: origin,\n                displacement: origin\n            }\n        }\n    };\n    return viewport;\n};\nvar getInitialPublish = ({ critical, scrollOptions, registry })=>{\n    start();\n    const viewport = getViewport();\n    const windowScroll = viewport.scroll.current;\n    const home = critical.droppable;\n    const droppables = registry.droppable.getAllByType(home.type).map((entry)=>entry.callbacks.getDimensionAndWatchScroll(windowScroll, scrollOptions));\n    const draggables = registry.draggable.getAllByType(critical.draggable.type).map((entry)=>entry.getDimension(windowScroll));\n    const dimensions = {\n        draggables: toDraggableMap(draggables),\n        droppables: toDroppableMap(droppables)\n    };\n    finish();\n    const result = {\n        dimensions,\n        critical,\n        viewport\n    };\n    return result;\n};\nfunction shouldPublishUpdate(registry, dragging, entry) {\n    if (entry.descriptor.id === dragging.id) {\n        return false;\n    }\n    if (entry.descriptor.type !== dragging.type) {\n        return false;\n    }\n    const home = registry.droppable.getById(entry.descriptor.droppableId);\n    if (home.descriptor.mode !== \"virtual\") {\n         true ? warning(`\n      You are attempting to add or remove a Draggable [id: ${entry.descriptor.id}]\n      while a drag is occurring. This is only supported for virtual lists.\n\n      See https://github.com/hello-pangea/dnd/blob/main/docs/patterns/virtual-lists.md\n    `) : 0;\n        return false;\n    }\n    return true;\n}\nvar createDimensionMarshal = (registry, callbacks)=>{\n    let collection = null;\n    const publisher = createPublisher({\n        callbacks: {\n            publish: callbacks.publishWhileDragging,\n            collectionStarting: callbacks.collectionStarting\n        },\n        registry\n    });\n    const updateDroppableIsEnabled = (id, isEnabled)=>{\n        !registry.droppable.exists(id) ?  true ? invariant(false, `Cannot update is enabled flag of Droppable ${id} as it is not registered`) : 0 : void 0;\n        if (!collection) {\n            return;\n        }\n        callbacks.updateDroppableIsEnabled({\n            id,\n            isEnabled\n        });\n    };\n    const updateDroppableIsCombineEnabled = (id, isCombineEnabled)=>{\n        if (!collection) {\n            return;\n        }\n        !registry.droppable.exists(id) ?  true ? invariant(false, `Cannot update isCombineEnabled flag of Droppable ${id} as it is not registered`) : 0 : void 0;\n        callbacks.updateDroppableIsCombineEnabled({\n            id,\n            isCombineEnabled\n        });\n    };\n    const updateDroppableScroll = (id, newScroll)=>{\n        if (!collection) {\n            return;\n        }\n        !registry.droppable.exists(id) ?  true ? invariant(false, `Cannot update the scroll on Droppable ${id} as it is not registered`) : 0 : void 0;\n        callbacks.updateDroppableScroll({\n            id,\n            newScroll\n        });\n    };\n    const scrollDroppable = (id, change)=>{\n        if (!collection) {\n            return;\n        }\n        registry.droppable.getById(id).callbacks.scroll(change);\n    };\n    const stopPublishing = ()=>{\n        if (!collection) {\n            return;\n        }\n        publisher.stop();\n        const home = collection.critical.droppable;\n        registry.droppable.getAllByType(home.type).forEach((entry)=>entry.callbacks.dragStopped());\n        collection.unsubscribe();\n        collection = null;\n    };\n    const subscriber = (event)=>{\n        !collection ?  true ? invariant(false, \"Should only be subscribed when a collection is occurring\") : 0 : void 0;\n        const dragging = collection.critical.draggable;\n        if (event.type === \"ADDITION\") {\n            if (shouldPublishUpdate(registry, dragging, event.value)) {\n                publisher.add(event.value);\n            }\n        }\n        if (event.type === \"REMOVAL\") {\n            if (shouldPublishUpdate(registry, dragging, event.value)) {\n                publisher.remove(event.value);\n            }\n        }\n    };\n    const startPublishing = (request)=>{\n        !!collection ?  true ? invariant(false, \"Cannot start capturing critical dimensions as there is already a collection\") : 0 : void 0;\n        const entry = registry.draggable.getById(request.draggableId);\n        const home = registry.droppable.getById(entry.descriptor.droppableId);\n        const critical = {\n            draggable: entry.descriptor,\n            droppable: home.descriptor\n        };\n        const unsubscribe = registry.subscribe(subscriber);\n        collection = {\n            critical,\n            unsubscribe\n        };\n        return getInitialPublish({\n            critical,\n            registry,\n            scrollOptions: request.scrollOptions\n        });\n    };\n    const marshal = {\n        updateDroppableIsEnabled,\n        updateDroppableIsCombineEnabled,\n        scrollDroppable,\n        updateDroppableScroll,\n        startPublishing,\n        stopPublishing\n    };\n    return marshal;\n};\nvar canStartDrag = (state, id)=>{\n    if (state.phase === \"IDLE\") {\n        return true;\n    }\n    if (state.phase !== \"DROP_ANIMATING\") {\n        return false;\n    }\n    if (state.completed.result.draggableId === id) {\n        return false;\n    }\n    return state.completed.result.reason === \"DROP\";\n};\nvar scrollWindow = (change)=>{\n    window.scrollBy(change.x, change.y);\n};\nconst getScrollableDroppables = (0,memoize_one__WEBPACK_IMPORTED_MODULE_5__[\"default\"])((droppables)=>toDroppableList(droppables).filter((droppable)=>{\n        if (!droppable.isEnabled) {\n            return false;\n        }\n        if (!droppable.frame) {\n            return false;\n        }\n        return true;\n    }));\nconst getScrollableDroppableOver = (target, droppables)=>{\n    const maybe = getScrollableDroppables(droppables).find((droppable)=>{\n        !droppable.frame ?  true ? invariant(false, \"Invalid result\") : 0 : void 0;\n        return isPositionInFrame(droppable.frame.pageMarginBox)(target);\n    }) || null;\n    return maybe;\n};\nvar getBestScrollableDroppable = ({ center, destination, droppables })=>{\n    if (destination) {\n        const dimension = droppables[destination];\n        if (!dimension.frame) {\n            return null;\n        }\n        return dimension;\n    }\n    const dimension = getScrollableDroppableOver(center, droppables);\n    return dimension;\n};\nconst defaultAutoScrollerOptions = {\n    startFromPercentage: 0.25,\n    maxScrollAtPercentage: 0.05,\n    maxPixelScroll: 28,\n    ease: (percentage)=>percentage ** 2,\n    durationDampening: {\n        stopDampeningAt: 1200,\n        accelerateAt: 360\n    },\n    disabled: false\n};\nvar getDistanceThresholds = (container, axis, getAutoScrollerOptions = ()=>defaultAutoScrollerOptions)=>{\n    const autoScrollerOptions = getAutoScrollerOptions();\n    const startScrollingFrom = container[axis.size] * autoScrollerOptions.startFromPercentage;\n    const maxScrollValueAt = container[axis.size] * autoScrollerOptions.maxScrollAtPercentage;\n    const thresholds = {\n        startScrollingFrom,\n        maxScrollValueAt\n    };\n    return thresholds;\n};\nvar getPercentage = ({ startOfRange, endOfRange, current })=>{\n    const range = endOfRange - startOfRange;\n    if (range === 0) {\n         true ? warning(`\n      Detected distance range of 0 in the fluid auto scroller\n      This is unexpected and would cause a divide by 0 issue.\n      Not allowing an auto scroll\n    `) : 0;\n        return 0;\n    }\n    const currentInRange = current - startOfRange;\n    const percentage = currentInRange / range;\n    return percentage;\n};\nvar minScroll = 1;\nvar getValueFromDistance = (distanceToEdge, thresholds, getAutoScrollerOptions = ()=>defaultAutoScrollerOptions)=>{\n    const autoScrollerOptions = getAutoScrollerOptions();\n    if (distanceToEdge > thresholds.startScrollingFrom) {\n        return 0;\n    }\n    if (distanceToEdge <= thresholds.maxScrollValueAt) {\n        return autoScrollerOptions.maxPixelScroll;\n    }\n    if (distanceToEdge === thresholds.startScrollingFrom) {\n        return minScroll;\n    }\n    const percentageFromMaxScrollValueAt = getPercentage({\n        startOfRange: thresholds.maxScrollValueAt,\n        endOfRange: thresholds.startScrollingFrom,\n        current: distanceToEdge\n    });\n    const percentageFromStartScrollingFrom = 1 - percentageFromMaxScrollValueAt;\n    const scroll = autoScrollerOptions.maxPixelScroll * autoScrollerOptions.ease(percentageFromStartScrollingFrom);\n    return Math.ceil(scroll);\n};\nvar dampenValueByTime = (proposedScroll, dragStartTime, getAutoScrollerOptions)=>{\n    const autoScrollerOptions = getAutoScrollerOptions();\n    const accelerateAt = autoScrollerOptions.durationDampening.accelerateAt;\n    const stopAt = autoScrollerOptions.durationDampening.stopDampeningAt;\n    const startOfRange = dragStartTime;\n    const endOfRange = stopAt;\n    const now = Date.now();\n    const runTime = now - startOfRange;\n    if (runTime >= stopAt) {\n        return proposedScroll;\n    }\n    if (runTime < accelerateAt) {\n        return minScroll;\n    }\n    const betweenAccelerateAtAndStopAtPercentage = getPercentage({\n        startOfRange: accelerateAt,\n        endOfRange,\n        current: runTime\n    });\n    const scroll = proposedScroll * autoScrollerOptions.ease(betweenAccelerateAtAndStopAtPercentage);\n    return Math.ceil(scroll);\n};\nvar getValue = ({ distanceToEdge, thresholds, dragStartTime, shouldUseTimeDampening, getAutoScrollerOptions })=>{\n    const scroll = getValueFromDistance(distanceToEdge, thresholds, getAutoScrollerOptions);\n    if (scroll === 0) {\n        return 0;\n    }\n    if (!shouldUseTimeDampening) {\n        return scroll;\n    }\n    return Math.max(dampenValueByTime(scroll, dragStartTime, getAutoScrollerOptions), minScroll);\n};\nvar getScrollOnAxis = ({ container, distanceToEdges, dragStartTime, axis, shouldUseTimeDampening, getAutoScrollerOptions })=>{\n    const thresholds = getDistanceThresholds(container, axis, getAutoScrollerOptions);\n    const isCloserToEnd = distanceToEdges[axis.end] < distanceToEdges[axis.start];\n    if (isCloserToEnd) {\n        return getValue({\n            distanceToEdge: distanceToEdges[axis.end],\n            thresholds,\n            dragStartTime,\n            shouldUseTimeDampening,\n            getAutoScrollerOptions\n        });\n    }\n    return -1 * getValue({\n        distanceToEdge: distanceToEdges[axis.start],\n        thresholds,\n        dragStartTime,\n        shouldUseTimeDampening,\n        getAutoScrollerOptions\n    });\n};\nvar adjustForSizeLimits = ({ container, subject, proposedScroll })=>{\n    const isTooBigVertically = subject.height > container.height;\n    const isTooBigHorizontally = subject.width > container.width;\n    if (!isTooBigHorizontally && !isTooBigVertically) {\n        return proposedScroll;\n    }\n    if (isTooBigHorizontally && isTooBigVertically) {\n        return null;\n    }\n    return {\n        x: isTooBigHorizontally ? 0 : proposedScroll.x,\n        y: isTooBigVertically ? 0 : proposedScroll.y\n    };\n};\nconst clean = apply((value)=>value === 0 ? 0 : value);\nvar getScroll$1 = ({ dragStartTime, container, subject, center, shouldUseTimeDampening, getAutoScrollerOptions })=>{\n    const distanceToEdges = {\n        top: center.y - container.top,\n        right: container.right - center.x,\n        bottom: container.bottom - center.y,\n        left: center.x - container.left\n    };\n    const y = getScrollOnAxis({\n        container,\n        distanceToEdges,\n        dragStartTime,\n        axis: vertical,\n        shouldUseTimeDampening,\n        getAutoScrollerOptions\n    });\n    const x = getScrollOnAxis({\n        container,\n        distanceToEdges,\n        dragStartTime,\n        axis: horizontal,\n        shouldUseTimeDampening,\n        getAutoScrollerOptions\n    });\n    const required = clean({\n        x,\n        y\n    });\n    if (isEqual$1(required, origin)) {\n        return null;\n    }\n    const limited = adjustForSizeLimits({\n        container,\n        subject,\n        proposedScroll: required\n    });\n    if (!limited) {\n        return null;\n    }\n    return isEqual$1(limited, origin) ? null : limited;\n};\nconst smallestSigned = apply((value)=>{\n    if (value === 0) {\n        return 0;\n    }\n    return value > 0 ? 1 : -1;\n});\nconst getOverlap = (()=>{\n    const getRemainder = (target, max)=>{\n        if (target < 0) {\n            return target;\n        }\n        if (target > max) {\n            return target - max;\n        }\n        return 0;\n    };\n    return ({ current, max, change })=>{\n        const targetScroll = add(current, change);\n        const overlap = {\n            x: getRemainder(targetScroll.x, max.x),\n            y: getRemainder(targetScroll.y, max.y)\n        };\n        if (isEqual$1(overlap, origin)) {\n            return null;\n        }\n        return overlap;\n    };\n})();\nconst canPartiallyScroll = ({ max: rawMax, current, change })=>{\n    const max = {\n        x: Math.max(current.x, rawMax.x),\n        y: Math.max(current.y, rawMax.y)\n    };\n    const smallestChange = smallestSigned(change);\n    const overlap = getOverlap({\n        max,\n        current,\n        change: smallestChange\n    });\n    if (!overlap) {\n        return true;\n    }\n    if (smallestChange.x !== 0 && overlap.x === 0) {\n        return true;\n    }\n    if (smallestChange.y !== 0 && overlap.y === 0) {\n        return true;\n    }\n    return false;\n};\nconst canScrollWindow = (viewport, change)=>canPartiallyScroll({\n        current: viewport.scroll.current,\n        max: viewport.scroll.max,\n        change\n    });\nconst getWindowOverlap = (viewport, change)=>{\n    if (!canScrollWindow(viewport, change)) {\n        return null;\n    }\n    const max = viewport.scroll.max;\n    const current = viewport.scroll.current;\n    return getOverlap({\n        current,\n        max,\n        change\n    });\n};\nconst canScrollDroppable = (droppable, change)=>{\n    const frame = droppable.frame;\n    if (!frame) {\n        return false;\n    }\n    return canPartiallyScroll({\n        current: frame.scroll.current,\n        max: frame.scroll.max,\n        change\n    });\n};\nconst getDroppableOverlap = (droppable, change)=>{\n    const frame = droppable.frame;\n    if (!frame) {\n        return null;\n    }\n    if (!canScrollDroppable(droppable, change)) {\n        return null;\n    }\n    return getOverlap({\n        current: frame.scroll.current,\n        max: frame.scroll.max,\n        change\n    });\n};\nvar getWindowScrollChange = ({ viewport, subject, center, dragStartTime, shouldUseTimeDampening, getAutoScrollerOptions })=>{\n    const scroll = getScroll$1({\n        dragStartTime,\n        container: viewport.frame,\n        subject,\n        center,\n        shouldUseTimeDampening,\n        getAutoScrollerOptions\n    });\n    return scroll && canScrollWindow(viewport, scroll) ? scroll : null;\n};\nvar getDroppableScrollChange = ({ droppable, subject, center, dragStartTime, shouldUseTimeDampening, getAutoScrollerOptions })=>{\n    const frame = droppable.frame;\n    if (!frame) {\n        return null;\n    }\n    const scroll = getScroll$1({\n        dragStartTime,\n        container: frame.pageMarginBox,\n        subject,\n        center,\n        shouldUseTimeDampening,\n        getAutoScrollerOptions\n    });\n    return scroll && canScrollDroppable(droppable, scroll) ? scroll : null;\n};\nvar scroll = ({ state, dragStartTime, shouldUseTimeDampening, scrollWindow, scrollDroppable, getAutoScrollerOptions })=>{\n    const center = state.current.page.borderBoxCenter;\n    const draggable = state.dimensions.draggables[state.critical.draggable.id];\n    const subject = draggable.page.marginBox;\n    if (state.isWindowScrollAllowed) {\n        const viewport = state.viewport;\n        const change = getWindowScrollChange({\n            dragStartTime,\n            viewport,\n            subject,\n            center,\n            shouldUseTimeDampening,\n            getAutoScrollerOptions\n        });\n        if (change) {\n            scrollWindow(change);\n            return;\n        }\n    }\n    const droppable = getBestScrollableDroppable({\n        center,\n        destination: whatIsDraggedOver(state.impact),\n        droppables: state.dimensions.droppables\n    });\n    if (!droppable) {\n        return;\n    }\n    const change = getDroppableScrollChange({\n        dragStartTime,\n        droppable,\n        subject,\n        center,\n        shouldUseTimeDampening,\n        getAutoScrollerOptions\n    });\n    if (change) {\n        scrollDroppable(droppable.descriptor.id, change);\n    }\n};\nvar createFluidScroller = ({ scrollWindow, scrollDroppable, getAutoScrollerOptions = ()=>defaultAutoScrollerOptions })=>{\n    const scheduleWindowScroll = (0,raf_schd__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(scrollWindow);\n    const scheduleDroppableScroll = (0,raf_schd__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(scrollDroppable);\n    let dragging = null;\n    const tryScroll = (state)=>{\n        !dragging ?  true ? invariant(false, \"Cannot fluid scroll if not dragging\") : 0 : void 0;\n        const { shouldUseTimeDampening, dragStartTime } = dragging;\n        scroll({\n            state,\n            scrollWindow: scheduleWindowScroll,\n            scrollDroppable: scheduleDroppableScroll,\n            dragStartTime,\n            shouldUseTimeDampening,\n            getAutoScrollerOptions\n        });\n    };\n    const start$1 = (state)=>{\n        start();\n        !!dragging ?  true ? invariant(false, \"Cannot start auto scrolling when already started\") : 0 : void 0;\n        const dragStartTime = Date.now();\n        let wasScrollNeeded = false;\n        const fakeScrollCallback = ()=>{\n            wasScrollNeeded = true;\n        };\n        scroll({\n            state,\n            dragStartTime: 0,\n            shouldUseTimeDampening: false,\n            scrollWindow: fakeScrollCallback,\n            scrollDroppable: fakeScrollCallback,\n            getAutoScrollerOptions\n        });\n        dragging = {\n            dragStartTime,\n            shouldUseTimeDampening: wasScrollNeeded\n        };\n        finish();\n        if (wasScrollNeeded) {\n            tryScroll(state);\n        }\n    };\n    const stop = ()=>{\n        if (!dragging) {\n            return;\n        }\n        scheduleWindowScroll.cancel();\n        scheduleDroppableScroll.cancel();\n        dragging = null;\n    };\n    return {\n        start: start$1,\n        stop,\n        scroll: tryScroll\n    };\n};\nvar createJumpScroller = ({ move, scrollDroppable, scrollWindow })=>{\n    const moveByOffset = (state, offset)=>{\n        const client = add(state.current.client.selection, offset);\n        move({\n            client\n        });\n    };\n    const scrollDroppableAsMuchAsItCan = (droppable, change)=>{\n        if (!canScrollDroppable(droppable, change)) {\n            return change;\n        }\n        const overlap = getDroppableOverlap(droppable, change);\n        if (!overlap) {\n            scrollDroppable(droppable.descriptor.id, change);\n            return null;\n        }\n        const whatTheDroppableCanScroll = subtract(change, overlap);\n        scrollDroppable(droppable.descriptor.id, whatTheDroppableCanScroll);\n        const remainder = subtract(change, whatTheDroppableCanScroll);\n        return remainder;\n    };\n    const scrollWindowAsMuchAsItCan = (isWindowScrollAllowed, viewport, change)=>{\n        if (!isWindowScrollAllowed) {\n            return change;\n        }\n        if (!canScrollWindow(viewport, change)) {\n            return change;\n        }\n        const overlap = getWindowOverlap(viewport, change);\n        if (!overlap) {\n            scrollWindow(change);\n            return null;\n        }\n        const whatTheWindowCanScroll = subtract(change, overlap);\n        scrollWindow(whatTheWindowCanScroll);\n        const remainder = subtract(change, whatTheWindowCanScroll);\n        return remainder;\n    };\n    const jumpScroller = (state)=>{\n        const request = state.scrollJumpRequest;\n        if (!request) {\n            return;\n        }\n        const destination = whatIsDraggedOver(state.impact);\n        !destination ?  true ? invariant(false, \"Cannot perform a jump scroll when there is no destination\") : 0 : void 0;\n        const droppableRemainder = scrollDroppableAsMuchAsItCan(state.dimensions.droppables[destination], request);\n        if (!droppableRemainder) {\n            return;\n        }\n        const viewport = state.viewport;\n        const windowRemainder = scrollWindowAsMuchAsItCan(state.isWindowScrollAllowed, viewport, droppableRemainder);\n        if (!windowRemainder) {\n            return;\n        }\n        moveByOffset(state, windowRemainder);\n    };\n    return jumpScroller;\n};\nvar createAutoScroller = ({ scrollDroppable, scrollWindow, move, getAutoScrollerOptions })=>{\n    const fluidScroller = createFluidScroller({\n        scrollWindow,\n        scrollDroppable,\n        getAutoScrollerOptions\n    });\n    const jumpScroll = createJumpScroller({\n        move,\n        scrollWindow,\n        scrollDroppable\n    });\n    const scroll = (state)=>{\n        const autoScrollerOptions = getAutoScrollerOptions();\n        if (autoScrollerOptions.disabled || state.phase !== \"DRAGGING\") {\n            return;\n        }\n        if (state.movementMode === \"FLUID\") {\n            fluidScroller.scroll(state);\n            return;\n        }\n        if (!state.scrollJumpRequest) {\n            return;\n        }\n        jumpScroll(state);\n    };\n    const scroller = {\n        scroll,\n        start: fluidScroller.start,\n        stop: fluidScroller.stop\n    };\n    return scroller;\n};\nconst prefix = \"data-rfd\";\nconst dragHandle = (()=>{\n    const base = `${prefix}-drag-handle`;\n    return {\n        base,\n        draggableId: `${base}-draggable-id`,\n        contextId: `${base}-context-id`\n    };\n})();\nconst draggable = (()=>{\n    const base = `${prefix}-draggable`;\n    return {\n        base,\n        contextId: `${base}-context-id`,\n        id: `${base}-id`\n    };\n})();\nconst droppable = (()=>{\n    const base = `${prefix}-droppable`;\n    return {\n        base,\n        contextId: `${base}-context-id`,\n        id: `${base}-id`\n    };\n})();\nconst scrollContainer = {\n    contextId: `${prefix}-scroll-container-context-id`\n};\nconst makeGetSelector = (context)=>(attribute)=>`[${attribute}=\"${context}\"]`;\nconst getStyles = (rules, property)=>rules.map((rule)=>{\n        const value = rule.styles[property];\n        if (!value) {\n            return \"\";\n        }\n        return `${rule.selector} { ${value} }`;\n    }).join(\" \");\nconst noPointerEvents = \"pointer-events: none;\";\nvar getStyles$1 = (contextId)=>{\n    const getSelector = makeGetSelector(contextId);\n    const dragHandle$1 = (()=>{\n        const grabCursor = `\n      cursor: -webkit-grab;\n      cursor: grab;\n    `;\n        return {\n            selector: getSelector(dragHandle.contextId),\n            styles: {\n                always: `\n          -webkit-touch-callout: none;\n          -webkit-tap-highlight-color: rgba(0,0,0,0);\n          touch-action: manipulation;\n        `,\n                resting: grabCursor,\n                dragging: noPointerEvents,\n                dropAnimating: grabCursor\n            }\n        };\n    })();\n    const draggable$1 = (()=>{\n        const transition = `\n      transition: ${transitions.outOfTheWay};\n    `;\n        return {\n            selector: getSelector(draggable.contextId),\n            styles: {\n                dragging: transition,\n                dropAnimating: transition,\n                userCancel: transition\n            }\n        };\n    })();\n    const droppable$1 = {\n        selector: getSelector(droppable.contextId),\n        styles: {\n            always: `overflow-anchor: none;`\n        }\n    };\n    const body = {\n        selector: \"body\",\n        styles: {\n            dragging: `\n        cursor: grabbing;\n        cursor: -webkit-grabbing;\n        user-select: none;\n        -webkit-user-select: none;\n        -moz-user-select: none;\n        -ms-user-select: none;\n        overflow-anchor: none;\n      `\n        }\n    };\n    const rules = [\n        draggable$1,\n        dragHandle$1,\n        droppable$1,\n        body\n    ];\n    return {\n        always: getStyles(rules, \"always\"),\n        resting: getStyles(rules, \"resting\"),\n        dragging: getStyles(rules, \"dragging\"),\n        dropAnimating: getStyles(rules, \"dropAnimating\"),\n        userCancel: getStyles(rules, \"userCancel\")\n    };\n};\nconst useIsomorphicLayoutEffect =  false ? 0 : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nvar useLayoutEffect = useIsomorphicLayoutEffect;\nconst getHead = ()=>{\n    const head = document.querySelector(\"head\");\n    !head ?  true ? invariant(false, \"Cannot find the head to append a style to\") : 0 : void 0;\n    return head;\n};\nconst createStyleEl = (nonce)=>{\n    const el = document.createElement(\"style\");\n    if (nonce) {\n        el.setAttribute(\"nonce\", nonce);\n    }\n    el.type = \"text/css\";\n    return el;\n};\nfunction useStyleMarshal(contextId, nonce) {\n    const styles = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>getStyles$1(contextId), [\n        contextId\n    ]);\n    const alwaysRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const dynamicRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const setDynamicStyle = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)((0,memoize_one__WEBPACK_IMPORTED_MODULE_5__[\"default\"])((proposed)=>{\n        const el = dynamicRef.current;\n        !el ?  true ? invariant(false, \"Cannot set dynamic style element if it is not set\") : 0 : void 0;\n        el.textContent = proposed;\n    }), []);\n    const setAlwaysStyle = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)((proposed)=>{\n        const el = alwaysRef.current;\n        !el ?  true ? invariant(false, \"Cannot set dynamic style element if it is not set\") : 0 : void 0;\n        el.textContent = proposed;\n    }, []);\n    useLayoutEffect(()=>{\n        !(!alwaysRef.current && !dynamicRef.current) ?  true ? invariant(false, \"style elements already mounted\") : 0 : void 0;\n        const always = createStyleEl(nonce);\n        const dynamic = createStyleEl(nonce);\n        alwaysRef.current = always;\n        dynamicRef.current = dynamic;\n        always.setAttribute(`${prefix}-always`, contextId);\n        dynamic.setAttribute(`${prefix}-dynamic`, contextId);\n        getHead().appendChild(always);\n        getHead().appendChild(dynamic);\n        setAlwaysStyle(styles.always);\n        setDynamicStyle(styles.resting);\n        return ()=>{\n            const remove = (ref)=>{\n                const current = ref.current;\n                !current ?  true ? invariant(false, \"Cannot unmount ref as it is not set\") : 0 : void 0;\n                getHead().removeChild(current);\n                ref.current = null;\n            };\n            remove(alwaysRef);\n            remove(dynamicRef);\n        };\n    }, [\n        nonce,\n        setAlwaysStyle,\n        setDynamicStyle,\n        styles.always,\n        styles.resting,\n        contextId\n    ]);\n    const dragging = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(()=>setDynamicStyle(styles.dragging), [\n        setDynamicStyle,\n        styles.dragging\n    ]);\n    const dropping = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)((reason)=>{\n        if (reason === \"DROP\") {\n            setDynamicStyle(styles.dropAnimating);\n            return;\n        }\n        setDynamicStyle(styles.userCancel);\n    }, [\n        setDynamicStyle,\n        styles.dropAnimating,\n        styles.userCancel\n    ]);\n    const resting = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(()=>{\n        if (!dynamicRef.current) {\n            return;\n        }\n        setDynamicStyle(styles.resting);\n    }, [\n        setDynamicStyle,\n        styles.resting\n    ]);\n    const marshal = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>({\n            dragging,\n            dropping,\n            resting\n        }), [\n        dragging,\n        dropping,\n        resting\n    ]);\n    return marshal;\n}\nfunction querySelectorAll(parentNode, selector) {\n    return Array.from(parentNode.querySelectorAll(selector));\n}\nvar getWindowFromEl = (el)=>{\n    if (el && el.ownerDocument && el.ownerDocument.defaultView) {\n        return el.ownerDocument.defaultView;\n    }\n    return window;\n};\nfunction isHtmlElement(el) {\n    return el instanceof getWindowFromEl(el).HTMLElement;\n}\nfunction findDragHandle(contextId, draggableId) {\n    const selector = `[${dragHandle.contextId}=\"${contextId}\"]`;\n    const possible = querySelectorAll(document, selector);\n    if (!possible.length) {\n         true ? warning(`Unable to find any drag handles in the context \"${contextId}\"`) : 0;\n        return null;\n    }\n    const handle = possible.find((el)=>{\n        return el.getAttribute(dragHandle.draggableId) === draggableId;\n    });\n    if (!handle) {\n         true ? warning(`Unable to find drag handle with id \"${draggableId}\" as no handle with a matching id was found`) : 0;\n        return null;\n    }\n    if (!isHtmlElement(handle)) {\n         true ? warning(\"drag handle needs to be a HTMLElement\") : 0;\n        return null;\n    }\n    return handle;\n}\nfunction useFocusMarshal(contextId) {\n    const entriesRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({});\n    const recordRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const restoreFocusFrameRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const isMountedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const register = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(function register(id, focus) {\n        const entry = {\n            id,\n            focus\n        };\n        entriesRef.current[id] = entry;\n        return function unregister() {\n            const entries = entriesRef.current;\n            const current = entries[id];\n            if (current !== entry) {\n                delete entries[id];\n            }\n        };\n    }, []);\n    const tryGiveFocus = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(function tryGiveFocus(tryGiveFocusTo) {\n        const handle = findDragHandle(contextId, tryGiveFocusTo);\n        if (handle && handle !== document.activeElement) {\n            handle.focus();\n        }\n    }, [\n        contextId\n    ]);\n    const tryShiftRecord = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(function tryShiftRecord(previous, redirectTo) {\n        if (recordRef.current === previous) {\n            recordRef.current = redirectTo;\n        }\n    }, []);\n    const tryRestoreFocusRecorded = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(function tryRestoreFocusRecorded() {\n        if (restoreFocusFrameRef.current) {\n            return;\n        }\n        if (!isMountedRef.current) {\n            return;\n        }\n        restoreFocusFrameRef.current = requestAnimationFrame(()=>{\n            restoreFocusFrameRef.current = null;\n            const record = recordRef.current;\n            if (record) {\n                tryGiveFocus(record);\n            }\n        });\n    }, [\n        tryGiveFocus\n    ]);\n    const tryRecordFocus = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(function tryRecordFocus(id) {\n        recordRef.current = null;\n        const focused = document.activeElement;\n        if (!focused) {\n            return;\n        }\n        if (focused.getAttribute(dragHandle.draggableId) !== id) {\n            return;\n        }\n        recordRef.current = id;\n    }, []);\n    useLayoutEffect(()=>{\n        isMountedRef.current = true;\n        return function clearFrameOnUnmount() {\n            isMountedRef.current = false;\n            const frameId = restoreFocusFrameRef.current;\n            if (frameId) {\n                cancelAnimationFrame(frameId);\n            }\n        };\n    }, []);\n    const marshal = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>({\n            register,\n            tryRecordFocus,\n            tryRestoreFocusRecorded,\n            tryShiftRecord\n        }), [\n        register,\n        tryRecordFocus,\n        tryRestoreFocusRecorded,\n        tryShiftRecord\n    ]);\n    return marshal;\n}\nfunction createRegistry() {\n    const entries = {\n        draggables: {},\n        droppables: {}\n    };\n    const subscribers = [];\n    function subscribe(cb) {\n        subscribers.push(cb);\n        return function unsubscribe() {\n            const index = subscribers.indexOf(cb);\n            if (index === -1) {\n                return;\n            }\n            subscribers.splice(index, 1);\n        };\n    }\n    function notify(event) {\n        if (subscribers.length) {\n            subscribers.forEach((cb)=>cb(event));\n        }\n    }\n    function findDraggableById(id) {\n        return entries.draggables[id] || null;\n    }\n    function getDraggableById(id) {\n        const entry = findDraggableById(id);\n        !entry ?  true ? invariant(false, `Cannot find draggable entry with id [${id}]`) : 0 : void 0;\n        return entry;\n    }\n    const draggableAPI = {\n        register: (entry)=>{\n            entries.draggables[entry.descriptor.id] = entry;\n            notify({\n                type: \"ADDITION\",\n                value: entry\n            });\n        },\n        update: (entry, last)=>{\n            const current = entries.draggables[last.descriptor.id];\n            if (!current) {\n                return;\n            }\n            if (current.uniqueId !== entry.uniqueId) {\n                return;\n            }\n            delete entries.draggables[last.descriptor.id];\n            entries.draggables[entry.descriptor.id] = entry;\n        },\n        unregister: (entry)=>{\n            const draggableId = entry.descriptor.id;\n            const current = findDraggableById(draggableId);\n            if (!current) {\n                return;\n            }\n            if (entry.uniqueId !== current.uniqueId) {\n                return;\n            }\n            delete entries.draggables[draggableId];\n            if (entries.droppables[entry.descriptor.droppableId]) {\n                notify({\n                    type: \"REMOVAL\",\n                    value: entry\n                });\n            }\n        },\n        getById: getDraggableById,\n        findById: findDraggableById,\n        exists: (id)=>Boolean(findDraggableById(id)),\n        getAllByType: (type)=>Object.values(entries.draggables).filter((entry)=>entry.descriptor.type === type)\n    };\n    function findDroppableById(id) {\n        return entries.droppables[id] || null;\n    }\n    function getDroppableById(id) {\n        const entry = findDroppableById(id);\n        !entry ?  true ? invariant(false, `Cannot find droppable entry with id [${id}]`) : 0 : void 0;\n        return entry;\n    }\n    const droppableAPI = {\n        register: (entry)=>{\n            entries.droppables[entry.descriptor.id] = entry;\n        },\n        unregister: (entry)=>{\n            const current = findDroppableById(entry.descriptor.id);\n            if (!current) {\n                return;\n            }\n            if (entry.uniqueId !== current.uniqueId) {\n                return;\n            }\n            delete entries.droppables[entry.descriptor.id];\n        },\n        getById: getDroppableById,\n        findById: findDroppableById,\n        exists: (id)=>Boolean(findDroppableById(id)),\n        getAllByType: (type)=>Object.values(entries.droppables).filter((entry)=>entry.descriptor.type === type)\n    };\n    function clean() {\n        entries.draggables = {};\n        entries.droppables = {};\n        subscribers.length = 0;\n    }\n    return {\n        draggable: draggableAPI,\n        droppable: droppableAPI,\n        subscribe,\n        clean\n    };\n}\nfunction useRegistry() {\n    const registry = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(createRegistry, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        return function unmount() {\n            if (react__WEBPACK_IMPORTED_MODULE_0___default().version.startsWith(\"16\") || react__WEBPACK_IMPORTED_MODULE_0___default().version.startsWith(\"17\")) {\n                requestAnimationFrame(registry.clean);\n            } else {\n                registry.clean();\n            }\n        };\n    }, [\n        registry\n    ]);\n    return registry;\n}\nvar StoreContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createContext(null);\nvar getBodyElement = ()=>{\n    const body = document.body;\n    !body ?  true ? invariant(false, \"Cannot find document.body\") : 0 : void 0;\n    return body;\n};\nconst visuallyHidden = {\n    position: \"absolute\",\n    width: \"1px\",\n    height: \"1px\",\n    margin: \"-1px\",\n    border: \"0\",\n    padding: \"0\",\n    overflow: \"hidden\",\n    clip: \"rect(0 0 0 0)\",\n    \"clip-path\": \"inset(100%)\"\n};\nvar visuallyHidden$1 = visuallyHidden;\nconst getId = (contextId)=>`rfd-announcement-${contextId}`;\nfunction useAnnouncer(contextId) {\n    const id = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>getId(contextId), [\n        contextId\n    ]);\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function setup() {\n        const el = document.createElement(\"div\");\n        ref.current = el;\n        el.id = id;\n        el.setAttribute(\"aria-live\", \"assertive\");\n        el.setAttribute(\"aria-atomic\", \"true\");\n        (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(el.style, visuallyHidden$1);\n        getBodyElement().appendChild(el);\n        return function cleanup() {\n            setTimeout(function remove() {\n                const body = getBodyElement();\n                if (body.contains(el)) {\n                    body.removeChild(el);\n                }\n                if (el === ref.current) {\n                    ref.current = null;\n                }\n            });\n        };\n    }, [\n        id\n    ]);\n    const announce = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)((message)=>{\n        const el = ref.current;\n        if (el) {\n            el.textContent = message;\n            return;\n        }\n         true ? warning(`\n      A screen reader message was trying to be announced but it was unable to do so.\n      This can occur if you unmount your <DragDropContext /> in your onDragEnd.\n      Consider calling provided.announce() before the unmount so that the instruction will\n      not be lost for users relying on a screen reader.\n\n      Message not passed to screen reader:\n\n      \"${message}\"\n    `) : 0;\n    }, []);\n    return announce;\n}\nlet count$1 = 0;\nconst defaults = {\n    separator: \"::\"\n};\nfunction resetDeprecatedUniqueId() {\n    count$1 = 0;\n}\nfunction useDeprecatedUniqueId(prefix, options = defaults) {\n    return (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>`${prefix}${options.separator}${count$1++}`, [\n        options.separator,\n        prefix\n    ]);\n}\nfunction useUniqueId(prefix, options = defaults) {\n    const id = react__WEBPACK_IMPORTED_MODULE_0___default().useId();\n    return (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>`${prefix}${options.separator}${id}`, [\n        options.separator,\n        prefix,\n        id\n    ]);\n}\nvar useUniqueId$1 = \"useId\" in (react__WEBPACK_IMPORTED_MODULE_0___default()) ? useUniqueId : useDeprecatedUniqueId;\nfunction getElementId({ contextId, uniqueId }) {\n    return `rfd-hidden-text-${contextId}-${uniqueId}`;\n}\nfunction useHiddenTextElement({ contextId, text }) {\n    const uniqueId = useUniqueId$1(\"hidden-text\", {\n        separator: \"-\"\n    });\n    const id = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>getElementId({\n            contextId,\n            uniqueId\n        }), [\n        uniqueId,\n        contextId\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function mount() {\n        const el = document.createElement(\"div\");\n        el.id = id;\n        el.textContent = text;\n        el.style.display = \"none\";\n        getBodyElement().appendChild(el);\n        return function unmount() {\n            const body = getBodyElement();\n            if (body.contains(el)) {\n                body.removeChild(el);\n            }\n        };\n    }, [\n        id,\n        text\n    ]);\n    return id;\n}\nvar AppContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createContext(null);\nvar peerDependencies = {\n    react: \"^16.8.5 || ^17.0.0 || ^18.0.0\",\n    \"react-dom\": \"^16.8.5 || ^17.0.0 || ^18.0.0\"\n};\nconst semver = /(\\d+)\\.(\\d+)\\.(\\d+)/;\nconst getVersion = (value)=>{\n    const result = semver.exec(value);\n    !(result != null) ?  true ? invariant(false, `Unable to parse React version ${value}`) : 0 : void 0;\n    const major = Number(result[1]);\n    const minor = Number(result[2]);\n    const patch = Number(result[3]);\n    return {\n        major,\n        minor,\n        patch,\n        raw: value\n    };\n};\nconst isSatisfied = (expected, actual)=>{\n    if (actual.major > expected.major) {\n        return true;\n    }\n    if (actual.major < expected.major) {\n        return false;\n    }\n    if (actual.minor > expected.minor) {\n        return true;\n    }\n    if (actual.minor < expected.minor) {\n        return false;\n    }\n    return actual.patch >= expected.patch;\n};\nvar checkReactVersion = (peerDepValue, actualValue)=>{\n    const peerDep = getVersion(peerDepValue);\n    const actual = getVersion(actualValue);\n    if (isSatisfied(peerDep, actual)) {\n        return;\n    }\n     true ? warning(`\n    React version: [${actual.raw}]\n    does not satisfy expected peer dependency version: [${peerDep.raw}]\n\n    This can result in run time bugs, and even fatal crashes\n  `) : 0;\n};\nconst suffix = `\n  We expect a html5 doctype: <!doctype html>\n  This is to ensure consistent browser layout and measurement\n\n  More information: https://github.com/hello-pangea/dnd/blob/main/docs/guides/doctype.md\n`;\nvar checkDoctype = (doc)=>{\n    const doctype = doc.doctype;\n    if (!doctype) {\n         true ? warning(`\n      No <!doctype html> found.\n\n      ${suffix}\n    `) : 0;\n        return;\n    }\n    if (doctype.name.toLowerCase() !== \"html\") {\n         true ? warning(`\n      Unexpected <!doctype> found: (${doctype.name})\n\n      ${suffix}\n    `) : 0;\n    }\n    if (doctype.publicId !== \"\") {\n         true ? warning(`\n      Unexpected <!doctype> publicId found: (${doctype.publicId})\n      A html5 doctype does not have a publicId\n\n      ${suffix}\n    `) : 0;\n    }\n};\nfunction useDev(useHook) {\n    if (true) {\n        useHook();\n    }\n}\nfunction useDevSetupWarning(fn, inputs) {\n    useDev(()=>{\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n            try {\n                fn();\n            } catch (e) {\n                error(`\n          A setup problem was encountered.\n\n          > ${e.message}\n        `);\n            }\n        }, inputs);\n    });\n}\nfunction useStartupValidation() {\n    useDevSetupWarning(()=>{\n        checkReactVersion(peerDependencies.react, (react__WEBPACK_IMPORTED_MODULE_0___default().version));\n        checkDoctype(document);\n    }, []);\n}\nfunction usePrevious(current) {\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(current);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        ref.current = current;\n    });\n    return ref;\n}\nfunction create() {\n    let lock = null;\n    function isClaimed() {\n        return Boolean(lock);\n    }\n    function isActive(value) {\n        return value === lock;\n    }\n    function claim(abandon) {\n        !!lock ?  true ? invariant(false, \"Cannot claim lock as it is already claimed\") : 0 : void 0;\n        const newLock = {\n            abandon\n        };\n        lock = newLock;\n        return newLock;\n    }\n    function release() {\n        !lock ?  true ? invariant(false, \"Cannot release lock when there is no lock\") : 0 : void 0;\n        lock = null;\n    }\n    function tryAbandon() {\n        if (lock) {\n            lock.abandon();\n            release();\n        }\n    }\n    return {\n        isClaimed,\n        isActive,\n        claim,\n        release,\n        tryAbandon\n    };\n}\nfunction isDragging(state) {\n    if (state.phase === \"IDLE\" || state.phase === \"DROP_ANIMATING\") {\n        return false;\n    }\n    return state.isDragging;\n}\nconst tab = 9;\nconst enter = 13;\nconst escape = 27;\nconst space = 32;\nconst pageUp = 33;\nconst pageDown = 34;\nconst end = 35;\nconst home = 36;\nconst arrowLeft = 37;\nconst arrowUp = 38;\nconst arrowRight = 39;\nconst arrowDown = 40;\nconst preventedKeys = {\n    [enter]: true,\n    [tab]: true\n};\nvar preventStandardKeyEvents = (event)=>{\n    if (preventedKeys[event.keyCode]) {\n        event.preventDefault();\n    }\n};\nconst supportedEventName = (()=>{\n    const base = \"visibilitychange\";\n    if (typeof document === \"undefined\") {\n        return base;\n    }\n    const candidates = [\n        base,\n        `ms${base}`,\n        `webkit${base}`,\n        `moz${base}`,\n        `o${base}`\n    ];\n    const supported = candidates.find((eventName)=>`on${eventName}` in document);\n    return supported || base;\n})();\nvar supportedPageVisibilityEventName = supportedEventName;\nconst primaryButton = 0;\nconst sloppyClickThreshold = 5;\nfunction isSloppyClickThresholdExceeded(original, current) {\n    return Math.abs(current.x - original.x) >= sloppyClickThreshold || Math.abs(current.y - original.y) >= sloppyClickThreshold;\n}\nconst idle$1 = {\n    type: \"IDLE\"\n};\nfunction getCaptureBindings({ cancel, completed, getPhase, setPhase }) {\n    return [\n        {\n            eventName: \"mousemove\",\n            fn: (event)=>{\n                const { button, clientX, clientY } = event;\n                if (button !== primaryButton) {\n                    return;\n                }\n                const point = {\n                    x: clientX,\n                    y: clientY\n                };\n                const phase = getPhase();\n                if (phase.type === \"DRAGGING\") {\n                    event.preventDefault();\n                    phase.actions.move(point);\n                    return;\n                }\n                !(phase.type === \"PENDING\") ?  true ? invariant(false, \"Cannot be IDLE\") : 0 : void 0;\n                const pending = phase.point;\n                if (!isSloppyClickThresholdExceeded(pending, point)) {\n                    return;\n                }\n                event.preventDefault();\n                const actions = phase.actions.fluidLift(point);\n                setPhase({\n                    type: \"DRAGGING\",\n                    actions\n                });\n            }\n        },\n        {\n            eventName: \"mouseup\",\n            fn: (event)=>{\n                const phase = getPhase();\n                if (phase.type !== \"DRAGGING\") {\n                    cancel();\n                    return;\n                }\n                event.preventDefault();\n                phase.actions.drop({\n                    shouldBlockNextClick: true\n                });\n                completed();\n            }\n        },\n        {\n            eventName: \"mousedown\",\n            fn: (event)=>{\n                if (getPhase().type === \"DRAGGING\") {\n                    event.preventDefault();\n                }\n                cancel();\n            }\n        },\n        {\n            eventName: \"keydown\",\n            fn: (event)=>{\n                const phase = getPhase();\n                if (phase.type === \"PENDING\") {\n                    cancel();\n                    return;\n                }\n                if (event.keyCode === escape) {\n                    event.preventDefault();\n                    cancel();\n                    return;\n                }\n                preventStandardKeyEvents(event);\n            }\n        },\n        {\n            eventName: \"resize\",\n            fn: cancel\n        },\n        {\n            eventName: \"scroll\",\n            options: {\n                passive: true,\n                capture: false\n            },\n            fn: ()=>{\n                if (getPhase().type === \"PENDING\") {\n                    cancel();\n                }\n            }\n        },\n        {\n            eventName: \"webkitmouseforcedown\",\n            fn: (event)=>{\n                const phase = getPhase();\n                !(phase.type !== \"IDLE\") ?  true ? invariant(false, \"Unexpected phase\") : 0 : void 0;\n                if (phase.actions.shouldRespectForcePress()) {\n                    cancel();\n                    return;\n                }\n                event.preventDefault();\n            }\n        },\n        {\n            eventName: supportedPageVisibilityEventName,\n            fn: cancel\n        }\n    ];\n}\nfunction useMouseSensor(api) {\n    const phaseRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(idle$1);\n    const unbindEventsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(noop$2);\n    const startCaptureBinding = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>({\n            eventName: \"mousedown\",\n            fn: function onMouseDown(event) {\n                if (event.defaultPrevented) {\n                    return;\n                }\n                if (event.button !== primaryButton) {\n                    return;\n                }\n                if (event.ctrlKey || event.metaKey || event.shiftKey || event.altKey) {\n                    return;\n                }\n                const draggableId = api.findClosestDraggableId(event);\n                if (!draggableId) {\n                    return;\n                }\n                const actions = api.tryGetLock(draggableId, stop, {\n                    sourceEvent: event\n                });\n                if (!actions) {\n                    return;\n                }\n                event.preventDefault();\n                const point = {\n                    x: event.clientX,\n                    y: event.clientY\n                };\n                unbindEventsRef.current();\n                startPendingDrag(actions, point);\n            }\n        }), [\n        api\n    ]);\n    const preventForcePressBinding = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>({\n            eventName: \"webkitmouseforcewillbegin\",\n            fn: (event)=>{\n                if (event.defaultPrevented) {\n                    return;\n                }\n                const id = api.findClosestDraggableId(event);\n                if (!id) {\n                    return;\n                }\n                const options = api.findOptionsForDraggable(id);\n                if (!options) {\n                    return;\n                }\n                if (options.shouldRespectForcePress) {\n                    return;\n                }\n                if (!api.canGetLock(id)) {\n                    return;\n                }\n                event.preventDefault();\n            }\n        }), [\n        api\n    ]);\n    const listenForCapture = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(function listenForCapture() {\n        const options = {\n            passive: false,\n            capture: true\n        };\n        unbindEventsRef.current = bindEvents(window, [\n            preventForcePressBinding,\n            startCaptureBinding\n        ], options);\n    }, [\n        preventForcePressBinding,\n        startCaptureBinding\n    ]);\n    const stop = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(()=>{\n        const current = phaseRef.current;\n        if (current.type === \"IDLE\") {\n            return;\n        }\n        phaseRef.current = idle$1;\n        unbindEventsRef.current();\n        listenForCapture();\n    }, [\n        listenForCapture\n    ]);\n    const cancel = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(()=>{\n        const phase = phaseRef.current;\n        stop();\n        if (phase.type === \"DRAGGING\") {\n            phase.actions.cancel({\n                shouldBlockNextClick: true\n            });\n        }\n        if (phase.type === \"PENDING\") {\n            phase.actions.abort();\n        }\n    }, [\n        stop\n    ]);\n    const bindCapturingEvents = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(function bindCapturingEvents() {\n        const options = {\n            capture: true,\n            passive: false\n        };\n        const bindings = getCaptureBindings({\n            cancel,\n            completed: stop,\n            getPhase: ()=>phaseRef.current,\n            setPhase: (phase)=>{\n                phaseRef.current = phase;\n            }\n        });\n        unbindEventsRef.current = bindEvents(window, bindings, options);\n    }, [\n        cancel,\n        stop\n    ]);\n    const startPendingDrag = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(function startPendingDrag(actions, point) {\n        !(phaseRef.current.type === \"IDLE\") ?  true ? invariant(false, \"Expected to move from IDLE to PENDING drag\") : 0 : void 0;\n        phaseRef.current = {\n            type: \"PENDING\",\n            point,\n            actions\n        };\n        bindCapturingEvents();\n    }, [\n        bindCapturingEvents\n    ]);\n    useLayoutEffect(function mount() {\n        listenForCapture();\n        return function unmount() {\n            unbindEventsRef.current();\n        };\n    }, [\n        listenForCapture\n    ]);\n}\nfunction noop$1() {}\nconst scrollJumpKeys = {\n    [pageDown]: true,\n    [pageUp]: true,\n    [home]: true,\n    [end]: true\n};\nfunction getDraggingBindings(actions, stop) {\n    function cancel() {\n        stop();\n        actions.cancel();\n    }\n    function drop() {\n        stop();\n        actions.drop();\n    }\n    return [\n        {\n            eventName: \"keydown\",\n            fn: (event)=>{\n                if (event.keyCode === escape) {\n                    event.preventDefault();\n                    cancel();\n                    return;\n                }\n                if (event.keyCode === space) {\n                    event.preventDefault();\n                    drop();\n                    return;\n                }\n                if (event.keyCode === arrowDown) {\n                    event.preventDefault();\n                    actions.moveDown();\n                    return;\n                }\n                if (event.keyCode === arrowUp) {\n                    event.preventDefault();\n                    actions.moveUp();\n                    return;\n                }\n                if (event.keyCode === arrowRight) {\n                    event.preventDefault();\n                    actions.moveRight();\n                    return;\n                }\n                if (event.keyCode === arrowLeft) {\n                    event.preventDefault();\n                    actions.moveLeft();\n                    return;\n                }\n                if (scrollJumpKeys[event.keyCode]) {\n                    event.preventDefault();\n                    return;\n                }\n                preventStandardKeyEvents(event);\n            }\n        },\n        {\n            eventName: \"mousedown\",\n            fn: cancel\n        },\n        {\n            eventName: \"mouseup\",\n            fn: cancel\n        },\n        {\n            eventName: \"click\",\n            fn: cancel\n        },\n        {\n            eventName: \"touchstart\",\n            fn: cancel\n        },\n        {\n            eventName: \"resize\",\n            fn: cancel\n        },\n        {\n            eventName: \"wheel\",\n            fn: cancel,\n            options: {\n                passive: true\n            }\n        },\n        {\n            eventName: supportedPageVisibilityEventName,\n            fn: cancel\n        }\n    ];\n}\nfunction useKeyboardSensor(api) {\n    const unbindEventsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(noop$1);\n    const startCaptureBinding = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>({\n            eventName: \"keydown\",\n            fn: function onKeyDown(event) {\n                if (event.defaultPrevented) {\n                    return;\n                }\n                if (event.keyCode !== space) {\n                    return;\n                }\n                const draggableId = api.findClosestDraggableId(event);\n                if (!draggableId) {\n                    return;\n                }\n                const preDrag = api.tryGetLock(draggableId, stop, {\n                    sourceEvent: event\n                });\n                if (!preDrag) {\n                    return;\n                }\n                event.preventDefault();\n                let isCapturing = true;\n                const actions = preDrag.snapLift();\n                unbindEventsRef.current();\n                function stop() {\n                    !isCapturing ?  true ? invariant(false, \"Cannot stop capturing a keyboard drag when not capturing\") : 0 : void 0;\n                    isCapturing = false;\n                    unbindEventsRef.current();\n                    listenForCapture();\n                }\n                unbindEventsRef.current = bindEvents(window, getDraggingBindings(actions, stop), {\n                    capture: true,\n                    passive: false\n                });\n            }\n        }), [\n        api\n    ]);\n    const listenForCapture = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(function tryStartCapture() {\n        const options = {\n            passive: false,\n            capture: true\n        };\n        unbindEventsRef.current = bindEvents(window, [\n            startCaptureBinding\n        ], options);\n    }, [\n        startCaptureBinding\n    ]);\n    useLayoutEffect(function mount() {\n        listenForCapture();\n        return function unmount() {\n            unbindEventsRef.current();\n        };\n    }, [\n        listenForCapture\n    ]);\n}\nconst idle = {\n    type: \"IDLE\"\n};\nconst timeForLongPress = 120;\nconst forcePressThreshold = 0.15;\nfunction getWindowBindings({ cancel, getPhase }) {\n    return [\n        {\n            eventName: \"orientationchange\",\n            fn: cancel\n        },\n        {\n            eventName: \"resize\",\n            fn: cancel\n        },\n        {\n            eventName: \"contextmenu\",\n            fn: (event)=>{\n                event.preventDefault();\n            }\n        },\n        {\n            eventName: \"keydown\",\n            fn: (event)=>{\n                if (getPhase().type !== \"DRAGGING\") {\n                    cancel();\n                    return;\n                }\n                if (event.keyCode === escape) {\n                    event.preventDefault();\n                }\n                cancel();\n            }\n        },\n        {\n            eventName: supportedPageVisibilityEventName,\n            fn: cancel\n        }\n    ];\n}\nfunction getHandleBindings({ cancel, completed, getPhase }) {\n    return [\n        {\n            eventName: \"touchmove\",\n            options: {\n                capture: false\n            },\n            fn: (event)=>{\n                const phase = getPhase();\n                if (phase.type !== \"DRAGGING\") {\n                    cancel();\n                    return;\n                }\n                phase.hasMoved = true;\n                const { clientX, clientY } = event.touches[0];\n                const point = {\n                    x: clientX,\n                    y: clientY\n                };\n                event.preventDefault();\n                phase.actions.move(point);\n            }\n        },\n        {\n            eventName: \"touchend\",\n            fn: (event)=>{\n                const phase = getPhase();\n                if (phase.type !== \"DRAGGING\") {\n                    cancel();\n                    return;\n                }\n                event.preventDefault();\n                phase.actions.drop({\n                    shouldBlockNextClick: true\n                });\n                completed();\n            }\n        },\n        {\n            eventName: \"touchcancel\",\n            fn: (event)=>{\n                if (getPhase().type !== \"DRAGGING\") {\n                    cancel();\n                    return;\n                }\n                event.preventDefault();\n                cancel();\n            }\n        },\n        {\n            eventName: \"touchforcechange\",\n            fn: (event)=>{\n                const phase = getPhase();\n                !(phase.type !== \"IDLE\") ?  true ? invariant(false) : 0 : void 0;\n                const touch = event.touches[0];\n                if (!touch) {\n                    return;\n                }\n                const isForcePress = touch.force >= forcePressThreshold;\n                if (!isForcePress) {\n                    return;\n                }\n                const shouldRespect = phase.actions.shouldRespectForcePress();\n                if (phase.type === \"PENDING\") {\n                    if (shouldRespect) {\n                        cancel();\n                    }\n                    return;\n                }\n                if (shouldRespect) {\n                    if (phase.hasMoved) {\n                        event.preventDefault();\n                        return;\n                    }\n                    cancel();\n                    return;\n                }\n                event.preventDefault();\n            }\n        },\n        {\n            eventName: supportedPageVisibilityEventName,\n            fn: cancel\n        }\n    ];\n}\nfunction useTouchSensor(api) {\n    const phaseRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(idle);\n    const unbindEventsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(noop$2);\n    const getPhase = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(function getPhase() {\n        return phaseRef.current;\n    }, []);\n    const setPhase = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(function setPhase(phase) {\n        phaseRef.current = phase;\n    }, []);\n    const startCaptureBinding = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>({\n            eventName: \"touchstart\",\n            fn: function onTouchStart(event) {\n                if (event.defaultPrevented) {\n                    return;\n                }\n                const draggableId = api.findClosestDraggableId(event);\n                if (!draggableId) {\n                    return;\n                }\n                const actions = api.tryGetLock(draggableId, stop, {\n                    sourceEvent: event\n                });\n                if (!actions) {\n                    return;\n                }\n                const touch = event.touches[0];\n                const { clientX, clientY } = touch;\n                const point = {\n                    x: clientX,\n                    y: clientY\n                };\n                unbindEventsRef.current();\n                startPendingDrag(actions, point);\n            }\n        }), [\n        api\n    ]);\n    const listenForCapture = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(function listenForCapture() {\n        const options = {\n            capture: true,\n            passive: false\n        };\n        unbindEventsRef.current = bindEvents(window, [\n            startCaptureBinding\n        ], options);\n    }, [\n        startCaptureBinding\n    ]);\n    const stop = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(()=>{\n        const current = phaseRef.current;\n        if (current.type === \"IDLE\") {\n            return;\n        }\n        if (current.type === \"PENDING\") {\n            clearTimeout(current.longPressTimerId);\n        }\n        setPhase(idle);\n        unbindEventsRef.current();\n        listenForCapture();\n    }, [\n        listenForCapture,\n        setPhase\n    ]);\n    const cancel = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(()=>{\n        const phase = phaseRef.current;\n        stop();\n        if (phase.type === \"DRAGGING\") {\n            phase.actions.cancel({\n                shouldBlockNextClick: true\n            });\n        }\n        if (phase.type === \"PENDING\") {\n            phase.actions.abort();\n        }\n    }, [\n        stop\n    ]);\n    const bindCapturingEvents = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(function bindCapturingEvents() {\n        const options = {\n            capture: true,\n            passive: false\n        };\n        const args = {\n            cancel,\n            completed: stop,\n            getPhase\n        };\n        const unbindTarget = bindEvents(window, getHandleBindings(args), options);\n        const unbindWindow = bindEvents(window, getWindowBindings(args), options);\n        unbindEventsRef.current = function unbindAll() {\n            unbindTarget();\n            unbindWindow();\n        };\n    }, [\n        cancel,\n        getPhase,\n        stop\n    ]);\n    const startDragging = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(function startDragging() {\n        const phase = getPhase();\n        !(phase.type === \"PENDING\") ?  true ? invariant(false, `Cannot start dragging from phase ${phase.type}`) : 0 : void 0;\n        const actions = phase.actions.fluidLift(phase.point);\n        setPhase({\n            type: \"DRAGGING\",\n            actions,\n            hasMoved: false\n        });\n    }, [\n        getPhase,\n        setPhase\n    ]);\n    const startPendingDrag = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(function startPendingDrag(actions, point) {\n        !(getPhase().type === \"IDLE\") ?  true ? invariant(false, \"Expected to move from IDLE to PENDING drag\") : 0 : void 0;\n        const longPressTimerId = setTimeout(startDragging, timeForLongPress);\n        setPhase({\n            type: \"PENDING\",\n            point,\n            actions,\n            longPressTimerId\n        });\n        bindCapturingEvents();\n    }, [\n        bindCapturingEvents,\n        getPhase,\n        setPhase,\n        startDragging\n    ]);\n    useLayoutEffect(function mount() {\n        listenForCapture();\n        return function unmount() {\n            unbindEventsRef.current();\n            const phase = getPhase();\n            if (phase.type === \"PENDING\") {\n                clearTimeout(phase.longPressTimerId);\n                setPhase(idle);\n            }\n        };\n    }, [\n        getPhase,\n        listenForCapture,\n        setPhase\n    ]);\n    useLayoutEffect(function webkitHack() {\n        const unbind = bindEvents(window, [\n            {\n                eventName: \"touchmove\",\n                fn: ()=>{},\n                options: {\n                    capture: false,\n                    passive: false\n                }\n            }\n        ]);\n        return unbind;\n    }, []);\n}\nfunction useValidateSensorHooks(sensorHooks) {\n    useDev(()=>{\n        const previousRef = usePrevious(sensorHooks);\n        useDevSetupWarning(()=>{\n            !(previousRef.current.length === sensorHooks.length) ?  true ? invariant(false, \"Cannot change the amount of sensor hooks after mounting\") : 0 : void 0;\n        });\n    });\n}\nconst interactiveTagNames = [\n    \"input\",\n    \"button\",\n    \"textarea\",\n    \"select\",\n    \"option\",\n    \"optgroup\",\n    \"video\",\n    \"audio\"\n];\nfunction isAnInteractiveElement(parent, current) {\n    if (current == null) {\n        return false;\n    }\n    const hasAnInteractiveTag = interactiveTagNames.includes(current.tagName.toLowerCase());\n    if (hasAnInteractiveTag) {\n        return true;\n    }\n    const attribute = current.getAttribute(\"contenteditable\");\n    if (attribute === \"true\" || attribute === \"\") {\n        return true;\n    }\n    if (current === parent) {\n        return false;\n    }\n    return isAnInteractiveElement(parent, current.parentElement);\n}\nfunction isEventInInteractiveElement(draggable, event) {\n    const target = event.target;\n    if (!isHtmlElement(target)) {\n        return false;\n    }\n    return isAnInteractiveElement(draggable, target);\n}\nvar getBorderBoxCenterPosition = (el)=>(0,css_box_model__WEBPACK_IMPORTED_MODULE_4__.getRect)(el.getBoundingClientRect()).center;\nfunction isElement(el) {\n    return el instanceof getWindowFromEl(el).Element;\n}\nconst supportedMatchesName = (()=>{\n    const base = \"matches\";\n    if (typeof document === \"undefined\") {\n        return base;\n    }\n    const candidates = [\n        base,\n        \"msMatchesSelector\",\n        \"webkitMatchesSelector\"\n    ];\n    const value = candidates.find((name)=>name in Element.prototype);\n    return value || base;\n})();\nfunction closestPonyfill(el, selector) {\n    if (el == null) {\n        return null;\n    }\n    if (el[supportedMatchesName](selector)) {\n        return el;\n    }\n    return closestPonyfill(el.parentElement, selector);\n}\nfunction closest(el, selector) {\n    if (el.closest) {\n        return el.closest(selector);\n    }\n    return closestPonyfill(el, selector);\n}\nfunction getSelector(contextId) {\n    return `[${dragHandle.contextId}=\"${contextId}\"]`;\n}\nfunction findClosestDragHandleFromEvent(contextId, event) {\n    const target = event.target;\n    if (!isElement(target)) {\n         true ? warning(\"event.target must be a Element\") : 0;\n        return null;\n    }\n    const selector = getSelector(contextId);\n    const handle = closest(target, selector);\n    if (!handle) {\n        return null;\n    }\n    if (!isHtmlElement(handle)) {\n         true ? warning(\"drag handle must be a HTMLElement\") : 0;\n        return null;\n    }\n    return handle;\n}\nfunction tryGetClosestDraggableIdFromEvent(contextId, event) {\n    const handle = findClosestDragHandleFromEvent(contextId, event);\n    if (!handle) {\n        return null;\n    }\n    return handle.getAttribute(dragHandle.draggableId);\n}\nfunction findDraggable(contextId, draggableId) {\n    const selector = `[${draggable.contextId}=\"${contextId}\"]`;\n    const possible = querySelectorAll(document, selector);\n    const draggable$1 = possible.find((el)=>{\n        return el.getAttribute(draggable.id) === draggableId;\n    });\n    if (!draggable$1) {\n        return null;\n    }\n    if (!isHtmlElement(draggable$1)) {\n         true ? warning(\"Draggable element is not a HTMLElement\") : 0;\n        return null;\n    }\n    return draggable$1;\n}\nfunction preventDefault(event) {\n    event.preventDefault();\n}\nfunction isActive({ expected, phase, isLockActive, shouldWarn }) {\n    if (!isLockActive()) {\n        if (shouldWarn) {\n             true ? warning(`\n        Cannot perform action.\n        The sensor no longer has an action lock.\n\n        Tips:\n\n        - Throw away your action handlers when forceStop() is called\n        - Check actions.isActive() if you really need to\n      `) : 0;\n        }\n        return false;\n    }\n    if (expected !== phase) {\n        if (shouldWarn) {\n             true ? warning(`\n        Cannot perform action.\n        The actions you used belong to an outdated phase\n\n        Current phase: ${expected}\n        You called an action from outdated phase: ${phase}\n\n        Tips:\n\n        - Do not use preDragActions actions after calling preDragActions.lift()\n      `) : 0;\n        }\n        return false;\n    }\n    return true;\n}\nfunction canStart({ lockAPI, store, registry, draggableId }) {\n    if (lockAPI.isClaimed()) {\n        return false;\n    }\n    const entry = registry.draggable.findById(draggableId);\n    if (!entry) {\n         true ? warning(`Unable to find draggable with id: ${draggableId}`) : 0;\n        return false;\n    }\n    if (!entry.options.isEnabled) {\n        return false;\n    }\n    if (!canStartDrag(store.getState(), draggableId)) {\n        return false;\n    }\n    return true;\n}\nfunction tryStart({ lockAPI, contextId, store, registry, draggableId, forceSensorStop, sourceEvent }) {\n    const shouldStart = canStart({\n        lockAPI,\n        store,\n        registry,\n        draggableId\n    });\n    if (!shouldStart) {\n        return null;\n    }\n    const entry = registry.draggable.getById(draggableId);\n    const el = findDraggable(contextId, entry.descriptor.id);\n    if (!el) {\n         true ? warning(`Unable to find draggable element with id: ${draggableId}`) : 0;\n        return null;\n    }\n    if (sourceEvent && !entry.options.canDragInteractiveElements && isEventInInteractiveElement(el, sourceEvent)) {\n        return null;\n    }\n    const lock = lockAPI.claim(forceSensorStop || noop$2);\n    let phase = \"PRE_DRAG\";\n    function getShouldRespectForcePress() {\n        return entry.options.shouldRespectForcePress;\n    }\n    function isLockActive() {\n        return lockAPI.isActive(lock);\n    }\n    function tryDispatch(expected, getAction) {\n        if (isActive({\n            expected,\n            phase,\n            isLockActive,\n            shouldWarn: true\n        })) {\n            store.dispatch(getAction());\n        }\n    }\n    const tryDispatchWhenDragging = tryDispatch.bind(null, \"DRAGGING\");\n    function lift(args) {\n        function completed() {\n            lockAPI.release();\n            phase = \"COMPLETED\";\n        }\n        if (phase !== \"PRE_DRAG\") {\n            completed();\n             true ? invariant(false, `Cannot lift in phase ${phase}`) : 0;\n        }\n        store.dispatch(lift$1(args.liftActionArgs));\n        phase = \"DRAGGING\";\n        function finish(reason, options = {\n            shouldBlockNextClick: false\n        }) {\n            args.cleanup();\n            if (options.shouldBlockNextClick) {\n                const unbind = bindEvents(window, [\n                    {\n                        eventName: \"click\",\n                        fn: preventDefault,\n                        options: {\n                            once: true,\n                            passive: false,\n                            capture: true\n                        }\n                    }\n                ]);\n                setTimeout(unbind);\n            }\n            completed();\n            store.dispatch(drop$1({\n                reason\n            }));\n        }\n        return {\n            isActive: ()=>isActive({\n                    expected: \"DRAGGING\",\n                    phase,\n                    isLockActive,\n                    shouldWarn: false\n                }),\n            shouldRespectForcePress: getShouldRespectForcePress,\n            drop: (options)=>finish(\"DROP\", options),\n            cancel: (options)=>finish(\"CANCEL\", options),\n            ...args.actions\n        };\n    }\n    function fluidLift(clientSelection) {\n        const move$1 = (0,raf_schd__WEBPACK_IMPORTED_MODULE_6__[\"default\"])((client)=>{\n            tryDispatchWhenDragging(()=>move({\n                    client\n                }));\n        });\n        const api = lift({\n            liftActionArgs: {\n                id: draggableId,\n                clientSelection,\n                movementMode: \"FLUID\"\n            },\n            cleanup: ()=>move$1.cancel(),\n            actions: {\n                move: move$1\n            }\n        });\n        return {\n            ...api,\n            move: move$1\n        };\n    }\n    function snapLift() {\n        const actions = {\n            moveUp: ()=>tryDispatchWhenDragging(moveUp),\n            moveRight: ()=>tryDispatchWhenDragging(moveRight),\n            moveDown: ()=>tryDispatchWhenDragging(moveDown),\n            moveLeft: ()=>tryDispatchWhenDragging(moveLeft)\n        };\n        return lift({\n            liftActionArgs: {\n                id: draggableId,\n                clientSelection: getBorderBoxCenterPosition(el),\n                movementMode: \"SNAP\"\n            },\n            cleanup: noop$2,\n            actions\n        });\n    }\n    function abortPreDrag() {\n        const shouldRelease = isActive({\n            expected: \"PRE_DRAG\",\n            phase,\n            isLockActive,\n            shouldWarn: true\n        });\n        if (shouldRelease) {\n            lockAPI.release();\n        }\n    }\n    const preDrag = {\n        isActive: ()=>isActive({\n                expected: \"PRE_DRAG\",\n                phase,\n                isLockActive,\n                shouldWarn: false\n            }),\n        shouldRespectForcePress: getShouldRespectForcePress,\n        fluidLift,\n        snapLift,\n        abort: abortPreDrag\n    };\n    return preDrag;\n}\nconst defaultSensors = [\n    useMouseSensor,\n    useKeyboardSensor,\n    useTouchSensor\n];\nfunction useSensorMarshal({ contextId, store, registry, customSensors, enableDefaultSensors }) {\n    const useSensors = [\n        ...enableDefaultSensors ? defaultSensors : [],\n        ...customSensors || []\n    ];\n    const lockAPI = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>create())[0];\n    const tryAbandonLock = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(function tryAbandonLock(previous, current) {\n        if (isDragging(previous) && !isDragging(current)) {\n            lockAPI.tryAbandon();\n        }\n    }, [\n        lockAPI\n    ]);\n    useLayoutEffect(function listenToStore() {\n        let previous = store.getState();\n        const unsubscribe = store.subscribe(()=>{\n            const current = store.getState();\n            tryAbandonLock(previous, current);\n            previous = current;\n        });\n        return unsubscribe;\n    }, [\n        lockAPI,\n        store,\n        tryAbandonLock\n    ]);\n    useLayoutEffect(()=>{\n        return lockAPI.tryAbandon;\n    }, [\n        lockAPI.tryAbandon\n    ]);\n    const canGetLock = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)((draggableId)=>{\n        return canStart({\n            lockAPI,\n            registry,\n            store,\n            draggableId\n        });\n    }, [\n        lockAPI,\n        registry,\n        store\n    ]);\n    const tryGetLock = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)((draggableId, forceStop, options)=>tryStart({\n            lockAPI,\n            registry,\n            contextId,\n            store,\n            draggableId,\n            forceSensorStop: forceStop || null,\n            sourceEvent: options && options.sourceEvent ? options.sourceEvent : null\n        }), [\n        contextId,\n        lockAPI,\n        registry,\n        store\n    ]);\n    const findClosestDraggableId = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)((event)=>tryGetClosestDraggableIdFromEvent(contextId, event), [\n        contextId\n    ]);\n    const findOptionsForDraggable = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)((id)=>{\n        const entry = registry.draggable.findById(id);\n        return entry ? entry.options : null;\n    }, [\n        registry.draggable\n    ]);\n    const tryReleaseLock = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(function tryReleaseLock() {\n        if (!lockAPI.isClaimed()) {\n            return;\n        }\n        lockAPI.tryAbandon();\n        if (store.getState().phase !== \"IDLE\") {\n            store.dispatch(flush());\n        }\n    }, [\n        lockAPI,\n        store\n    ]);\n    const isLockClaimed = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(()=>lockAPI.isClaimed(), [\n        lockAPI\n    ]);\n    const api = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>({\n            canGetLock,\n            tryGetLock,\n            findClosestDraggableId,\n            findOptionsForDraggable,\n            tryReleaseLock,\n            isLockClaimed\n        }), [\n        canGetLock,\n        tryGetLock,\n        findClosestDraggableId,\n        findOptionsForDraggable,\n        tryReleaseLock,\n        isLockClaimed\n    ]);\n    useValidateSensorHooks(useSensors);\n    for(let i = 0; i < useSensors.length; i++){\n        useSensors[i](api);\n    }\n}\nconst createResponders = (props)=>({\n        onBeforeCapture: (t)=>{\n            const onBeforeCapureCallback = ()=>{\n                if (props.onBeforeCapture) {\n                    props.onBeforeCapture(t);\n                }\n            };\n            if (react__WEBPACK_IMPORTED_MODULE_0___default().version.startsWith(\"16\") || react__WEBPACK_IMPORTED_MODULE_0___default().version.startsWith(\"17\")) {\n                onBeforeCapureCallback();\n            } else {\n                (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync)(onBeforeCapureCallback);\n            }\n        },\n        onBeforeDragStart: props.onBeforeDragStart,\n        onDragStart: props.onDragStart,\n        onDragEnd: props.onDragEnd,\n        onDragUpdate: props.onDragUpdate\n    });\nconst createAutoScrollerOptions = (props)=>({\n        ...defaultAutoScrollerOptions,\n        ...props.autoScrollerOptions,\n        durationDampening: {\n            ...defaultAutoScrollerOptions.durationDampening,\n            ...props.autoScrollerOptions\n        }\n    });\nfunction getStore(lazyRef) {\n    !lazyRef.current ?  true ? invariant(false, \"Could not find store from lazy ref\") : 0 : void 0;\n    return lazyRef.current;\n}\nfunction App(props) {\n    const { contextId, setCallbacks, sensors, nonce, dragHandleUsageInstructions } = props;\n    const lazyStoreRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    useStartupValidation();\n    const lastPropsRef = usePrevious(props);\n    const getResponders = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(()=>{\n        return createResponders(lastPropsRef.current);\n    }, [\n        lastPropsRef\n    ]);\n    const getAutoScrollerOptions = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(()=>{\n        return createAutoScrollerOptions(lastPropsRef.current);\n    }, [\n        lastPropsRef\n    ]);\n    const announce = useAnnouncer(contextId);\n    const dragHandleUsageInstructionsId = useHiddenTextElement({\n        contextId,\n        text: dragHandleUsageInstructions\n    });\n    const styleMarshal = useStyleMarshal(contextId, nonce);\n    const lazyDispatch = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)((action)=>{\n        getStore(lazyStoreRef).dispatch(action);\n    }, []);\n    const marshalCallbacks = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>(0,redux__WEBPACK_IMPORTED_MODULE_7__.bindActionCreators)({\n            publishWhileDragging,\n            updateDroppableScroll,\n            updateDroppableIsEnabled,\n            updateDroppableIsCombineEnabled,\n            collectionStarting\n        }, lazyDispatch), [\n        lazyDispatch\n    ]);\n    const registry = useRegistry();\n    const dimensionMarshal = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>{\n        return createDimensionMarshal(registry, marshalCallbacks);\n    }, [\n        registry,\n        marshalCallbacks\n    ]);\n    const autoScroller = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>createAutoScroller({\n            scrollWindow,\n            scrollDroppable: dimensionMarshal.scrollDroppable,\n            getAutoScrollerOptions,\n            ...(0,redux__WEBPACK_IMPORTED_MODULE_7__.bindActionCreators)({\n                move\n            }, lazyDispatch)\n        }), [\n        dimensionMarshal.scrollDroppable,\n        lazyDispatch,\n        getAutoScrollerOptions\n    ]);\n    const focusMarshal = useFocusMarshal(contextId);\n    const store = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>createStore({\n            announce,\n            autoScroller,\n            dimensionMarshal,\n            focusMarshal,\n            getResponders,\n            styleMarshal\n        }), [\n        announce,\n        autoScroller,\n        dimensionMarshal,\n        focusMarshal,\n        getResponders,\n        styleMarshal\n    ]);\n    if (true) {\n        if (lazyStoreRef.current && lazyStoreRef.current !== store) {\n             true ? warning(\"unexpected store change\") : 0;\n        }\n    }\n    lazyStoreRef.current = store;\n    const tryResetStore = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(()=>{\n        const current = getStore(lazyStoreRef);\n        const state = current.getState();\n        if (state.phase !== \"IDLE\") {\n            current.dispatch(flush());\n        }\n    }, []);\n    const isDragging = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(()=>{\n        const state = getStore(lazyStoreRef).getState();\n        if (state.phase === \"DROP_ANIMATING\") {\n            return true;\n        }\n        if (state.phase === \"IDLE\") {\n            return false;\n        }\n        return state.isDragging;\n    }, []);\n    const appCallbacks = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>({\n            isDragging,\n            tryAbort: tryResetStore\n        }), [\n        isDragging,\n        tryResetStore\n    ]);\n    setCallbacks(appCallbacks);\n    const getCanLift = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)((id)=>canStartDrag(getStore(lazyStoreRef).getState(), id), []);\n    const getIsMovementAllowed = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(()=>isMovementAllowed(getStore(lazyStoreRef).getState()), []);\n    const appContext = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>({\n            marshal: dimensionMarshal,\n            focus: focusMarshal,\n            contextId,\n            canLift: getCanLift,\n            isMovementAllowed: getIsMovementAllowed,\n            dragHandleUsageInstructionsId,\n            registry\n        }), [\n        contextId,\n        dimensionMarshal,\n        dragHandleUsageInstructionsId,\n        focusMarshal,\n        getCanLift,\n        getIsMovementAllowed,\n        registry\n    ]);\n    useSensorMarshal({\n        contextId,\n        store,\n        registry,\n        customSensors: sensors || null,\n        enableDefaultSensors: props.enableDefaultSensors !== false\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        return tryResetStore;\n    }, [\n        tryResetStore\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(AppContext.Provider, {\n        value: appContext\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(react_redux__WEBPACK_IMPORTED_MODULE_2__.Provider, {\n        context: StoreContext,\n        store: store\n    }, props.children));\n}\nlet count = 0;\nfunction resetDeprecatedUniqueContextId() {\n    count = 0;\n}\nfunction useDeprecatedUniqueContextId() {\n    return (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>`${count++}`, []);\n}\nfunction useUniqueContextId() {\n    return react__WEBPACK_IMPORTED_MODULE_0___default().useId();\n}\nvar useUniqueContextId$1 = \"useId\" in (react__WEBPACK_IMPORTED_MODULE_0___default()) ? useUniqueContextId : useDeprecatedUniqueContextId;\nfunction resetServerContext() {\n    if (\"useId\" in (react__WEBPACK_IMPORTED_MODULE_0___default())) {\n         true ? warning(`It is not necessary to call resetServerContext when using React 18+`) : 0;\n        return;\n    }\n    resetDeprecatedUniqueContextId();\n    resetDeprecatedUniqueId();\n}\nfunction DragDropContext(props) {\n    const contextId = useUniqueContextId$1();\n    const dragHandleUsageInstructions = props.dragHandleUsageInstructions || preset$1.dragHandleUsageInstructions;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(ErrorBoundary, null, (setCallbacks)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(App, {\n            nonce: props.nonce,\n            contextId: contextId,\n            setCallbacks: setCallbacks,\n            dragHandleUsageInstructions: dragHandleUsageInstructions,\n            enableDefaultSensors: props.enableDefaultSensors,\n            sensors: props.sensors,\n            onBeforeCapture: props.onBeforeCapture,\n            onBeforeDragStart: props.onBeforeDragStart,\n            onDragStart: props.onDragStart,\n            onDragUpdate: props.onDragUpdate,\n            onDragEnd: props.onDragEnd,\n            autoScrollerOptions: props.autoScrollerOptions\n        }, props.children));\n}\nconst zIndexOptions = {\n    dragging: 5000,\n    dropAnimating: 4500\n};\nconst getDraggingTransition = (shouldAnimateDragMovement, dropping)=>{\n    if (dropping) {\n        return transitions.drop(dropping.duration);\n    }\n    if (shouldAnimateDragMovement) {\n        return transitions.snap;\n    }\n    return transitions.fluid;\n};\nconst getDraggingOpacity = (isCombining, isDropAnimating)=>{\n    if (!isCombining) {\n        return undefined;\n    }\n    return isDropAnimating ? combine.opacity.drop : combine.opacity.combining;\n};\nconst getShouldDraggingAnimate = (dragging)=>{\n    if (dragging.forceShouldAnimate != null) {\n        return dragging.forceShouldAnimate;\n    }\n    return dragging.mode === \"SNAP\";\n};\nfunction getDraggingStyle(dragging) {\n    const dimension = dragging.dimension;\n    const box = dimension.client;\n    const { offset, combineWith, dropping } = dragging;\n    const isCombining = Boolean(combineWith);\n    const shouldAnimate = getShouldDraggingAnimate(dragging);\n    const isDropAnimating = Boolean(dropping);\n    const transform = isDropAnimating ? transforms.drop(offset, isCombining) : transforms.moveTo(offset);\n    const style = {\n        position: \"fixed\",\n        top: box.marginBox.top,\n        left: box.marginBox.left,\n        boxSizing: \"border-box\",\n        width: box.borderBox.width,\n        height: box.borderBox.height,\n        transition: getDraggingTransition(shouldAnimate, dropping),\n        transform,\n        opacity: getDraggingOpacity(isCombining, isDropAnimating),\n        zIndex: isDropAnimating ? zIndexOptions.dropAnimating : zIndexOptions.dragging,\n        pointerEvents: \"none\"\n    };\n    return style;\n}\nfunction getSecondaryStyle(secondary) {\n    return {\n        transform: transforms.moveTo(secondary.offset),\n        transition: secondary.shouldAnimateDisplacement ? undefined : \"none\"\n    };\n}\nfunction getStyle$1(mapped) {\n    return mapped.type === \"DRAGGING\" ? getDraggingStyle(mapped) : getSecondaryStyle(mapped);\n}\nfunction getDimension$1(descriptor, el, windowScroll = origin) {\n    const computedStyles = window.getComputedStyle(el);\n    const borderBox = el.getBoundingClientRect();\n    const client = (0,css_box_model__WEBPACK_IMPORTED_MODULE_4__.calculateBox)(borderBox, computedStyles);\n    const page = (0,css_box_model__WEBPACK_IMPORTED_MODULE_4__.withScroll)(client, windowScroll);\n    const placeholder = {\n        client,\n        tagName: el.tagName.toLowerCase(),\n        display: computedStyles.display\n    };\n    const displaceBy = {\n        x: client.marginBox.width,\n        y: client.marginBox.height\n    };\n    const dimension = {\n        descriptor,\n        placeholder,\n        displaceBy,\n        client,\n        page\n    };\n    return dimension;\n}\nfunction useDraggablePublisher(args) {\n    const uniqueId = useUniqueId$1(\"draggable\");\n    const { descriptor, registry, getDraggableRef, canDragInteractiveElements, shouldRespectForcePress, isEnabled } = args;\n    const options = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>({\n            canDragInteractiveElements,\n            shouldRespectForcePress,\n            isEnabled\n        }), [\n        canDragInteractiveElements,\n        isEnabled,\n        shouldRespectForcePress\n    ]);\n    const getDimension = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)((windowScroll)=>{\n        const el = getDraggableRef();\n        !el ?  true ? invariant(false, \"Cannot get dimension when no ref is set\") : 0 : void 0;\n        return getDimension$1(descriptor, el, windowScroll);\n    }, [\n        descriptor,\n        getDraggableRef\n    ]);\n    const entry = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>({\n            uniqueId,\n            descriptor,\n            options,\n            getDimension\n        }), [\n        descriptor,\n        getDimension,\n        options,\n        uniqueId\n    ]);\n    const publishedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(entry);\n    const isFirstPublishRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(true);\n    useLayoutEffect(()=>{\n        registry.draggable.register(publishedRef.current);\n        return ()=>registry.draggable.unregister(publishedRef.current);\n    }, [\n        registry.draggable\n    ]);\n    useLayoutEffect(()=>{\n        if (isFirstPublishRef.current) {\n            isFirstPublishRef.current = false;\n            return;\n        }\n        const last = publishedRef.current;\n        publishedRef.current = entry;\n        registry.draggable.update(entry, last);\n    }, [\n        entry,\n        registry.draggable\n    ]);\n}\nvar DroppableContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createContext(null);\nfunction checkIsValidInnerRef(el) {\n    !(el && isHtmlElement(el)) ?  true ? invariant(false, `\n    provided.innerRef has not been provided with a HTMLElement.\n\n    You can find a guide on using the innerRef callback functions at:\n    https://github.com/hello-pangea/dnd/blob/main/docs/guides/using-inner-ref.md\n  `) : 0 : void 0;\n}\nfunction useValidation$1(props, contextId, getRef) {\n    useDevSetupWarning(()=>{\n        function prefix(id) {\n            return `Draggable[id: ${id}]: `;\n        }\n        const id = props.draggableId;\n        !id ?  true ? invariant(false, \"Draggable requires a draggableId\") : 0 : void 0;\n        !(typeof id === \"string\") ?  true ? invariant(false, `Draggable requires a [string] draggableId.\n      Provided: [type: ${typeof id}] (value: ${id})`) : 0 : void 0;\n        !Number.isInteger(props.index) ?  true ? invariant(false, `${prefix(id)} requires an integer index prop`) : 0 : void 0;\n        if (props.mapped.type === \"DRAGGING\") {\n            return;\n        }\n        checkIsValidInnerRef(getRef());\n        if (props.isEnabled) {\n            !findDragHandle(contextId, id) ?  true ? invariant(false, `${prefix(id)} Unable to find drag handle`) : 0 : void 0;\n        }\n    });\n}\nfunction useClonePropValidation(isClone) {\n    useDev(()=>{\n        const initialRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(isClone);\n        useDevSetupWarning(()=>{\n            !(isClone === initialRef.current) ?  true ? invariant(false, \"Draggable isClone prop value changed during component life\") : 0 : void 0;\n        }, [\n            isClone\n        ]);\n    });\n}\nfunction useRequiredContext(Context) {\n    const result = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(Context);\n    !result ?  true ? invariant(false, \"Could not find required context\") : 0 : void 0;\n    return result;\n}\nfunction preventHtml5Dnd(event) {\n    event.preventDefault();\n}\nconst Draggable = (props)=>{\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const setRef = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)((el = null)=>{\n        ref.current = el;\n    }, []);\n    const getRef = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(()=>ref.current, []);\n    const { contextId, dragHandleUsageInstructionsId, registry } = useRequiredContext(AppContext);\n    const { type, droppableId } = useRequiredContext(DroppableContext);\n    const descriptor = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>({\n            id: props.draggableId,\n            index: props.index,\n            type,\n            droppableId\n        }), [\n        props.draggableId,\n        props.index,\n        type,\n        droppableId\n    ]);\n    const { children, draggableId, isEnabled, shouldRespectForcePress, canDragInteractiveElements, isClone, mapped, dropAnimationFinished: dropAnimationFinishedAction } = props;\n    useValidation$1(props, contextId, getRef);\n    useClonePropValidation(isClone);\n    if (!isClone) {\n        const forPublisher = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>({\n                descriptor,\n                registry,\n                getDraggableRef: getRef,\n                canDragInteractiveElements,\n                shouldRespectForcePress,\n                isEnabled\n            }), [\n            descriptor,\n            registry,\n            getRef,\n            canDragInteractiveElements,\n            shouldRespectForcePress,\n            isEnabled\n        ]);\n        useDraggablePublisher(forPublisher);\n    }\n    const dragHandleProps = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>isEnabled ? {\n            tabIndex: 0,\n            role: \"button\",\n            \"aria-describedby\": dragHandleUsageInstructionsId,\n            \"data-rfd-drag-handle-draggable-id\": draggableId,\n            \"data-rfd-drag-handle-context-id\": contextId,\n            draggable: false,\n            onDragStart: preventHtml5Dnd\n        } : null, [\n        contextId,\n        dragHandleUsageInstructionsId,\n        draggableId,\n        isEnabled\n    ]);\n    const onMoveEnd = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)((event)=>{\n        if (mapped.type !== \"DRAGGING\") {\n            return;\n        }\n        if (!mapped.dropping) {\n            return;\n        }\n        if (event.propertyName !== \"transform\") {\n            return;\n        }\n        if (react__WEBPACK_IMPORTED_MODULE_0___default().version.startsWith(\"16\") || react__WEBPACK_IMPORTED_MODULE_0___default().version.startsWith(\"17\")) {\n            dropAnimationFinishedAction();\n        } else {\n            (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync)(dropAnimationFinishedAction);\n        }\n    }, [\n        dropAnimationFinishedAction,\n        mapped\n    ]);\n    const provided = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>{\n        const style = getStyle$1(mapped);\n        const onTransitionEnd = mapped.type === \"DRAGGING\" && mapped.dropping ? onMoveEnd : undefined;\n        const result = {\n            innerRef: setRef,\n            draggableProps: {\n                \"data-rfd-draggable-context-id\": contextId,\n                \"data-rfd-draggable-id\": draggableId,\n                style,\n                onTransitionEnd\n            },\n            dragHandleProps\n        };\n        return result;\n    }, [\n        contextId,\n        dragHandleProps,\n        draggableId,\n        mapped,\n        onMoveEnd,\n        setRef\n    ]);\n    const rubric = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>({\n            draggableId: descriptor.id,\n            type: descriptor.type,\n            source: {\n                index: descriptor.index,\n                droppableId: descriptor.droppableId\n            }\n        }), [\n        descriptor.droppableId,\n        descriptor.id,\n        descriptor.index,\n        descriptor.type\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement((react__WEBPACK_IMPORTED_MODULE_0___default().Fragment), null, children(provided, mapped.snapshot, rubric));\n};\nvar Draggable$1 = Draggable;\nvar isStrictEqual = (a, b)=>a === b;\nvar whatIsDraggedOverFromResult = (result)=>{\n    const { combine, destination } = result;\n    if (destination) {\n        return destination.droppableId;\n    }\n    if (combine) {\n        return combine.droppableId;\n    }\n    return null;\n};\nconst getCombineWithFromResult = (result)=>{\n    return result.combine ? result.combine.draggableId : null;\n};\nconst getCombineWithFromImpact = (impact)=>{\n    return impact.at && impact.at.type === \"COMBINE\" ? impact.at.combine.draggableId : null;\n};\nfunction getDraggableSelector() {\n    const memoizedOffset = (0,memoize_one__WEBPACK_IMPORTED_MODULE_5__[\"default\"])((x, y)=>({\n            x,\n            y\n        }));\n    const getMemoizedSnapshot = (0,memoize_one__WEBPACK_IMPORTED_MODULE_5__[\"default\"])((mode, isClone, draggingOver = null, combineWith = null, dropping = null)=>({\n            isDragging: true,\n            isClone,\n            isDropAnimating: Boolean(dropping),\n            dropAnimation: dropping,\n            mode,\n            draggingOver,\n            combineWith,\n            combineTargetFor: null\n        }));\n    const getMemoizedProps = (0,memoize_one__WEBPACK_IMPORTED_MODULE_5__[\"default\"])((offset, mode, dimension, isClone, draggingOver = null, combineWith = null, forceShouldAnimate = null)=>({\n            mapped: {\n                type: \"DRAGGING\",\n                dropping: null,\n                draggingOver,\n                combineWith,\n                mode,\n                offset,\n                dimension,\n                forceShouldAnimate,\n                snapshot: getMemoizedSnapshot(mode, isClone, draggingOver, combineWith, null)\n            }\n        }));\n    const selector = (state, ownProps)=>{\n        if (isDragging(state)) {\n            if (state.critical.draggable.id !== ownProps.draggableId) {\n                return null;\n            }\n            const offset = state.current.client.offset;\n            const dimension = state.dimensions.draggables[ownProps.draggableId];\n            const draggingOver = whatIsDraggedOver(state.impact);\n            const combineWith = getCombineWithFromImpact(state.impact);\n            const forceShouldAnimate = state.forceShouldAnimate;\n            return getMemoizedProps(memoizedOffset(offset.x, offset.y), state.movementMode, dimension, ownProps.isClone, draggingOver, combineWith, forceShouldAnimate);\n        }\n        if (state.phase === \"DROP_ANIMATING\") {\n            const completed = state.completed;\n            if (completed.result.draggableId !== ownProps.draggableId) {\n                return null;\n            }\n            const isClone = ownProps.isClone;\n            const dimension = state.dimensions.draggables[ownProps.draggableId];\n            const result = completed.result;\n            const mode = result.mode;\n            const draggingOver = whatIsDraggedOverFromResult(result);\n            const combineWith = getCombineWithFromResult(result);\n            const duration = state.dropDuration;\n            const dropping = {\n                duration,\n                curve: curves.drop,\n                moveTo: state.newHomeClientOffset,\n                opacity: combineWith ? combine.opacity.drop : null,\n                scale: combineWith ? combine.scale.drop : null\n            };\n            return {\n                mapped: {\n                    type: \"DRAGGING\",\n                    offset: state.newHomeClientOffset,\n                    dimension,\n                    dropping,\n                    draggingOver,\n                    combineWith,\n                    mode,\n                    forceShouldAnimate: null,\n                    snapshot: getMemoizedSnapshot(mode, isClone, draggingOver, combineWith, dropping)\n                }\n            };\n        }\n        return null;\n    };\n    return selector;\n}\nfunction getSecondarySnapshot(combineTargetFor = null) {\n    return {\n        isDragging: false,\n        isDropAnimating: false,\n        isClone: false,\n        dropAnimation: null,\n        mode: null,\n        draggingOver: null,\n        combineTargetFor,\n        combineWith: null\n    };\n}\nconst atRest = {\n    mapped: {\n        type: \"SECONDARY\",\n        offset: origin,\n        combineTargetFor: null,\n        shouldAnimateDisplacement: true,\n        snapshot: getSecondarySnapshot(null)\n    }\n};\nfunction getSecondarySelector() {\n    const memoizedOffset = (0,memoize_one__WEBPACK_IMPORTED_MODULE_5__[\"default\"])((x, y)=>({\n            x,\n            y\n        }));\n    const getMemoizedSnapshot = (0,memoize_one__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(getSecondarySnapshot);\n    const getMemoizedProps = (0,memoize_one__WEBPACK_IMPORTED_MODULE_5__[\"default\"])((offset, combineTargetFor = null, shouldAnimateDisplacement)=>({\n            mapped: {\n                type: \"SECONDARY\",\n                offset,\n                combineTargetFor,\n                shouldAnimateDisplacement,\n                snapshot: getMemoizedSnapshot(combineTargetFor)\n            }\n        }));\n    const getFallback = (combineTargetFor)=>{\n        return combineTargetFor ? getMemoizedProps(origin, combineTargetFor, true) : null;\n    };\n    const getProps = (ownId, draggingId, impact, afterCritical)=>{\n        const visualDisplacement = impact.displaced.visible[ownId];\n        const isAfterCriticalInVirtualList = Boolean(afterCritical.inVirtualList && afterCritical.effected[ownId]);\n        const combine = tryGetCombine(impact);\n        const combineTargetFor = combine && combine.draggableId === ownId ? draggingId : null;\n        if (!visualDisplacement) {\n            if (!isAfterCriticalInVirtualList) {\n                return getFallback(combineTargetFor);\n            }\n            if (impact.displaced.invisible[ownId]) {\n                return null;\n            }\n            const change = negate(afterCritical.displacedBy.point);\n            const offset = memoizedOffset(change.x, change.y);\n            return getMemoizedProps(offset, combineTargetFor, true);\n        }\n        if (isAfterCriticalInVirtualList) {\n            return getFallback(combineTargetFor);\n        }\n        const displaceBy = impact.displacedBy.point;\n        const offset = memoizedOffset(displaceBy.x, displaceBy.y);\n        return getMemoizedProps(offset, combineTargetFor, visualDisplacement.shouldAnimate);\n    };\n    const selector = (state, ownProps)=>{\n        if (isDragging(state)) {\n            if (state.critical.draggable.id === ownProps.draggableId) {\n                return null;\n            }\n            return getProps(ownProps.draggableId, state.critical.draggable.id, state.impact, state.afterCritical);\n        }\n        if (state.phase === \"DROP_ANIMATING\") {\n            const completed = state.completed;\n            if (completed.result.draggableId === ownProps.draggableId) {\n                return null;\n            }\n            return getProps(ownProps.draggableId, completed.result.draggableId, completed.impact, completed.afterCritical);\n        }\n        return null;\n    };\n    return selector;\n}\nconst makeMapStateToProps$1 = ()=>{\n    const draggingSelector = getDraggableSelector();\n    const secondarySelector = getSecondarySelector();\n    const selector = (state, ownProps)=>draggingSelector(state, ownProps) || secondarySelector(state, ownProps) || atRest;\n    return selector;\n};\nconst mapDispatchToProps$1 = {\n    dropAnimationFinished: dropAnimationFinished\n};\nconst ConnectedDraggable = (0,react_redux__WEBPACK_IMPORTED_MODULE_2__.connect)(makeMapStateToProps$1, mapDispatchToProps$1, null, {\n    context: StoreContext,\n    areStatePropsEqual: isStrictEqual\n})(Draggable$1);\nvar ConnectedDraggable$1 = ConnectedDraggable;\nfunction PrivateDraggable(props) {\n    const droppableContext = useRequiredContext(DroppableContext);\n    const isUsingCloneFor = droppableContext.isUsingCloneFor;\n    if (isUsingCloneFor === props.draggableId && !props.isClone) {\n        return null;\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(ConnectedDraggable$1, props);\n}\nfunction PublicDraggable(props) {\n    const isEnabled = typeof props.isDragDisabled === \"boolean\" ? !props.isDragDisabled : true;\n    const canDragInteractiveElements = Boolean(props.disableInteractiveElementBlocking);\n    const shouldRespectForcePress = Boolean(props.shouldRespectForcePress);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(PrivateDraggable, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_3__[\"default\"])({}, props, {\n        isClone: false,\n        isEnabled: isEnabled,\n        canDragInteractiveElements: canDragInteractiveElements,\n        shouldRespectForcePress: shouldRespectForcePress\n    }));\n}\nconst isEqual = (base)=>(value)=>base === value;\nconst isScroll = isEqual(\"scroll\");\nconst isAuto = isEqual(\"auto\");\nconst isVisible = isEqual(\"visible\");\nconst isEither = (overflow, fn)=>fn(overflow.overflowX) || fn(overflow.overflowY);\nconst isBoth = (overflow, fn)=>fn(overflow.overflowX) && fn(overflow.overflowY);\nconst isElementScrollable = (el)=>{\n    const style = window.getComputedStyle(el);\n    const overflow = {\n        overflowX: style.overflowX,\n        overflowY: style.overflowY\n    };\n    return isEither(overflow, isScroll) || isEither(overflow, isAuto);\n};\nconst isBodyScrollable = ()=>{\n    if (false) {}\n    const body = getBodyElement();\n    const html = document.documentElement;\n    !html ?  true ? invariant(false) : 0 : void 0;\n    if (!isElementScrollable(body)) {\n        return false;\n    }\n    const htmlStyle = window.getComputedStyle(html);\n    const htmlOverflow = {\n        overflowX: htmlStyle.overflowX,\n        overflowY: htmlStyle.overflowY\n    };\n    if (isBoth(htmlOverflow, isVisible)) {\n        return false;\n    }\n     true ? warning(`\n    We have detected that your <body> element might be a scroll container.\n    We have found no reliable way of detecting whether the <body> element is a scroll container.\n    Under most circumstances a <body> scroll bar will be on the <html> element (document.documentElement)\n\n    Because we cannot determine if the <body> is a scroll container, and generally it is not one,\n    we will be treating the <body> as *not* a scroll container\n\n    More information: https://github.com/hello-pangea/dnd/blob/main/docs/guides/how-we-detect-scroll-containers.md\n  `) : 0;\n    return false;\n};\nconst getClosestScrollable = (el)=>{\n    if (el == null) {\n        return null;\n    }\n    if (el === document.body) {\n        return isBodyScrollable() ? el : null;\n    }\n    if (el === document.documentElement) {\n        return null;\n    }\n    if (!isElementScrollable(el)) {\n        return getClosestScrollable(el.parentElement);\n    }\n    return el;\n};\nvar checkForNestedScrollContainers = (scrollable)=>{\n    if (!scrollable) {\n        return;\n    }\n    const anotherScrollParent = getClosestScrollable(scrollable.parentElement);\n    if (!anotherScrollParent) {\n        return;\n    }\n     true ? warning(`\n    Droppable: unsupported nested scroll container detected.\n    A Droppable can only have one scroll parent (which can be itself)\n    Nested scroll containers are currently not supported.\n\n    We hope to support nested scroll containers soon: https://github.com/atlassian/react-beautiful-dnd/issues/131\n  `) : 0;\n};\nvar getScroll = (el)=>({\n        x: el.scrollLeft,\n        y: el.scrollTop\n    });\nconst getIsFixed = (el)=>{\n    if (!el) {\n        return false;\n    }\n    const style = window.getComputedStyle(el);\n    if (style.position === \"fixed\") {\n        return true;\n    }\n    return getIsFixed(el.parentElement);\n};\nvar getEnv = (start)=>{\n    const closestScrollable = getClosestScrollable(start);\n    const isFixedOnPage = getIsFixed(start);\n    return {\n        closestScrollable,\n        isFixedOnPage\n    };\n};\nvar getDroppableDimension = ({ descriptor, isEnabled, isCombineEnabled, isFixedOnPage, direction, client, page, closest })=>{\n    const frame = (()=>{\n        if (!closest) {\n            return null;\n        }\n        const { scrollSize, client: frameClient } = closest;\n        const maxScroll = getMaxScroll({\n            scrollHeight: scrollSize.scrollHeight,\n            scrollWidth: scrollSize.scrollWidth,\n            height: frameClient.paddingBox.height,\n            width: frameClient.paddingBox.width\n        });\n        return {\n            pageMarginBox: closest.page.marginBox,\n            frameClient,\n            scrollSize,\n            shouldClipSubject: closest.shouldClipSubject,\n            scroll: {\n                initial: closest.scroll,\n                current: closest.scroll,\n                max: maxScroll,\n                diff: {\n                    value: origin,\n                    displacement: origin\n                }\n            }\n        };\n    })();\n    const axis = direction === \"vertical\" ? vertical : horizontal;\n    const subject = getSubject({\n        page,\n        withPlaceholder: null,\n        axis,\n        frame\n    });\n    const dimension = {\n        descriptor,\n        isCombineEnabled,\n        isFixedOnPage,\n        axis,\n        isEnabled,\n        client,\n        page,\n        frame,\n        subject\n    };\n    return dimension;\n};\nconst getClient = (targetRef, closestScrollable)=>{\n    const base = (0,css_box_model__WEBPACK_IMPORTED_MODULE_4__.getBox)(targetRef);\n    if (!closestScrollable) {\n        return base;\n    }\n    if (targetRef !== closestScrollable) {\n        return base;\n    }\n    const top = base.paddingBox.top - closestScrollable.scrollTop;\n    const left = base.paddingBox.left - closestScrollable.scrollLeft;\n    const bottom = top + closestScrollable.scrollHeight;\n    const right = left + closestScrollable.scrollWidth;\n    const paddingBox = {\n        top,\n        right,\n        bottom,\n        left\n    };\n    const borderBox = (0,css_box_model__WEBPACK_IMPORTED_MODULE_4__.expand)(paddingBox, base.border);\n    const client = (0,css_box_model__WEBPACK_IMPORTED_MODULE_4__.createBox)({\n        borderBox,\n        margin: base.margin,\n        border: base.border,\n        padding: base.padding\n    });\n    return client;\n};\nvar getDimension = ({ ref, descriptor, env, windowScroll, direction, isDropDisabled, isCombineEnabled, shouldClipSubject })=>{\n    const closestScrollable = env.closestScrollable;\n    const client = getClient(ref, closestScrollable);\n    const page = (0,css_box_model__WEBPACK_IMPORTED_MODULE_4__.withScroll)(client, windowScroll);\n    const closest = (()=>{\n        if (!closestScrollable) {\n            return null;\n        }\n        const frameClient = (0,css_box_model__WEBPACK_IMPORTED_MODULE_4__.getBox)(closestScrollable);\n        const scrollSize = {\n            scrollHeight: closestScrollable.scrollHeight,\n            scrollWidth: closestScrollable.scrollWidth\n        };\n        return {\n            client: frameClient,\n            page: (0,css_box_model__WEBPACK_IMPORTED_MODULE_4__.withScroll)(frameClient, windowScroll),\n            scroll: getScroll(closestScrollable),\n            scrollSize,\n            shouldClipSubject\n        };\n    })();\n    const dimension = getDroppableDimension({\n        descriptor,\n        isEnabled: !isDropDisabled,\n        isCombineEnabled,\n        isFixedOnPage: env.isFixedOnPage,\n        direction,\n        client,\n        page,\n        closest\n    });\n    return dimension;\n};\nconst immediate = {\n    passive: false\n};\nconst delayed = {\n    passive: true\n};\nvar getListenerOptions = (options)=>options.shouldPublishImmediately ? immediate : delayed;\nconst getClosestScrollableFromDrag = (dragging)=>dragging && dragging.env.closestScrollable || null;\nfunction useDroppablePublisher(args) {\n    const whileDraggingRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const appContext = useRequiredContext(AppContext);\n    const uniqueId = useUniqueId$1(\"droppable\");\n    const { registry, marshal } = appContext;\n    const previousRef = usePrevious(args);\n    const descriptor = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>({\n            id: args.droppableId,\n            type: args.type,\n            mode: args.mode\n        }), [\n        args.droppableId,\n        args.mode,\n        args.type\n    ]);\n    const publishedDescriptorRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(descriptor);\n    const memoizedUpdateScroll = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>(0,memoize_one__WEBPACK_IMPORTED_MODULE_5__[\"default\"])((x, y)=>{\n            !whileDraggingRef.current ?  true ? invariant(false, \"Can only update scroll when dragging\") : 0 : void 0;\n            const scroll = {\n                x,\n                y\n            };\n            marshal.updateDroppableScroll(descriptor.id, scroll);\n        }), [\n        descriptor.id,\n        marshal\n    ]);\n    const getClosestScroll = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(()=>{\n        const dragging = whileDraggingRef.current;\n        if (!dragging || !dragging.env.closestScrollable) {\n            return origin;\n        }\n        return getScroll(dragging.env.closestScrollable);\n    }, []);\n    const updateScroll = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(()=>{\n        const scroll = getClosestScroll();\n        memoizedUpdateScroll(scroll.x, scroll.y);\n    }, [\n        getClosestScroll,\n        memoizedUpdateScroll\n    ]);\n    const scheduleScrollUpdate = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>(0,raf_schd__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(updateScroll), [\n        updateScroll\n    ]);\n    const onClosestScroll = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(()=>{\n        const dragging = whileDraggingRef.current;\n        const closest = getClosestScrollableFromDrag(dragging);\n        !(dragging && closest) ?  true ? invariant(false, \"Could not find scroll options while scrolling\") : 0 : void 0;\n        const options = dragging.scrollOptions;\n        if (options.shouldPublishImmediately) {\n            updateScroll();\n            return;\n        }\n        scheduleScrollUpdate();\n    }, [\n        scheduleScrollUpdate,\n        updateScroll\n    ]);\n    const getDimensionAndWatchScroll = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)((windowScroll, options)=>{\n        !!whileDraggingRef.current ?  true ? invariant(false, \"Cannot collect a droppable while a drag is occurring\") : 0 : void 0;\n        const previous = previousRef.current;\n        const ref = previous.getDroppableRef();\n        !ref ?  true ? invariant(false, \"Cannot collect without a droppable ref\") : 0 : void 0;\n        const env = getEnv(ref);\n        const dragging = {\n            ref,\n            descriptor,\n            env,\n            scrollOptions: options\n        };\n        whileDraggingRef.current = dragging;\n        const dimension = getDimension({\n            ref,\n            descriptor,\n            env,\n            windowScroll,\n            direction: previous.direction,\n            isDropDisabled: previous.isDropDisabled,\n            isCombineEnabled: previous.isCombineEnabled,\n            shouldClipSubject: !previous.ignoreContainerClipping\n        });\n        const scrollable = env.closestScrollable;\n        if (scrollable) {\n            scrollable.setAttribute(scrollContainer.contextId, appContext.contextId);\n            scrollable.addEventListener(\"scroll\", onClosestScroll, getListenerOptions(dragging.scrollOptions));\n            if (true) {\n                checkForNestedScrollContainers(scrollable);\n            }\n        }\n        return dimension;\n    }, [\n        appContext.contextId,\n        descriptor,\n        onClosestScroll,\n        previousRef\n    ]);\n    const getScrollWhileDragging = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(()=>{\n        const dragging = whileDraggingRef.current;\n        const closest = getClosestScrollableFromDrag(dragging);\n        !(dragging && closest) ?  true ? invariant(false, \"Can only recollect Droppable client for Droppables that have a scroll container\") : 0 : void 0;\n        return getScroll(closest);\n    }, []);\n    const dragStopped = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(()=>{\n        const dragging = whileDraggingRef.current;\n        !dragging ?  true ? invariant(false, \"Cannot stop drag when no active drag\") : 0 : void 0;\n        const closest = getClosestScrollableFromDrag(dragging);\n        whileDraggingRef.current = null;\n        if (!closest) {\n            return;\n        }\n        scheduleScrollUpdate.cancel();\n        closest.removeAttribute(scrollContainer.contextId);\n        closest.removeEventListener(\"scroll\", onClosestScroll, getListenerOptions(dragging.scrollOptions));\n    }, [\n        onClosestScroll,\n        scheduleScrollUpdate\n    ]);\n    const scroll = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)((change)=>{\n        const dragging = whileDraggingRef.current;\n        !dragging ?  true ? invariant(false, \"Cannot scroll when there is no drag\") : 0 : void 0;\n        const closest = getClosestScrollableFromDrag(dragging);\n        !closest ?  true ? invariant(false, \"Cannot scroll a droppable with no closest scrollable\") : 0 : void 0;\n        closest.scrollTop += change.y;\n        closest.scrollLeft += change.x;\n    }, []);\n    const callbacks = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>{\n        return {\n            getDimensionAndWatchScroll,\n            getScrollWhileDragging,\n            dragStopped,\n            scroll\n        };\n    }, [\n        dragStopped,\n        getDimensionAndWatchScroll,\n        getScrollWhileDragging,\n        scroll\n    ]);\n    const entry = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>({\n            uniqueId,\n            descriptor,\n            callbacks\n        }), [\n        callbacks,\n        descriptor,\n        uniqueId\n    ]);\n    useLayoutEffect(()=>{\n        publishedDescriptorRef.current = entry.descriptor;\n        registry.droppable.register(entry);\n        return ()=>{\n            if (whileDraggingRef.current) {\n                 true ? warning(\"Unsupported: changing the droppableId or type of a Droppable during a drag\") : 0;\n                dragStopped();\n            }\n            registry.droppable.unregister(entry);\n        };\n    }, [\n        callbacks,\n        descriptor,\n        dragStopped,\n        entry,\n        marshal,\n        registry.droppable\n    ]);\n    useLayoutEffect(()=>{\n        if (!whileDraggingRef.current) {\n            return;\n        }\n        marshal.updateDroppableIsEnabled(publishedDescriptorRef.current.id, !args.isDropDisabled);\n    }, [\n        args.isDropDisabled,\n        marshal\n    ]);\n    useLayoutEffect(()=>{\n        if (!whileDraggingRef.current) {\n            return;\n        }\n        marshal.updateDroppableIsCombineEnabled(publishedDescriptorRef.current.id, args.isCombineEnabled);\n    }, [\n        args.isCombineEnabled,\n        marshal\n    ]);\n}\nfunction noop() {}\nconst empty = {\n    width: 0,\n    height: 0,\n    margin: noSpacing\n};\nconst getSize = ({ isAnimatingOpenOnMount, placeholder, animate })=>{\n    if (isAnimatingOpenOnMount) {\n        return empty;\n    }\n    if (animate === \"close\") {\n        return empty;\n    }\n    return {\n        height: placeholder.client.borderBox.height,\n        width: placeholder.client.borderBox.width,\n        margin: placeholder.client.margin\n    };\n};\nconst getStyle = ({ isAnimatingOpenOnMount, placeholder, animate })=>{\n    const size = getSize({\n        isAnimatingOpenOnMount,\n        placeholder,\n        animate\n    });\n    return {\n        display: placeholder.display,\n        boxSizing: \"border-box\",\n        width: size.width,\n        height: size.height,\n        marginTop: size.margin.top,\n        marginRight: size.margin.right,\n        marginBottom: size.margin.bottom,\n        marginLeft: size.margin.left,\n        flexShrink: \"0\",\n        flexGrow: \"0\",\n        pointerEvents: \"none\",\n        transition: animate !== \"none\" ? transitions.placeholder : null\n    };\n};\nconst Placeholder = (props)=>{\n    const animateOpenTimerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const tryClearAnimateOpenTimer = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(()=>{\n        if (!animateOpenTimerRef.current) {\n            return;\n        }\n        clearTimeout(animateOpenTimerRef.current);\n        animateOpenTimerRef.current = null;\n    }, []);\n    const { animate, onTransitionEnd, onClose, contextId } = props;\n    const [isAnimatingOpenOnMount, setIsAnimatingOpenOnMount] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(props.animate === \"open\");\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!isAnimatingOpenOnMount) {\n            return noop;\n        }\n        if (animate !== \"open\") {\n            tryClearAnimateOpenTimer();\n            setIsAnimatingOpenOnMount(false);\n            return noop;\n        }\n        if (animateOpenTimerRef.current) {\n            return noop;\n        }\n        animateOpenTimerRef.current = setTimeout(()=>{\n            animateOpenTimerRef.current = null;\n            setIsAnimatingOpenOnMount(false);\n        });\n        return tryClearAnimateOpenTimer;\n    }, [\n        animate,\n        isAnimatingOpenOnMount,\n        tryClearAnimateOpenTimer\n    ]);\n    const onSizeChangeEnd = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)((event)=>{\n        if (event.propertyName !== \"height\") {\n            return;\n        }\n        onTransitionEnd();\n        if (animate === \"close\") {\n            onClose();\n        }\n    }, [\n        animate,\n        onClose,\n        onTransitionEnd\n    ]);\n    const style = getStyle({\n        isAnimatingOpenOnMount,\n        animate: props.animate,\n        placeholder: props.placeholder\n    });\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(props.placeholder.tagName, {\n        style,\n        \"data-rfd-placeholder-context-id\": contextId,\n        onTransitionEnd: onSizeChangeEnd,\n        ref: props.innerRef\n    });\n};\nvar Placeholder$1 = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().memo(Placeholder);\nfunction isBoolean(value) {\n    return typeof value === \"boolean\";\n}\nfunction runChecks(args, checks) {\n    checks.forEach((check)=>check(args));\n}\nconst shared = [\n    function required({ props }) {\n        !props.droppableId ?  true ? invariant(false, \"A Droppable requires a droppableId prop\") : 0 : void 0;\n        !(typeof props.droppableId === \"string\") ?  true ? invariant(false, `A Droppable requires a [string] droppableId. Provided: [${typeof props.droppableId}]`) : 0 : void 0;\n    },\n    function boolean({ props }) {\n        !isBoolean(props.isDropDisabled) ?  true ? invariant(false, \"isDropDisabled must be a boolean\") : 0 : void 0;\n        !isBoolean(props.isCombineEnabled) ?  true ? invariant(false, \"isCombineEnabled must be a boolean\") : 0 : void 0;\n        !isBoolean(props.ignoreContainerClipping) ?  true ? invariant(false, \"ignoreContainerClipping must be a boolean\") : 0 : void 0;\n    },\n    function ref({ getDroppableRef }) {\n        checkIsValidInnerRef(getDroppableRef());\n    }\n];\nconst standard = [\n    function placeholder({ props, getPlaceholderRef }) {\n        if (!props.placeholder) {\n            return;\n        }\n        const ref = getPlaceholderRef();\n        if (ref) {\n            return;\n        }\n         true ? warning(`\n      Droppable setup issue [droppableId: \"${props.droppableId}\"]:\n      DroppableProvided > placeholder could not be found.\n\n      Please be sure to add the {provided.placeholder} React Node as a child of your Droppable.\n      More information: https://github.com/hello-pangea/dnd/blob/main/docs/api/droppable.md\n    `) : 0;\n    }\n];\nconst virtual = [\n    function hasClone({ props }) {\n        !props.renderClone ?  true ? invariant(false, \"Must provide a clone render function (renderClone) for virtual lists\") : 0 : void 0;\n    },\n    function hasNoPlaceholder({ getPlaceholderRef }) {\n        !!getPlaceholderRef() ?  true ? invariant(false, \"Expected virtual list to not have a placeholder\") : 0 : void 0;\n    }\n];\nfunction useValidation(args) {\n    useDevSetupWarning(()=>{\n        runChecks(args, shared);\n        if (args.props.mode === \"standard\") {\n            runChecks(args, standard);\n        }\n        if (args.props.mode === \"virtual\") {\n            runChecks(args, virtual);\n        }\n    });\n}\nclass AnimateInOut extends (react__WEBPACK_IMPORTED_MODULE_0___default().PureComponent) {\n    constructor(...args){\n        super(...args);\n        this.state = {\n            isVisible: Boolean(this.props.on),\n            data: this.props.on,\n            animate: this.props.shouldAnimate && this.props.on ? \"open\" : \"none\"\n        };\n        this.onClose = ()=>{\n            if (this.state.animate !== \"close\") {\n                return;\n            }\n            this.setState({\n                isVisible: false\n            });\n        };\n    }\n    static getDerivedStateFromProps(props, state) {\n        if (!props.shouldAnimate) {\n            return {\n                isVisible: Boolean(props.on),\n                data: props.on,\n                animate: \"none\"\n            };\n        }\n        if (props.on) {\n            return {\n                isVisible: true,\n                data: props.on,\n                animate: \"open\"\n            };\n        }\n        if (state.isVisible) {\n            return {\n                isVisible: true,\n                data: state.data,\n                animate: \"close\"\n            };\n        }\n        return {\n            isVisible: false,\n            animate: \"close\",\n            data: null\n        };\n    }\n    render() {\n        if (!this.state.isVisible) {\n            return null;\n        }\n        const provided = {\n            onClose: this.onClose,\n            data: this.state.data,\n            animate: this.state.animate\n        };\n        return this.props.children(provided);\n    }\n}\nconst Droppable = (props)=>{\n    const appContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(AppContext);\n    !appContext ?  true ? invariant(false, \"Could not find app context\") : 0 : void 0;\n    const { contextId, isMovementAllowed } = appContext;\n    const droppableRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const placeholderRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const { children, droppableId, type, mode, direction, ignoreContainerClipping, isDropDisabled, isCombineEnabled, snapshot, useClone, updateViewportMaxScroll, getContainerForClone } = props;\n    const getDroppableRef = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(()=>droppableRef.current, []);\n    const setDroppableRef = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)((value = null)=>{\n        droppableRef.current = value;\n    }, []);\n    const getPlaceholderRef = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(()=>placeholderRef.current, []);\n    const setPlaceholderRef = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)((value = null)=>{\n        placeholderRef.current = value;\n    }, []);\n    useValidation({\n        props,\n        getDroppableRef,\n        getPlaceholderRef\n    });\n    const onPlaceholderTransitionEnd = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useCallback)(()=>{\n        if (isMovementAllowed()) {\n            updateViewportMaxScroll({\n                maxScroll: getMaxWindowScroll()\n            });\n        }\n    }, [\n        isMovementAllowed,\n        updateViewportMaxScroll\n    ]);\n    useDroppablePublisher({\n        droppableId,\n        type,\n        mode,\n        direction,\n        isDropDisabled,\n        isCombineEnabled,\n        ignoreContainerClipping,\n        getDroppableRef\n    });\n    const placeholder = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(AnimateInOut, {\n            on: props.placeholder,\n            shouldAnimate: props.shouldAnimatePlaceholder\n        }, ({ onClose, data, animate })=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Placeholder$1, {\n                placeholder: data,\n                onClose: onClose,\n                innerRef: setPlaceholderRef,\n                animate: animate,\n                contextId: contextId,\n                onTransitionEnd: onPlaceholderTransitionEnd\n            })), [\n        contextId,\n        onPlaceholderTransitionEnd,\n        props.placeholder,\n        props.shouldAnimatePlaceholder,\n        setPlaceholderRef\n    ]);\n    const provided = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>({\n            innerRef: setDroppableRef,\n            placeholder,\n            droppableProps: {\n                \"data-rfd-droppable-id\": droppableId,\n                \"data-rfd-droppable-context-id\": contextId\n            }\n        }), [\n        contextId,\n        droppableId,\n        placeholder,\n        setDroppableRef\n    ]);\n    const isUsingCloneFor = useClone ? useClone.dragging.draggableId : null;\n    const droppableContext = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_8__.useMemo)(()=>({\n            droppableId,\n            type,\n            isUsingCloneFor\n        }), [\n        droppableId,\n        isUsingCloneFor,\n        type\n    ]);\n    function getClone() {\n        if (!useClone) {\n            return null;\n        }\n        const { dragging, render } = useClone;\n        const node = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(PrivateDraggable, {\n            draggableId: dragging.draggableId,\n            index: dragging.source.index,\n            isClone: true,\n            isEnabled: true,\n            shouldRespectForcePress: false,\n            canDragInteractiveElements: true\n        }, (draggableProvided, draggableSnapshot)=>render(draggableProvided, draggableSnapshot, dragging));\n        return /*#__PURE__*/ react_dom__WEBPACK_IMPORTED_MODULE_1___default().createPortal(node, getContainerForClone());\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(DroppableContext.Provider, {\n        value: droppableContext\n    }, children(provided, snapshot), getClone());\n};\nvar Droppable$1 = Droppable;\nfunction getBody() {\n    !document.body ?  true ? invariant(false, \"document.body is not ready\") : 0 : void 0;\n    return document.body;\n}\nconst defaultProps = {\n    mode: \"standard\",\n    type: \"DEFAULT\",\n    direction: \"vertical\",\n    isDropDisabled: false,\n    isCombineEnabled: false,\n    ignoreContainerClipping: false,\n    renderClone: null,\n    getContainerForClone: getBody\n};\nconst attachDefaultPropsToOwnProps = (ownProps)=>{\n    let mergedProps = {\n        ...ownProps\n    };\n    let defaultPropKey;\n    for(defaultPropKey in defaultProps){\n        if (ownProps[defaultPropKey] === undefined) {\n            mergedProps = {\n                ...mergedProps,\n                [defaultPropKey]: defaultProps[defaultPropKey]\n            };\n        }\n    }\n    return mergedProps;\n};\nconst isMatchingType = (type, critical)=>type === critical.droppable.type;\nconst getDraggable = (critical, dimensions)=>dimensions.draggables[critical.draggable.id];\nconst makeMapStateToProps = ()=>{\n    const idleWithAnimation = {\n        placeholder: null,\n        shouldAnimatePlaceholder: true,\n        snapshot: {\n            isDraggingOver: false,\n            draggingOverWith: null,\n            draggingFromThisWith: null,\n            isUsingPlaceholder: false\n        },\n        useClone: null\n    };\n    const idleWithoutAnimation = {\n        ...idleWithAnimation,\n        shouldAnimatePlaceholder: false\n    };\n    const getDraggableRubric = (0,memoize_one__WEBPACK_IMPORTED_MODULE_5__[\"default\"])((descriptor)=>({\n            draggableId: descriptor.id,\n            type: descriptor.type,\n            source: {\n                index: descriptor.index,\n                droppableId: descriptor.droppableId\n            }\n        }));\n    const getMapProps = (0,memoize_one__WEBPACK_IMPORTED_MODULE_5__[\"default\"])((id, isEnabled, isDraggingOverForConsumer, isDraggingOverForImpact, dragging, renderClone)=>{\n        const draggableId = dragging.descriptor.id;\n        const isHome = dragging.descriptor.droppableId === id;\n        if (isHome) {\n            const useClone = renderClone ? {\n                render: renderClone,\n                dragging: getDraggableRubric(dragging.descriptor)\n            } : null;\n            const snapshot = {\n                isDraggingOver: isDraggingOverForConsumer,\n                draggingOverWith: isDraggingOverForConsumer ? draggableId : null,\n                draggingFromThisWith: draggableId,\n                isUsingPlaceholder: true\n            };\n            return {\n                placeholder: dragging.placeholder,\n                shouldAnimatePlaceholder: false,\n                snapshot,\n                useClone\n            };\n        }\n        if (!isEnabled) {\n            return idleWithoutAnimation;\n        }\n        if (!isDraggingOverForImpact) {\n            return idleWithAnimation;\n        }\n        const snapshot = {\n            isDraggingOver: isDraggingOverForConsumer,\n            draggingOverWith: draggableId,\n            draggingFromThisWith: null,\n            isUsingPlaceholder: true\n        };\n        return {\n            placeholder: dragging.placeholder,\n            shouldAnimatePlaceholder: true,\n            snapshot,\n            useClone: null\n        };\n    });\n    const selector = (state, ownProps)=>{\n        const ownPropsWithDefaultProps = attachDefaultPropsToOwnProps(ownProps);\n        const id = ownPropsWithDefaultProps.droppableId;\n        const type = ownPropsWithDefaultProps.type;\n        const isEnabled = !ownPropsWithDefaultProps.isDropDisabled;\n        const renderClone = ownPropsWithDefaultProps.renderClone;\n        if (isDragging(state)) {\n            const critical = state.critical;\n            if (!isMatchingType(type, critical)) {\n                return idleWithoutAnimation;\n            }\n            const dragging = getDraggable(critical, state.dimensions);\n            const isDraggingOver = whatIsDraggedOver(state.impact) === id;\n            return getMapProps(id, isEnabled, isDraggingOver, isDraggingOver, dragging, renderClone);\n        }\n        if (state.phase === \"DROP_ANIMATING\") {\n            const completed = state.completed;\n            if (!isMatchingType(type, completed.critical)) {\n                return idleWithoutAnimation;\n            }\n            const dragging = getDraggable(completed.critical, state.dimensions);\n            return getMapProps(id, isEnabled, whatIsDraggedOverFromResult(completed.result) === id, whatIsDraggedOver(completed.impact) === id, dragging, renderClone);\n        }\n        if (state.phase === \"IDLE\" && state.completed && !state.shouldFlush) {\n            const completed = state.completed;\n            if (!isMatchingType(type, completed.critical)) {\n                return idleWithoutAnimation;\n            }\n            const wasOver = whatIsDraggedOver(completed.impact) === id;\n            const wasCombining = Boolean(completed.impact.at && completed.impact.at.type === \"COMBINE\");\n            const isHome = completed.critical.droppable.id === id;\n            if (wasOver) {\n                return wasCombining ? idleWithAnimation : idleWithoutAnimation;\n            }\n            if (isHome) {\n                return idleWithAnimation;\n            }\n            return idleWithoutAnimation;\n        }\n        return idleWithoutAnimation;\n    };\n    return selector;\n};\nconst mapDispatchToProps = {\n    updateViewportMaxScroll: updateViewportMaxScroll\n};\nconst ConnectedDroppable = (0,react_redux__WEBPACK_IMPORTED_MODULE_2__.connect)(makeMapStateToProps, mapDispatchToProps, (stateProps, dispatchProps, ownProps)=>{\n    return {\n        ...attachDefaultPropsToOwnProps(ownProps),\n        ...stateProps,\n        ...dispatchProps\n    };\n}, {\n    context: StoreContext,\n    areStatePropsEqual: isStrictEqual\n})(Droppable$1);\nvar ConnectedDroppable$1 = ConnectedDroppable;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGhlbGxvLXBhbmdlYS9kbmQvZGlzdC9kbmQuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE2RztBQUM3RDtBQUNtRDtBQUNuRDtBQUNJO0FBQ2lEO0FBQ2hFO0FBQ047QUFDMkI7QUFFMUQsTUFBTTRCLGlCQUFpQkMsa0JBQXlCO0FBQ2hELE1BQU1DLGdCQUFnQjtBQUN0QixNQUFNQyxzQkFBc0I7QUFDNUIsTUFBTUMsVUFBVUMsQ0FBQUEsUUFBU0EsTUFBTUMsT0FBTyxDQUFDSixlQUFlLEtBQUtJLE9BQU8sQ0FBQ0gscUJBQXFCLElBQUlJLElBQUk7QUFDaEcsTUFBTUMsZ0JBQWdCQyxDQUFBQSxVQUFXTCxRQUFRLENBQUM7OztJQUd0QyxFQUFFQSxRQUFRSyxTQUFTOzs7QUFHdkIsQ0FBQztBQUNELE1BQU1DLHNCQUFzQkQsQ0FBQUEsVUFBVztRQUFDRCxjQUFjQztRQUFVO1FBQXdEO1FBQW9CO0tBQWtCO0FBQzlKLE1BQU1FLGlCQUFpQjtBQUN2QixTQUFTQyxJQUFJQyxJQUFJLEVBQUVKLE9BQU87SUFDeEIsSUFBSVQsZ0JBQWdCO1FBQ2xCO0lBQ0Y7SUFDQSxJQUFJLEtBQXVELEVBQUUsRUFFNUQ7SUFDRGUsT0FBTyxDQUFDRixLQUFLLElBQUlILG9CQUFvQkQ7QUFDdkM7QUFDQSxNQUFNTyxVQUFVSixJQUFJSyxJQUFJLENBQUMsTUFBTTtBQUMvQixNQUFNQyxRQUFRTixJQUFJSyxJQUFJLENBQUMsTUFBTTtBQUU3QixTQUFTRSxVQUFVO0FBRW5CLFNBQVNDLFdBQVdDLE1BQU0sRUFBRUMsV0FBVztJQUNyQyxPQUFPO1FBQ0wsR0FBR0QsTUFBTTtRQUNULEdBQUdDLFdBQVc7SUFDaEI7QUFDRjtBQUNBLFNBQVNDLFdBQVdDLEVBQUUsRUFBRUMsUUFBUSxFQUFFQyxhQUFhO0lBQzdDLE1BQU1DLGFBQWFGLFNBQVNHLEdBQUcsQ0FBQ0MsQ0FBQUE7UUFDOUIsTUFBTUMsVUFBVVYsV0FB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Q3hELE1BQU1xckMsZUFBZTUvQixRQUFReU4sVUFBVXJULE1BQU0sQ0FBQ0MsRUFBRSxJQUFJb1QsVUFBVXJULE1BQU0sQ0FBQ0MsRUFBRSxDQUFDaEssSUFBSSxLQUFLO1lBQ2pGLE1BQU1xdkMsU0FBU2p5QixVQUFVN0YsUUFBUSxDQUFDalAsU0FBUyxDQUFDcEUsRUFBRSxLQUFLQTtZQUNuRCxJQUFJd1ksU0FBUztnQkFDWCxPQUFPNnlCLGVBQWVaLG9CQUFvQks7WUFDNUM7WUFDQSxJQUFJSyxRQUFRO2dCQUNWLE9BQU9WO1lBQ1Q7WUFDQSxPQUFPSztRQUNUO1FBQ0EsT0FBT0E7SUFDVDtJQUNBLE9BQU8vZDtBQUNUO0FBQ0EsTUFBTXVlLHFCQUFxQjtJQUN6Qjl3Qix5QkFBeUJBO0FBQzNCO0FBQ0EsTUFBTSt3QixxQkFBcUJueEMsb0RBQU9BLENBQUNvd0MscUJBQXFCYyxvQkFBb0IsQ0FBQ0UsWUFBWUMsZUFBZS9JO0lBQ3RHLE9BQU87UUFDTCxHQUFHeUgsNkJBQTZCekgsU0FBUztRQUN6QyxHQUFHOEksVUFBVTtRQUNiLEdBQUdDLGFBQWE7SUFDbEI7QUFDRixHQUFHO0lBQ0RqZixTQUFTaUY7SUFDVGlTLG9CQUFvQjNCO0FBQ3RCLEdBQUdpSTtBQUNILElBQUkwQix1QkFBdUJIO0FBRXdJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vSU5URUdSQVRFRCBQUk9KRUNUIFRSQUNLSU5HIEFORCBDT09SRElOQVRJT04gSFVCLy4vbm9kZV9tb2R1bGVzL0BoZWxsby1wYW5nZWEvZG5kL2Rpc3QvZG5kLmVzbS5qcz9jOTk3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyB1c2VMYXlvdXRFZmZlY3QgYXMgdXNlTGF5b3V0RWZmZWN0JDEsIHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSwgdXNlQ29udGV4dCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBSZWFjdERPTSwgeyBmbHVzaFN5bmMgfSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IHsgY3JlYXRlU3RvcmUgYXMgY3JlYXRlU3RvcmUkMSwgYXBwbHlNaWRkbGV3YXJlLCBjb21wb3NlLCBiaW5kQWN0aW9uQ3JlYXRvcnMgfSBmcm9tICdyZWR1eCc7XG5pbXBvcnQgeyBQcm92aWRlciwgY29ubmVjdCB9IGZyb20gJ3JlYWN0LXJlZHV4JztcbmltcG9ydCB7IHVzZU1lbW8sIHVzZUNhbGxiYWNrIH0gZnJvbSAndXNlLW1lbW8tb25lJztcbmltcG9ydCB7IGdldFJlY3QsIGV4cGFuZCwgb2Zmc2V0LCB3aXRoU2Nyb2xsLCBjYWxjdWxhdGVCb3gsIGdldEJveCwgY3JlYXRlQm94IH0gZnJvbSAnY3NzLWJveC1tb2RlbCc7XG5pbXBvcnQgbWVtb2l6ZU9uZSBmcm9tICdtZW1vaXplLW9uZSc7XG5pbXBvcnQgcmFmU2NoZCBmcm9tICdyYWYtc2NoZCc7XG5pbXBvcnQgX2V4dGVuZHMgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kcyc7XG5cbmNvbnN0IGlzUHJvZHVjdGlvbiQxID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJztcbmNvbnN0IHNwYWNlc0FuZFRhYnMgPSAvWyBcXHRdezIsfS9nO1xuY29uc3QgbGluZVN0YXJ0V2l0aFNwYWNlcyA9IC9eWyBcXHRdKi9nbTtcbmNvbnN0IGNsZWFuJDIgPSB2YWx1ZSA9PiB2YWx1ZS5yZXBsYWNlKHNwYWNlc0FuZFRhYnMsICcgJykucmVwbGFjZShsaW5lU3RhcnRXaXRoU3BhY2VzLCAnJykudHJpbSgpO1xuY29uc3QgZ2V0RGV2TWVzc2FnZSA9IG1lc3NhZ2UgPT4gY2xlYW4kMihgXG4gICVjQGhlbGxvLXBhbmdlYS9kbmRcblxuICAlYyR7Y2xlYW4kMihtZXNzYWdlKX1cblxuICAlY/CfkbfigI0gVGhpcyBpcyBhIGRldmVsb3BtZW50IG9ubHkgbWVzc2FnZS4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHByb2R1Y3Rpb24gYnVpbGRzLlxuYCk7XG5jb25zdCBnZXRGb3JtYXR0ZWRNZXNzYWdlID0gbWVzc2FnZSA9PiBbZ2V0RGV2TWVzc2FnZShtZXNzYWdlKSwgJ2NvbG9yOiAjMDBDNTg0OyBmb250LXNpemU6IDEuMmVtOyBmb250LXdlaWdodDogYm9sZDsnLCAnbGluZS1oZWlnaHQ6IDEuNScsICdjb2xvcjogIzcyMzg3NDsnXTtcbmNvbnN0IGlzRGlzYWJsZWRGbGFnID0gJ19fQGhlbGxvLXBhbmdlYS9kbmQtZGlzYWJsZS1kZXYtd2FybmluZ3MnO1xuZnVuY3Rpb24gbG9nKHR5cGUsIG1lc3NhZ2UpIHtcbiAgaWYgKGlzUHJvZHVjdGlvbiQxKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3dbaXNEaXNhYmxlZEZsYWddKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnNvbGVbdHlwZV0oLi4uZ2V0Rm9ybWF0dGVkTWVzc2FnZShtZXNzYWdlKSk7XG59XG5jb25zdCB3YXJuaW5nID0gbG9nLmJpbmQobnVsbCwgJ3dhcm4nKTtcbmNvbnN0IGVycm9yID0gbG9nLmJpbmQobnVsbCwgJ2Vycm9yJyk7XG5cbmZ1bmN0aW9uIG5vb3AkMigpIHt9XG5cbmZ1bmN0aW9uIGdldE9wdGlvbnMoc2hhcmVkLCBmcm9tQmluZGluZykge1xuICByZXR1cm4ge1xuICAgIC4uLnNoYXJlZCxcbiAgICAuLi5mcm9tQmluZGluZ1xuICB9O1xufVxuZnVuY3Rpb24gYmluZEV2ZW50cyhlbCwgYmluZGluZ3MsIHNoYXJlZE9wdGlvbnMpIHtcbiAgY29uc3QgdW5iaW5kaW5ncyA9IGJpbmRpbmdzLm1hcChiaW5kaW5nID0+IHtcbiAgICBjb25zdCBvcHRpb25zID0gZ2V0T3B0aW9ucyhzaGFyZWRPcHRpb25zLCBiaW5kaW5nLm9wdGlvbnMpO1xuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoYmluZGluZy5ldmVudE5hbWUsIGJpbmRpbmcuZm4sIG9wdGlvbnMpO1xuICAgIHJldHVybiBmdW5jdGlvbiB1bmJpbmQoKSB7XG4gICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGJpbmRpbmcuZXZlbnROYW1lLCBiaW5kaW5nLmZuLCBvcHRpb25zKTtcbiAgICB9O1xuICB9KTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHVuYmluZEFsbCgpIHtcbiAgICB1bmJpbmRpbmdzLmZvckVhY2godW5iaW5kID0+IHtcbiAgICAgIHVuYmluZCgpO1xuICAgIH0pO1xuICB9O1xufVxuXG5jb25zdCBpc1Byb2R1Y3Rpb24gPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nO1xuY29uc3QgcHJlZml4JDEgPSAnSW52YXJpYW50IGZhaWxlZCc7XG5jbGFzcyBSYmRJbnZhcmlhbnQgZXh0ZW5kcyBFcnJvciB7fVxuUmJkSW52YXJpYW50LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gdGhpcy5tZXNzYWdlO1xufTtcbmZ1bmN0aW9uIGludmFyaWFudChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgaWYgKGNvbmRpdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoaXNQcm9kdWN0aW9uKSB7XG4gICAgdGhyb3cgbmV3IFJiZEludmFyaWFudChwcmVmaXgkMSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFJiZEludmFyaWFudChgJHtwcmVmaXgkMX06ICR7bWVzc2FnZSB8fCAnJ31gKTtcbiAgfVxufVxuXG5jbGFzcyBFcnJvckJvdW5kYXJ5IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgIHRoaXMuY2FsbGJhY2tzID0gbnVsbDtcbiAgICB0aGlzLnVuYmluZCA9IG5vb3AkMjtcbiAgICB0aGlzLm9uV2luZG93RXJyb3IgPSBldmVudCA9PiB7XG4gICAgICBjb25zdCBjYWxsYmFja3MgPSB0aGlzLmdldENhbGxiYWNrcygpO1xuICAgICAgaWYgKGNhbGxiYWNrcy5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgY2FsbGJhY2tzLnRyeUFib3J0KCk7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoYFxuICAgICAgICBBbiBlcnJvciB3YXMgY2F1Z2h0IGJ5IG91ciB3aW5kb3cgJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB3aGlsZSBhIGRyYWcgd2FzIG9jY3VycmluZy5cbiAgICAgICAgVGhlIGFjdGl2ZSBkcmFnIGhhcyBiZWVuIGFib3J0ZWQuXG4gICAgICBgKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVyciA9IGV2ZW50LmVycm9yO1xuICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIFJiZEludmFyaWFudCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGVycm9yKGVyci5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5nZXRDYWxsYmFja3MgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuY2FsbGJhY2tzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgQXBwQ2FsbGJhY2tzIGluIDxFcnJvckJvdW5kYXJ5Lz4nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmNhbGxiYWNrcztcbiAgICB9O1xuICAgIHRoaXMuc2V0Q2FsbGJhY2tzID0gY2FsbGJhY2tzID0+IHtcbiAgICAgIHRoaXMuY2FsbGJhY2tzID0gY2FsbGJhY2tzO1xuICAgIH07XG4gIH1cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdGhpcy51bmJpbmQgPSBiaW5kRXZlbnRzKHdpbmRvdywgW3tcbiAgICAgIGV2ZW50TmFtZTogJ2Vycm9yJyxcbiAgICAgIGZuOiB0aGlzLm9uV2luZG93RXJyb3JcbiAgICB9XSk7XG4gIH1cbiAgY29tcG9uZW50RGlkQ2F0Y2goZXJyKSB7XG4gICAgaWYgKGVyciBpbnN0YW5jZW9mIFJiZEludmFyaWFudCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgZXJyb3IoZXJyLm1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRTdGF0ZSh7fSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRocm93IGVycjtcbiAgfVxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICB0aGlzLnVuYmluZCgpO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbih0aGlzLnNldENhbGxiYWNrcyk7XG4gIH1cbn1cblxuY29uc3QgZHJhZ0hhbmRsZVVzYWdlSW5zdHJ1Y3Rpb25zID0gYFxuICBQcmVzcyBzcGFjZSBiYXIgdG8gc3RhcnQgYSBkcmFnLlxuICBXaGVuIGRyYWdnaW5nIHlvdSBjYW4gdXNlIHRoZSBhcnJvdyBrZXlzIHRvIG1vdmUgdGhlIGl0ZW0gYXJvdW5kIGFuZCBlc2NhcGUgdG8gY2FuY2VsLlxuICBTb21lIHNjcmVlbiByZWFkZXJzIG1heSByZXF1aXJlIHlvdSB0byBiZSBpbiBmb2N1cyBtb2RlIG9yIHRvIHVzZSB5b3VyIHBhc3MgdGhyb3VnaCBrZXlcbmA7XG5jb25zdCBwb3NpdGlvbiA9IGluZGV4ID0+IGluZGV4ICsgMTtcbmNvbnN0IG9uRHJhZ1N0YXJ0ID0gc3RhcnQgPT4gYFxuICBZb3UgaGF2ZSBsaWZ0ZWQgYW4gaXRlbSBpbiBwb3NpdGlvbiAke3Bvc2l0aW9uKHN0YXJ0LnNvdXJjZS5pbmRleCl9XG5gO1xuY29uc3Qgd2l0aExvY2F0aW9uID0gKHNvdXJjZSwgZGVzdGluYXRpb24pID0+IHtcbiAgY29uc3QgaXNJbkhvbWVMaXN0ID0gc291cmNlLmRyb3BwYWJsZUlkID09PSBkZXN0aW5hdGlvbi5kcm9wcGFibGVJZDtcbiAgY29uc3Qgc3RhcnRQb3NpdGlvbiA9IHBvc2l0aW9uKHNvdXJjZS5pbmRleCk7XG4gIGNvbnN0IGVuZFBvc2l0aW9uID0gcG9zaXRpb24oZGVzdGluYXRpb24uaW5kZXgpO1xuICBpZiAoaXNJbkhvbWVMaXN0KSB7XG4gICAgcmV0dXJuIGBcbiAgICAgIFlvdSBoYXZlIG1vdmVkIHRoZSBpdGVtIGZyb20gcG9zaXRpb24gJHtzdGFydFBvc2l0aW9ufVxuICAgICAgdG8gcG9zaXRpb24gJHtlbmRQb3NpdGlvbn1cbiAgICBgO1xuICB9XG4gIHJldHVybiBgXG4gICAgWW91IGhhdmUgbW92ZWQgdGhlIGl0ZW0gZnJvbSBwb3NpdGlvbiAke3N0YXJ0UG9zaXRpb259XG4gICAgaW4gbGlzdCAke3NvdXJjZS5kcm9wcGFibGVJZH1cbiAgICB0byBsaXN0ICR7ZGVzdGluYXRpb24uZHJvcHBhYmxlSWR9XG4gICAgaW4gcG9zaXRpb24gJHtlbmRQb3NpdGlvbn1cbiAgYDtcbn07XG5jb25zdCB3aXRoQ29tYmluZSA9IChpZCwgc291cmNlLCBjb21iaW5lKSA9PiB7XG4gIGNvbnN0IGluSG9tZUxpc3QgPSBzb3VyY2UuZHJvcHBhYmxlSWQgPT09IGNvbWJpbmUuZHJvcHBhYmxlSWQ7XG4gIGlmIChpbkhvbWVMaXN0KSB7XG4gICAgcmV0dXJuIGBcbiAgICAgIFRoZSBpdGVtICR7aWR9XG4gICAgICBoYXMgYmVlbiBjb21iaW5lZCB3aXRoICR7Y29tYmluZS5kcmFnZ2FibGVJZH1gO1xuICB9XG4gIHJldHVybiBgXG4gICAgICBUaGUgaXRlbSAke2lkfVxuICAgICAgaW4gbGlzdCAke3NvdXJjZS5kcm9wcGFibGVJZH1cbiAgICAgIGhhcyBiZWVuIGNvbWJpbmVkIHdpdGggJHtjb21iaW5lLmRyYWdnYWJsZUlkfVxuICAgICAgaW4gbGlzdCAke2NvbWJpbmUuZHJvcHBhYmxlSWR9XG4gICAgYDtcbn07XG5jb25zdCBvbkRyYWdVcGRhdGUgPSB1cGRhdGUgPT4ge1xuICBjb25zdCBsb2NhdGlvbiA9IHVwZGF0ZS5kZXN0aW5hdGlvbjtcbiAgaWYgKGxvY2F0aW9uKSB7XG4gICAgcmV0dXJuIHdpdGhMb2NhdGlvbih1cGRhdGUuc291cmNlLCBsb2NhdGlvbik7XG4gIH1cbiAgY29uc3QgY29tYmluZSA9IHVwZGF0ZS5jb21iaW5lO1xuICBpZiAoY29tYmluZSkge1xuICAgIHJldHVybiB3aXRoQ29tYmluZSh1cGRhdGUuZHJhZ2dhYmxlSWQsIHVwZGF0ZS5zb3VyY2UsIGNvbWJpbmUpO1xuICB9XG4gIHJldHVybiAnWW91IGFyZSBvdmVyIGFuIGFyZWEgdGhhdCBjYW5ub3QgYmUgZHJvcHBlZCBvbic7XG59O1xuY29uc3QgcmV0dXJuZWRUb1N0YXJ0ID0gc291cmNlID0+IGBcbiAgVGhlIGl0ZW0gaGFzIHJldHVybmVkIHRvIGl0cyBzdGFydGluZyBwb3NpdGlvblxuICBvZiAke3Bvc2l0aW9uKHNvdXJjZS5pbmRleCl9XG5gO1xuY29uc3Qgb25EcmFnRW5kID0gcmVzdWx0ID0+IHtcbiAgaWYgKHJlc3VsdC5yZWFzb24gPT09ICdDQU5DRUwnKSB7XG4gICAgcmV0dXJuIGBcbiAgICAgIE1vdmVtZW50IGNhbmNlbGxlZC5cbiAgICAgICR7cmV0dXJuZWRUb1N0YXJ0KHJlc3VsdC5zb3VyY2UpfVxuICAgIGA7XG4gIH1cbiAgY29uc3QgbG9jYXRpb24gPSByZXN1bHQuZGVzdGluYXRpb247XG4gIGNvbnN0IGNvbWJpbmUgPSByZXN1bHQuY29tYmluZTtcbiAgaWYgKGxvY2F0aW9uKSB7XG4gICAgcmV0dXJuIGBcbiAgICAgIFlvdSBoYXZlIGRyb3BwZWQgdGhlIGl0ZW0uXG4gICAgICAke3dpdGhMb2NhdGlvbihyZXN1bHQuc291cmNlLCBsb2NhdGlvbil9XG4gICAgYDtcbiAgfVxuICBpZiAoY29tYmluZSkge1xuICAgIHJldHVybiBgXG4gICAgICBZb3UgaGF2ZSBkcm9wcGVkIHRoZSBpdGVtLlxuICAgICAgJHt3aXRoQ29tYmluZShyZXN1bHQuZHJhZ2dhYmxlSWQsIHJlc3VsdC5zb3VyY2UsIGNvbWJpbmUpfVxuICAgIGA7XG4gIH1cbiAgcmV0dXJuIGBcbiAgICBUaGUgaXRlbSBoYXMgYmVlbiBkcm9wcGVkIHdoaWxlIG5vdCBvdmVyIGEgZHJvcCBhcmVhLlxuICAgICR7cmV0dXJuZWRUb1N0YXJ0KHJlc3VsdC5zb3VyY2UpfVxuICBgO1xufTtcbmNvbnN0IHByZXNldCA9IHtcbiAgZHJhZ0hhbmRsZVVzYWdlSW5zdHJ1Y3Rpb25zLFxuICBvbkRyYWdTdGFydCxcbiAgb25EcmFnVXBkYXRlLFxuICBvbkRyYWdFbmRcbn07XG52YXIgcHJlc2V0JDEgPSBwcmVzZXQ7XG5cbmNvbnN0IG9yaWdpbiA9IHtcbiAgeDogMCxcbiAgeTogMFxufTtcbmNvbnN0IGFkZCA9IChwb2ludDEsIHBvaW50MikgPT4gKHtcbiAgeDogcG9pbnQxLnggKyBwb2ludDIueCxcbiAgeTogcG9pbnQxLnkgKyBwb2ludDIueVxufSk7XG5jb25zdCBzdWJ0cmFjdCA9IChwb2ludDEsIHBvaW50MikgPT4gKHtcbiAgeDogcG9pbnQxLnggLSBwb2ludDIueCxcbiAgeTogcG9pbnQxLnkgLSBwb2ludDIueVxufSk7XG5jb25zdCBpc0VxdWFsJDEgPSAocG9pbnQxLCBwb2ludDIpID0+IHBvaW50MS54ID09PSBwb2ludDIueCAmJiBwb2ludDEueSA9PT0gcG9pbnQyLnk7XG5jb25zdCBuZWdhdGUgPSBwb2ludCA9PiAoe1xuICB4OiBwb2ludC54ICE9PSAwID8gLXBvaW50LnggOiAwLFxuICB5OiBwb2ludC55ICE9PSAwID8gLXBvaW50LnkgOiAwXG59KTtcbmNvbnN0IHBhdGNoID0gKGxpbmUsIHZhbHVlLCBvdGhlclZhbHVlID0gMCkgPT4ge1xuICBpZiAobGluZSA9PT0gJ3gnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHZhbHVlLFxuICAgICAgeTogb3RoZXJWYWx1ZVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB4OiBvdGhlclZhbHVlLFxuICAgIHk6IHZhbHVlXG4gIH07XG59O1xuY29uc3QgZGlzdGFuY2UgPSAocG9pbnQxLCBwb2ludDIpID0+IE1hdGguc3FydCgocG9pbnQyLnggLSBwb2ludDEueCkgKiogMiArIChwb2ludDIueSAtIHBvaW50MS55KSAqKiAyKTtcbmNvbnN0IGNsb3Nlc3QkMSA9ICh0YXJnZXQsIHBvaW50cykgPT4gTWF0aC5taW4oLi4ucG9pbnRzLm1hcChwb2ludCA9PiBkaXN0YW5jZSh0YXJnZXQsIHBvaW50KSkpO1xuY29uc3QgYXBwbHkgPSBmbiA9PiBwb2ludCA9PiAoe1xuICB4OiBmbihwb2ludC54KSxcbiAgeTogZm4ocG9pbnQueSlcbn0pO1xuXG52YXIgZXhlY3V0ZUNsaXAgPSAoKGZyYW1lLCBzdWJqZWN0KSA9PiB7XG4gIGNvbnN0IHJlc3VsdCA9IGdldFJlY3Qoe1xuICAgIHRvcDogTWF0aC5tYXgoc3ViamVjdC50b3AsIGZyYW1lLnRvcCksXG4gICAgcmlnaHQ6IE1hdGgubWluKHN1YmplY3QucmlnaHQsIGZyYW1lLnJpZ2h0KSxcbiAgICBib3R0b206IE1hdGgubWluKHN1YmplY3QuYm90dG9tLCBmcmFtZS5ib3R0b20pLFxuICAgIGxlZnQ6IE1hdGgubWF4KHN1YmplY3QubGVmdCwgZnJhbWUubGVmdClcbiAgfSk7XG4gIGlmIChyZXN1bHQud2lkdGggPD0gMCB8fCByZXN1bHQuaGVpZ2h0IDw9IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufSk7XG5cbmNvbnN0IG9mZnNldEJ5UG9zaXRpb24gPSAoc3BhY2luZywgcG9pbnQpID0+ICh7XG4gIHRvcDogc3BhY2luZy50b3AgKyBwb2ludC55LFxuICBsZWZ0OiBzcGFjaW5nLmxlZnQgKyBwb2ludC54LFxuICBib3R0b206IHNwYWNpbmcuYm90dG9tICsgcG9pbnQueSxcbiAgcmlnaHQ6IHNwYWNpbmcucmlnaHQgKyBwb2ludC54XG59KTtcbmNvbnN0IGdldENvcm5lcnMgPSBzcGFjaW5nID0+IFt7XG4gIHg6IHNwYWNpbmcubGVmdCxcbiAgeTogc3BhY2luZy50b3Bcbn0sIHtcbiAgeDogc3BhY2luZy5yaWdodCxcbiAgeTogc3BhY2luZy50b3Bcbn0sIHtcbiAgeDogc3BhY2luZy5sZWZ0LFxuICB5OiBzcGFjaW5nLmJvdHRvbVxufSwge1xuICB4OiBzcGFjaW5nLnJpZ2h0LFxuICB5OiBzcGFjaW5nLmJvdHRvbVxufV07XG5jb25zdCBub1NwYWNpbmcgPSB7XG4gIHRvcDogMCxcbiAgcmlnaHQ6IDAsXG4gIGJvdHRvbTogMCxcbiAgbGVmdDogMFxufTtcblxuY29uc3Qgc2Nyb2xsJDEgPSAodGFyZ2V0LCBmcmFtZSkgPT4ge1xuICBpZiAoIWZyYW1lKSB7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICByZXR1cm4gb2Zmc2V0QnlQb3NpdGlvbih0YXJnZXQsIGZyYW1lLnNjcm9sbC5kaWZmLmRpc3BsYWNlbWVudCk7XG59O1xuY29uc3QgaW5jcmVhc2UgPSAodGFyZ2V0LCBheGlzLCB3aXRoUGxhY2Vob2xkZXIpID0+IHtcbiAgaWYgKHdpdGhQbGFjZWhvbGRlciAmJiB3aXRoUGxhY2Vob2xkZXIuaW5jcmVhc2VkQnkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4udGFyZ2V0LFxuICAgICAgW2F4aXMuZW5kXTogdGFyZ2V0W2F4aXMuZW5kXSArIHdpdGhQbGFjZWhvbGRlci5pbmNyZWFzZWRCeVtheGlzLmxpbmVdXG4gICAgfTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufTtcbmNvbnN0IGNsaXAgPSAodGFyZ2V0LCBmcmFtZSkgPT4ge1xuICBpZiAoZnJhbWUgJiYgZnJhbWUuc2hvdWxkQ2xpcFN1YmplY3QpIHtcbiAgICByZXR1cm4gZXhlY3V0ZUNsaXAoZnJhbWUucGFnZU1hcmdpbkJveCwgdGFyZ2V0KTtcbiAgfVxuICByZXR1cm4gZ2V0UmVjdCh0YXJnZXQpO1xufTtcbnZhciBnZXRTdWJqZWN0ID0gKCh7XG4gIHBhZ2UsXG4gIHdpdGhQbGFjZWhvbGRlcixcbiAgYXhpcyxcbiAgZnJhbWVcbn0pID0+IHtcbiAgY29uc3Qgc2Nyb2xsZWQgPSBzY3JvbGwkMShwYWdlLm1hcmdpbkJveCwgZnJhbWUpO1xuICBjb25zdCBpbmNyZWFzZWQgPSBpbmNyZWFzZShzY3JvbGxlZCwgYXhpcywgd2l0aFBsYWNlaG9sZGVyKTtcbiAgY29uc3QgY2xpcHBlZCA9IGNsaXAoaW5jcmVhc2VkLCBmcmFtZSk7XG4gIHJldHVybiB7XG4gICAgcGFnZSxcbiAgICB3aXRoUGxhY2Vob2xkZXIsXG4gICAgYWN0aXZlOiBjbGlwcGVkXG4gIH07XG59KTtcblxudmFyIHNjcm9sbERyb3BwYWJsZSA9ICgoZHJvcHBhYmxlLCBuZXdTY3JvbGwpID0+IHtcbiAgIWRyb3BwYWJsZS5mcmFtZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICBjb25zdCBzY3JvbGxhYmxlID0gZHJvcHBhYmxlLmZyYW1lO1xuICBjb25zdCBzY3JvbGxEaWZmID0gc3VidHJhY3QobmV3U2Nyb2xsLCBzY3JvbGxhYmxlLnNjcm9sbC5pbml0aWFsKTtcbiAgY29uc3Qgc2Nyb2xsRGlzcGxhY2VtZW50ID0gbmVnYXRlKHNjcm9sbERpZmYpO1xuICBjb25zdCBmcmFtZSA9IHtcbiAgICAuLi5zY3JvbGxhYmxlLFxuICAgIHNjcm9sbDoge1xuICAgICAgaW5pdGlhbDogc2Nyb2xsYWJsZS5zY3JvbGwuaW5pdGlhbCxcbiAgICAgIGN1cnJlbnQ6IG5ld1Njcm9sbCxcbiAgICAgIGRpZmY6IHtcbiAgICAgICAgdmFsdWU6IHNjcm9sbERpZmYsXG4gICAgICAgIGRpc3BsYWNlbWVudDogc2Nyb2xsRGlzcGxhY2VtZW50XG4gICAgICB9LFxuICAgICAgbWF4OiBzY3JvbGxhYmxlLnNjcm9sbC5tYXhcbiAgICB9XG4gIH07XG4gIGNvbnN0IHN1YmplY3QgPSBnZXRTdWJqZWN0KHtcbiAgICBwYWdlOiBkcm9wcGFibGUuc3ViamVjdC5wYWdlLFxuICAgIHdpdGhQbGFjZWhvbGRlcjogZHJvcHBhYmxlLnN1YmplY3Qud2l0aFBsYWNlaG9sZGVyLFxuICAgIGF4aXM6IGRyb3BwYWJsZS5heGlzLFxuICAgIGZyYW1lXG4gIH0pO1xuICBjb25zdCByZXN1bHQgPSB7XG4gICAgLi4uZHJvcHBhYmxlLFxuICAgIGZyYW1lLFxuICAgIHN1YmplY3RcbiAgfTtcbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuXG5jb25zdCB0b0Ryb3BwYWJsZU1hcCA9IG1lbW9pemVPbmUoZHJvcHBhYmxlcyA9PiBkcm9wcGFibGVzLnJlZHVjZSgocHJldmlvdXMsIGN1cnJlbnQpID0+IHtcbiAgcHJldmlvdXNbY3VycmVudC5kZXNjcmlwdG9yLmlkXSA9IGN1cnJlbnQ7XG4gIHJldHVybiBwcmV2aW91cztcbn0sIHt9KSk7XG5jb25zdCB0b0RyYWdnYWJsZU1hcCA9IG1lbW9pemVPbmUoZHJhZ2dhYmxlcyA9PiBkcmFnZ2FibGVzLnJlZHVjZSgocHJldmlvdXMsIGN1cnJlbnQpID0+IHtcbiAgcHJldmlvdXNbY3VycmVudC5kZXNjcmlwdG9yLmlkXSA9IGN1cnJlbnQ7XG4gIHJldHVybiBwcmV2aW91cztcbn0sIHt9KSk7XG5jb25zdCB0b0Ryb3BwYWJsZUxpc3QgPSBtZW1vaXplT25lKGRyb3BwYWJsZXMgPT4gT2JqZWN0LnZhbHVlcyhkcm9wcGFibGVzKSk7XG5jb25zdCB0b0RyYWdnYWJsZUxpc3QgPSBtZW1vaXplT25lKGRyYWdnYWJsZXMgPT4gT2JqZWN0LnZhbHVlcyhkcmFnZ2FibGVzKSk7XG5cbnZhciBnZXREcmFnZ2FibGVzSW5zaWRlRHJvcHBhYmxlID0gbWVtb2l6ZU9uZSgoZHJvcHBhYmxlSWQsIGRyYWdnYWJsZXMpID0+IHtcbiAgY29uc3QgcmVzdWx0ID0gdG9EcmFnZ2FibGVMaXN0KGRyYWdnYWJsZXMpLmZpbHRlcihkcmFnZ2FibGUgPT4gZHJvcHBhYmxlSWQgPT09IGRyYWdnYWJsZS5kZXNjcmlwdG9yLmRyb3BwYWJsZUlkKS5zb3J0KChhLCBiKSA9PiBhLmRlc2NyaXB0b3IuaW5kZXggLSBiLmRlc2NyaXB0b3IuaW5kZXgpO1xuICByZXR1cm4gcmVzdWx0O1xufSk7XG5cbmZ1bmN0aW9uIHRyeUdldERlc3RpbmF0aW9uKGltcGFjdCkge1xuICBpZiAoaW1wYWN0LmF0ICYmIGltcGFjdC5hdC50eXBlID09PSAnUkVPUkRFUicpIHtcbiAgICByZXR1cm4gaW1wYWN0LmF0LmRlc3RpbmF0aW9uO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gdHJ5R2V0Q29tYmluZShpbXBhY3QpIHtcbiAgaWYgKGltcGFjdC5hdCAmJiBpbXBhY3QuYXQudHlwZSA9PT0gJ0NPTUJJTkUnKSB7XG4gICAgcmV0dXJuIGltcGFjdC5hdC5jb21iaW5lO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgcmVtb3ZlRHJhZ2dhYmxlRnJvbUxpc3QgPSBtZW1vaXplT25lKChyZW1vdmUsIGxpc3QpID0+IGxpc3QuZmlsdGVyKGl0ZW0gPT4gaXRlbS5kZXNjcmlwdG9yLmlkICE9PSByZW1vdmUuZGVzY3JpcHRvci5pZCkpO1xuXG52YXIgbW92ZVRvTmV4dENvbWJpbmUgPSAoKHtcbiAgaXNNb3ZpbmdGb3J3YXJkLFxuICBkcmFnZ2FibGUsXG4gIGRlc3RpbmF0aW9uLFxuICBpbnNpZGVEZXN0aW5hdGlvbixcbiAgcHJldmlvdXNJbXBhY3Rcbn0pID0+IHtcbiAgaWYgKCFkZXN0aW5hdGlvbi5pc0NvbWJpbmVFbmFibGVkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgbG9jYXRpb24gPSB0cnlHZXREZXN0aW5hdGlvbihwcmV2aW91c0ltcGFjdCk7XG4gIGlmICghbG9jYXRpb24pIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBnZXRJbXBhY3QodGFyZ2V0KSB7XG4gICAgY29uc3QgYXQgPSB7XG4gICAgICB0eXBlOiAnQ09NQklORScsXG4gICAgICBjb21iaW5lOiB7XG4gICAgICAgIGRyYWdnYWJsZUlkOiB0YXJnZXQsXG4gICAgICAgIGRyb3BwYWJsZUlkOiBkZXN0aW5hdGlvbi5kZXNjcmlwdG9yLmlkXG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4ucHJldmlvdXNJbXBhY3QsXG4gICAgICBhdFxuICAgIH07XG4gIH1cbiAgY29uc3QgYWxsID0gcHJldmlvdXNJbXBhY3QuZGlzcGxhY2VkLmFsbDtcbiAgY29uc3QgY2xvc2VzdElkID0gYWxsLmxlbmd0aCA/IGFsbFswXSA6IG51bGw7XG4gIGlmIChpc01vdmluZ0ZvcndhcmQpIHtcbiAgICByZXR1cm4gY2xvc2VzdElkID8gZ2V0SW1wYWN0KGNsb3Nlc3RJZCkgOiBudWxsO1xuICB9XG4gIGNvbnN0IHdpdGhvdXREcmFnZ2FibGUgPSByZW1vdmVEcmFnZ2FibGVGcm9tTGlzdChkcmFnZ2FibGUsIGluc2lkZURlc3RpbmF0aW9uKTtcbiAgaWYgKCFjbG9zZXN0SWQpIHtcbiAgICBpZiAoIXdpdGhvdXREcmFnZ2FibGUubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgbGFzdCA9IHdpdGhvdXREcmFnZ2FibGVbd2l0aG91dERyYWdnYWJsZS5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gZ2V0SW1wYWN0KGxhc3QuZGVzY3JpcHRvci5pZCk7XG4gIH1cbiAgY29uc3QgaW5kZXhPZkNsb3Nlc3QgPSB3aXRob3V0RHJhZ2dhYmxlLmZpbmRJbmRleChkID0+IGQuZGVzY3JpcHRvci5pZCA9PT0gY2xvc2VzdElkKTtcbiAgIShpbmRleE9mQ2xvc2VzdCAhPT0gLTEpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ291bGQgbm90IGZpbmQgZGlzcGxhY2VkIGl0ZW0gaW4gc2V0JykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICBjb25zdCBwcm9wb3NlZEluZGV4ID0gaW5kZXhPZkNsb3Nlc3QgLSAxO1xuICBpZiAocHJvcG9zZWRJbmRleCA8IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBiZWZvcmUgPSB3aXRob3V0RHJhZ2dhYmxlW3Byb3Bvc2VkSW5kZXhdO1xuICByZXR1cm4gZ2V0SW1wYWN0KGJlZm9yZS5kZXNjcmlwdG9yLmlkKTtcbn0pO1xuXG52YXIgaXNIb21lT2YgPSAoKGRyYWdnYWJsZSwgZGVzdGluYXRpb24pID0+IGRyYWdnYWJsZS5kZXNjcmlwdG9yLmRyb3BwYWJsZUlkID09PSBkZXN0aW5hdGlvbi5kZXNjcmlwdG9yLmlkKTtcblxuY29uc3Qgbm9EaXNwbGFjZWRCeSA9IHtcbiAgcG9pbnQ6IG9yaWdpbixcbiAgdmFsdWU6IDBcbn07XG5jb25zdCBlbXB0eUdyb3VwcyA9IHtcbiAgaW52aXNpYmxlOiB7fSxcbiAgdmlzaWJsZToge30sXG4gIGFsbDogW11cbn07XG5jb25zdCBub0ltcGFjdCA9IHtcbiAgZGlzcGxhY2VkOiBlbXB0eUdyb3VwcyxcbiAgZGlzcGxhY2VkQnk6IG5vRGlzcGxhY2VkQnksXG4gIGF0OiBudWxsXG59O1xudmFyIG5vSW1wYWN0JDEgPSBub0ltcGFjdDtcblxudmFyIGlzV2l0aGluID0gKChsb3dlckJvdW5kLCB1cHBlckJvdW5kKSA9PiB2YWx1ZSA9PiBsb3dlckJvdW5kIDw9IHZhbHVlICYmIHZhbHVlIDw9IHVwcGVyQm91bmQpO1xuXG52YXIgaXNQYXJ0aWFsbHlWaXNpYmxlVGhyb3VnaEZyYW1lID0gKGZyYW1lID0+IHtcbiAgY29uc3QgaXNXaXRoaW5WZXJ0aWNhbCA9IGlzV2l0aGluKGZyYW1lLnRvcCwgZnJhbWUuYm90dG9tKTtcbiAgY29uc3QgaXNXaXRoaW5Ib3Jpem9udGFsID0gaXNXaXRoaW4oZnJhbWUubGVmdCwgZnJhbWUucmlnaHQpO1xuICByZXR1cm4gc3ViamVjdCA9PiB7XG4gICAgY29uc3QgaXNDb250YWluZWQgPSBpc1dpdGhpblZlcnRpY2FsKHN1YmplY3QudG9wKSAmJiBpc1dpdGhpblZlcnRpY2FsKHN1YmplY3QuYm90dG9tKSAmJiBpc1dpdGhpbkhvcml6b250YWwoc3ViamVjdC5sZWZ0KSAmJiBpc1dpdGhpbkhvcml6b250YWwoc3ViamVjdC5yaWdodCk7XG4gICAgaWYgKGlzQ29udGFpbmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgaXNQYXJ0aWFsbHlWaXNpYmxlVmVydGljYWxseSA9IGlzV2l0aGluVmVydGljYWwoc3ViamVjdC50b3ApIHx8IGlzV2l0aGluVmVydGljYWwoc3ViamVjdC5ib3R0b20pO1xuICAgIGNvbnN0IGlzUGFydGlhbGx5VmlzaWJsZUhvcml6b250YWxseSA9IGlzV2l0aGluSG9yaXpvbnRhbChzdWJqZWN0LmxlZnQpIHx8IGlzV2l0aGluSG9yaXpvbnRhbChzdWJqZWN0LnJpZ2h0KTtcbiAgICBjb25zdCBpc1BhcnRpYWxseUNvbnRhaW5lZCA9IGlzUGFydGlhbGx5VmlzaWJsZVZlcnRpY2FsbHkgJiYgaXNQYXJ0aWFsbHlWaXNpYmxlSG9yaXpvbnRhbGx5O1xuICAgIGlmIChpc1BhcnRpYWxseUNvbnRhaW5lZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGlzQmlnZ2VyVmVydGljYWxseSA9IHN1YmplY3QudG9wIDwgZnJhbWUudG9wICYmIHN1YmplY3QuYm90dG9tID4gZnJhbWUuYm90dG9tO1xuICAgIGNvbnN0IGlzQmlnZ2VySG9yaXpvbnRhbGx5ID0gc3ViamVjdC5sZWZ0IDwgZnJhbWUubGVmdCAmJiBzdWJqZWN0LnJpZ2h0ID4gZnJhbWUucmlnaHQ7XG4gICAgY29uc3QgaXNUYXJnZXRCaWdnZXJUaGFuRnJhbWUgPSBpc0JpZ2dlclZlcnRpY2FsbHkgJiYgaXNCaWdnZXJIb3Jpem9udGFsbHk7XG4gICAgaWYgKGlzVGFyZ2V0QmlnZ2VyVGhhbkZyYW1lKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgaXNUYXJnZXRCaWdnZXJPbk9uZUF4aXMgPSBpc0JpZ2dlclZlcnRpY2FsbHkgJiYgaXNQYXJ0aWFsbHlWaXNpYmxlSG9yaXpvbnRhbGx5IHx8IGlzQmlnZ2VySG9yaXpvbnRhbGx5ICYmIGlzUGFydGlhbGx5VmlzaWJsZVZlcnRpY2FsbHk7XG4gICAgcmV0dXJuIGlzVGFyZ2V0QmlnZ2VyT25PbmVBeGlzO1xuICB9O1xufSk7XG5cbnZhciBpc1RvdGFsbHlWaXNpYmxlVGhyb3VnaEZyYW1lID0gKGZyYW1lID0+IHtcbiAgY29uc3QgaXNXaXRoaW5WZXJ0aWNhbCA9IGlzV2l0aGluKGZyYW1lLnRvcCwgZnJhbWUuYm90dG9tKTtcbiAgY29uc3QgaXNXaXRoaW5Ib3Jpem9udGFsID0gaXNXaXRoaW4oZnJhbWUubGVmdCwgZnJhbWUucmlnaHQpO1xuICByZXR1cm4gc3ViamVjdCA9PiB7XG4gICAgY29uc3QgaXNDb250YWluZWQgPSBpc1dpdGhpblZlcnRpY2FsKHN1YmplY3QudG9wKSAmJiBpc1dpdGhpblZlcnRpY2FsKHN1YmplY3QuYm90dG9tKSAmJiBpc1dpdGhpbkhvcml6b250YWwoc3ViamVjdC5sZWZ0KSAmJiBpc1dpdGhpbkhvcml6b250YWwoc3ViamVjdC5yaWdodCk7XG4gICAgcmV0dXJuIGlzQ29udGFpbmVkO1xuICB9O1xufSk7XG5cbmNvbnN0IHZlcnRpY2FsID0ge1xuICBkaXJlY3Rpb246ICd2ZXJ0aWNhbCcsXG4gIGxpbmU6ICd5JyxcbiAgY3Jvc3NBeGlzTGluZTogJ3gnLFxuICBzdGFydDogJ3RvcCcsXG4gIGVuZDogJ2JvdHRvbScsXG4gIHNpemU6ICdoZWlnaHQnLFxuICBjcm9zc0F4aXNTdGFydDogJ2xlZnQnLFxuICBjcm9zc0F4aXNFbmQ6ICdyaWdodCcsXG4gIGNyb3NzQXhpc1NpemU6ICd3aWR0aCdcbn07XG5jb25zdCBob3Jpem9udGFsID0ge1xuICBkaXJlY3Rpb246ICdob3Jpem9udGFsJyxcbiAgbGluZTogJ3gnLFxuICBjcm9zc0F4aXNMaW5lOiAneScsXG4gIHN0YXJ0OiAnbGVmdCcsXG4gIGVuZDogJ3JpZ2h0JyxcbiAgc2l6ZTogJ3dpZHRoJyxcbiAgY3Jvc3NBeGlzU3RhcnQ6ICd0b3AnLFxuICBjcm9zc0F4aXNFbmQ6ICdib3R0b20nLFxuICBjcm9zc0F4aXNTaXplOiAnaGVpZ2h0J1xufTtcblxudmFyIGlzVG90YWxseVZpc2libGVUaHJvdWdoRnJhbWVPbkF4aXMgPSAoYXhpcyA9PiBmcmFtZSA9PiB7XG4gIGNvbnN0IGlzV2l0aGluVmVydGljYWwgPSBpc1dpdGhpbihmcmFtZS50b3AsIGZyYW1lLmJvdHRvbSk7XG4gIGNvbnN0IGlzV2l0aGluSG9yaXpvbnRhbCA9IGlzV2l0aGluKGZyYW1lLmxlZnQsIGZyYW1lLnJpZ2h0KTtcbiAgcmV0dXJuIHN1YmplY3QgPT4ge1xuICAgIGlmIChheGlzID09PSB2ZXJ0aWNhbCkge1xuICAgICAgcmV0dXJuIGlzV2l0aGluVmVydGljYWwoc3ViamVjdC50b3ApICYmIGlzV2l0aGluVmVydGljYWwoc3ViamVjdC5ib3R0b20pO1xuICAgIH1cbiAgICByZXR1cm4gaXNXaXRoaW5Ib3Jpem9udGFsKHN1YmplY3QubGVmdCkgJiYgaXNXaXRoaW5Ib3Jpem9udGFsKHN1YmplY3QucmlnaHQpO1xuICB9O1xufSk7XG5cbmNvbnN0IGdldERyb3BwYWJsZURpc3BsYWNlZCA9ICh0YXJnZXQsIGRlc3RpbmF0aW9uKSA9PiB7XG4gIGNvbnN0IGRpc3BsYWNlbWVudCA9IGRlc3RpbmF0aW9uLmZyYW1lID8gZGVzdGluYXRpb24uZnJhbWUuc2Nyb2xsLmRpZmYuZGlzcGxhY2VtZW50IDogb3JpZ2luO1xuICByZXR1cm4gb2Zmc2V0QnlQb3NpdGlvbih0YXJnZXQsIGRpc3BsYWNlbWVudCk7XG59O1xuY29uc3QgaXNWaXNpYmxlSW5Ecm9wcGFibGUgPSAodGFyZ2V0LCBkZXN0aW5hdGlvbiwgaXNWaXNpYmxlVGhyb3VnaEZyYW1lRm4pID0+IHtcbiAgaWYgKCFkZXN0aW5hdGlvbi5zdWJqZWN0LmFjdGl2ZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gaXNWaXNpYmxlVGhyb3VnaEZyYW1lRm4oZGVzdGluYXRpb24uc3ViamVjdC5hY3RpdmUpKHRhcmdldCk7XG59O1xuY29uc3QgaXNWaXNpYmxlSW5WaWV3cG9ydCA9ICh0YXJnZXQsIHZpZXdwb3J0LCBpc1Zpc2libGVUaHJvdWdoRnJhbWVGbikgPT4gaXNWaXNpYmxlVGhyb3VnaEZyYW1lRm4odmlld3BvcnQpKHRhcmdldCk7XG5jb25zdCBpc1Zpc2libGUkMSA9ICh7XG4gIHRhcmdldDogdG9CZURpc3BsYWNlZCxcbiAgZGVzdGluYXRpb24sXG4gIHZpZXdwb3J0LFxuICB3aXRoRHJvcHBhYmxlRGlzcGxhY2VtZW50LFxuICBpc1Zpc2libGVUaHJvdWdoRnJhbWVGblxufSkgPT4ge1xuICBjb25zdCBkaXNwbGFjZWRUYXJnZXQgPSB3aXRoRHJvcHBhYmxlRGlzcGxhY2VtZW50ID8gZ2V0RHJvcHBhYmxlRGlzcGxhY2VkKHRvQmVEaXNwbGFjZWQsIGRlc3RpbmF0aW9uKSA6IHRvQmVEaXNwbGFjZWQ7XG4gIHJldHVybiBpc1Zpc2libGVJbkRyb3BwYWJsZShkaXNwbGFjZWRUYXJnZXQsIGRlc3RpbmF0aW9uLCBpc1Zpc2libGVUaHJvdWdoRnJhbWVGbikgJiYgaXNWaXNpYmxlSW5WaWV3cG9ydChkaXNwbGFjZWRUYXJnZXQsIHZpZXdwb3J0LCBpc1Zpc2libGVUaHJvdWdoRnJhbWVGbik7XG59O1xuY29uc3QgaXNQYXJ0aWFsbHlWaXNpYmxlID0gYXJncyA9PiBpc1Zpc2libGUkMSh7XG4gIC4uLmFyZ3MsXG4gIGlzVmlzaWJsZVRocm91Z2hGcmFtZUZuOiBpc1BhcnRpYWxseVZpc2libGVUaHJvdWdoRnJhbWVcbn0pO1xuY29uc3QgaXNUb3RhbGx5VmlzaWJsZSA9IGFyZ3MgPT4gaXNWaXNpYmxlJDEoe1xuICAuLi5hcmdzLFxuICBpc1Zpc2libGVUaHJvdWdoRnJhbWVGbjogaXNUb3RhbGx5VmlzaWJsZVRocm91Z2hGcmFtZVxufSk7XG5jb25zdCBpc1RvdGFsbHlWaXNpYmxlT25BeGlzID0gYXJncyA9PiBpc1Zpc2libGUkMSh7XG4gIC4uLmFyZ3MsXG4gIGlzVmlzaWJsZVRocm91Z2hGcmFtZUZuOiBpc1RvdGFsbHlWaXNpYmxlVGhyb3VnaEZyYW1lT25BeGlzKGFyZ3MuZGVzdGluYXRpb24uYXhpcylcbn0pO1xuXG5jb25zdCBnZXRTaG91bGRBbmltYXRlID0gKGlkLCBsYXN0LCBmb3JjZVNob3VsZEFuaW1hdGUpID0+IHtcbiAgaWYgKHR5cGVvZiBmb3JjZVNob3VsZEFuaW1hdGUgPT09ICdib29sZWFuJykge1xuICAgIHJldHVybiBmb3JjZVNob3VsZEFuaW1hdGU7XG4gIH1cbiAgaWYgKCFsYXN0KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3Qge1xuICAgIGludmlzaWJsZSxcbiAgICB2aXNpYmxlXG4gIH0gPSBsYXN0O1xuICBpZiAoaW52aXNpYmxlW2lkXSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBwcmV2aW91cyA9IHZpc2libGVbaWRdO1xuICByZXR1cm4gcHJldmlvdXMgPyBwcmV2aW91cy5zaG91bGRBbmltYXRlIDogdHJ1ZTtcbn07XG5mdW5jdGlvbiBnZXRUYXJnZXQoZHJhZ2dhYmxlLCBkaXNwbGFjZWRCeSkge1xuICBjb25zdCBtYXJnaW5Cb3ggPSBkcmFnZ2FibGUucGFnZS5tYXJnaW5Cb3g7XG4gIGNvbnN0IGV4cGFuZEJ5ID0ge1xuICAgIHRvcDogZGlzcGxhY2VkQnkucG9pbnQueSxcbiAgICByaWdodDogMCxcbiAgICBib3R0b206IDAsXG4gICAgbGVmdDogZGlzcGxhY2VkQnkucG9pbnQueFxuICB9O1xuICByZXR1cm4gZ2V0UmVjdChleHBhbmQobWFyZ2luQm94LCBleHBhbmRCeSkpO1xufVxuZnVuY3Rpb24gZ2V0RGlzcGxhY2VtZW50R3JvdXBzKHtcbiAgYWZ0ZXJEcmFnZ2luZyxcbiAgZGVzdGluYXRpb24sXG4gIGRpc3BsYWNlZEJ5LFxuICB2aWV3cG9ydCxcbiAgZm9yY2VTaG91bGRBbmltYXRlLFxuICBsYXN0XG59KSB7XG4gIHJldHVybiBhZnRlckRyYWdnaW5nLnJlZHVjZShmdW5jdGlvbiBwcm9jZXNzKGdyb3VwcywgZHJhZ2dhYmxlKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gZ2V0VGFyZ2V0KGRyYWdnYWJsZSwgZGlzcGxhY2VkQnkpO1xuICAgIGNvbnN0IGlkID0gZHJhZ2dhYmxlLmRlc2NyaXB0b3IuaWQ7XG4gICAgZ3JvdXBzLmFsbC5wdXNoKGlkKTtcbiAgICBjb25zdCBpc1Zpc2libGUgPSBpc1BhcnRpYWxseVZpc2libGUoe1xuICAgICAgdGFyZ2V0LFxuICAgICAgZGVzdGluYXRpb24sXG4gICAgICB2aWV3cG9ydCxcbiAgICAgIHdpdGhEcm9wcGFibGVEaXNwbGFjZW1lbnQ6IHRydWVcbiAgICB9KTtcbiAgICBpZiAoIWlzVmlzaWJsZSkge1xuICAgICAgZ3JvdXBzLmludmlzaWJsZVtkcmFnZ2FibGUuZGVzY3JpcHRvci5pZF0gPSB0cnVlO1xuICAgICAgcmV0dXJuIGdyb3VwcztcbiAgICB9XG4gICAgY29uc3Qgc2hvdWxkQW5pbWF0ZSA9IGdldFNob3VsZEFuaW1hdGUoaWQsIGxhc3QsIGZvcmNlU2hvdWxkQW5pbWF0ZSk7XG4gICAgY29uc3QgZGlzcGxhY2VtZW50ID0ge1xuICAgICAgZHJhZ2dhYmxlSWQ6IGlkLFxuICAgICAgc2hvdWxkQW5pbWF0ZVxuICAgIH07XG4gICAgZ3JvdXBzLnZpc2libGVbaWRdID0gZGlzcGxhY2VtZW50O1xuICAgIHJldHVybiBncm91cHM7XG4gIH0sIHtcbiAgICBhbGw6IFtdLFxuICAgIHZpc2libGU6IHt9LFxuICAgIGludmlzaWJsZToge31cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldEluZGV4T2ZMYXN0SXRlbShkcmFnZ2FibGVzLCBvcHRpb25zKSB7XG4gIGlmICghZHJhZ2dhYmxlcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBjb25zdCBpbmRleE9mTGFzdEl0ZW0gPSBkcmFnZ2FibGVzW2RyYWdnYWJsZXMubGVuZ3RoIC0gMV0uZGVzY3JpcHRvci5pbmRleDtcbiAgcmV0dXJuIG9wdGlvbnMuaW5Ib21lTGlzdCA/IGluZGV4T2ZMYXN0SXRlbSA6IGluZGV4T2ZMYXN0SXRlbSArIDE7XG59XG5mdW5jdGlvbiBnb0F0RW5kKHtcbiAgaW5zaWRlRGVzdGluYXRpb24sXG4gIGluSG9tZUxpc3QsXG4gIGRpc3BsYWNlZEJ5LFxuICBkZXN0aW5hdGlvblxufSkge1xuICBjb25zdCBuZXdJbmRleCA9IGdldEluZGV4T2ZMYXN0SXRlbShpbnNpZGVEZXN0aW5hdGlvbiwge1xuICAgIGluSG9tZUxpc3RcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgZGlzcGxhY2VkOiBlbXB0eUdyb3VwcyxcbiAgICBkaXNwbGFjZWRCeSxcbiAgICBhdDoge1xuICAgICAgdHlwZTogJ1JFT1JERVInLFxuICAgICAgZGVzdGluYXRpb246IHtcbiAgICAgICAgZHJvcHBhYmxlSWQ6IGRlc3RpbmF0aW9uLmRlc2NyaXB0b3IuaWQsXG4gICAgICAgIGluZGV4OiBuZXdJbmRleFxuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZVJlb3JkZXJJbXBhY3Qoe1xuICBkcmFnZ2FibGUsXG4gIGluc2lkZURlc3RpbmF0aW9uLFxuICBkZXN0aW5hdGlvbixcbiAgdmlld3BvcnQsXG4gIGRpc3BsYWNlZEJ5LFxuICBsYXN0LFxuICBpbmRleCxcbiAgZm9yY2VTaG91bGRBbmltYXRlXG59KSB7XG4gIGNvbnN0IGluSG9tZUxpc3QgPSBpc0hvbWVPZihkcmFnZ2FibGUsIGRlc3RpbmF0aW9uKTtcbiAgaWYgKGluZGV4ID09IG51bGwpIHtcbiAgICByZXR1cm4gZ29BdEVuZCh7XG4gICAgICBpbnNpZGVEZXN0aW5hdGlvbixcbiAgICAgIGluSG9tZUxpc3QsXG4gICAgICBkaXNwbGFjZWRCeSxcbiAgICAgIGRlc3RpbmF0aW9uXG4gICAgfSk7XG4gIH1cbiAgY29uc3QgbWF0Y2ggPSBpbnNpZGVEZXN0aW5hdGlvbi5maW5kKGl0ZW0gPT4gaXRlbS5kZXNjcmlwdG9yLmluZGV4ID09PSBpbmRleCk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm4gZ29BdEVuZCh7XG4gICAgICBpbnNpZGVEZXN0aW5hdGlvbixcbiAgICAgIGluSG9tZUxpc3QsXG4gICAgICBkaXNwbGFjZWRCeSxcbiAgICAgIGRlc3RpbmF0aW9uXG4gICAgfSk7XG4gIH1cbiAgY29uc3Qgd2l0aG91dERyYWdnaW5nID0gcmVtb3ZlRHJhZ2dhYmxlRnJvbUxpc3QoZHJhZ2dhYmxlLCBpbnNpZGVEZXN0aW5hdGlvbik7XG4gIGNvbnN0IHNsaWNlRnJvbSA9IGluc2lkZURlc3RpbmF0aW9uLmluZGV4T2YobWF0Y2gpO1xuICBjb25zdCBpbXBhY3RlZCA9IHdpdGhvdXREcmFnZ2luZy5zbGljZShzbGljZUZyb20pO1xuICBjb25zdCBkaXNwbGFjZWQgPSBnZXREaXNwbGFjZW1lbnRHcm91cHMoe1xuICAgIGFmdGVyRHJhZ2dpbmc6IGltcGFjdGVkLFxuICAgIGRlc3RpbmF0aW9uLFxuICAgIGRpc3BsYWNlZEJ5LFxuICAgIGxhc3QsXG4gICAgdmlld3BvcnQ6IHZpZXdwb3J0LmZyYW1lLFxuICAgIGZvcmNlU2hvdWxkQW5pbWF0ZVxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBkaXNwbGFjZWQsXG4gICAgZGlzcGxhY2VkQnksXG4gICAgYXQ6IHtcbiAgICAgIHR5cGU6ICdSRU9SREVSJyxcbiAgICAgIGRlc3RpbmF0aW9uOiB7XG4gICAgICAgIGRyb3BwYWJsZUlkOiBkZXN0aW5hdGlvbi5kZXNjcmlwdG9yLmlkLFxuICAgICAgICBpbmRleFxuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gZGlkU3RhcnRBZnRlckNyaXRpY2FsKGRyYWdnYWJsZUlkLCBhZnRlckNyaXRpY2FsKSB7XG4gIHJldHVybiBCb29sZWFuKGFmdGVyQ3JpdGljYWwuZWZmZWN0ZWRbZHJhZ2dhYmxlSWRdKTtcbn1cblxudmFyIGZyb21Db21iaW5lID0gKCh7XG4gIGlzTW92aW5nRm9yd2FyZCxcbiAgZGVzdGluYXRpb24sXG4gIGRyYWdnYWJsZXMsXG4gIGNvbWJpbmUsXG4gIGFmdGVyQ3JpdGljYWxcbn0pID0+IHtcbiAgaWYgKCFkZXN0aW5hdGlvbi5pc0NvbWJpbmVFbmFibGVkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgY29tYmluZUlkID0gY29tYmluZS5kcmFnZ2FibGVJZDtcbiAgY29uc3QgY29tYmluZVdpdGggPSBkcmFnZ2FibGVzW2NvbWJpbmVJZF07XG4gIGNvbnN0IGNvbWJpbmVXaXRoSW5kZXggPSBjb21iaW5lV2l0aC5kZXNjcmlwdG9yLmluZGV4O1xuICBjb25zdCBkaWRDb21iaW5lV2l0aFN0YXJ0QWZ0ZXJDcml0aWNhbCA9IGRpZFN0YXJ0QWZ0ZXJDcml0aWNhbChjb21iaW5lSWQsIGFmdGVyQ3JpdGljYWwpO1xuICBpZiAoZGlkQ29tYmluZVdpdGhTdGFydEFmdGVyQ3JpdGljYWwpIHtcbiAgICBpZiAoaXNNb3ZpbmdGb3J3YXJkKSB7XG4gICAgICByZXR1cm4gY29tYmluZVdpdGhJbmRleDtcbiAgICB9XG4gICAgcmV0dXJuIGNvbWJpbmVXaXRoSW5kZXggLSAxO1xuICB9XG4gIGlmIChpc01vdmluZ0ZvcndhcmQpIHtcbiAgICByZXR1cm4gY29tYmluZVdpdGhJbmRleCArIDE7XG4gIH1cbiAgcmV0dXJuIGNvbWJpbmVXaXRoSW5kZXg7XG59KTtcblxudmFyIGZyb21SZW9yZGVyID0gKCh7XG4gIGlzTW92aW5nRm9yd2FyZCxcbiAgaXNJbkhvbWVMaXN0LFxuICBpbnNpZGVEZXN0aW5hdGlvbixcbiAgbG9jYXRpb25cbn0pID0+IHtcbiAgaWYgKCFpbnNpZGVEZXN0aW5hdGlvbi5sZW5ndGgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBjdXJyZW50SW5kZXggPSBsb2NhdGlvbi5pbmRleDtcbiAgY29uc3QgcHJvcG9zZWRJbmRleCA9IGlzTW92aW5nRm9yd2FyZCA/IGN1cnJlbnRJbmRleCArIDEgOiBjdXJyZW50SW5kZXggLSAxO1xuICBjb25zdCBmaXJzdEluZGV4ID0gaW5zaWRlRGVzdGluYXRpb25bMF0uZGVzY3JpcHRvci5pbmRleDtcbiAgY29uc3QgbGFzdEluZGV4ID0gaW5zaWRlRGVzdGluYXRpb25baW5zaWRlRGVzdGluYXRpb24ubGVuZ3RoIC0gMV0uZGVzY3JpcHRvci5pbmRleDtcbiAgY29uc3QgdXBwZXJCb3VuZCA9IGlzSW5Ib21lTGlzdCA/IGxhc3RJbmRleCA6IGxhc3RJbmRleCArIDE7XG4gIGlmIChwcm9wb3NlZEluZGV4IDwgZmlyc3RJbmRleCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChwcm9wb3NlZEluZGV4ID4gdXBwZXJCb3VuZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBwcm9wb3NlZEluZGV4O1xufSk7XG5cbnZhciBtb3ZlVG9OZXh0SW5kZXggPSAoKHtcbiAgaXNNb3ZpbmdGb3J3YXJkLFxuICBpc0luSG9tZUxpc3QsXG4gIGRyYWdnYWJsZSxcbiAgZHJhZ2dhYmxlcyxcbiAgZGVzdGluYXRpb24sXG4gIGluc2lkZURlc3RpbmF0aW9uLFxuICBwcmV2aW91c0ltcGFjdCxcbiAgdmlld3BvcnQsXG4gIGFmdGVyQ3JpdGljYWxcbn0pID0+IHtcbiAgY29uc3Qgd2FzQXQgPSBwcmV2aW91c0ltcGFjdC5hdDtcbiAgIXdhc0F0ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IG1vdmUgaW4gZGlyZWN0aW9uIHdpdGhvdXQgcHJldmlvdXMgaW1wYWN0IGxvY2F0aW9uJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICBpZiAod2FzQXQudHlwZSA9PT0gJ1JFT1JERVInKSB7XG4gICAgY29uc3QgbmV3SW5kZXggPSBmcm9tUmVvcmRlcih7XG4gICAgICBpc01vdmluZ0ZvcndhcmQsXG4gICAgICBpc0luSG9tZUxpc3QsXG4gICAgICBsb2NhdGlvbjogd2FzQXQuZGVzdGluYXRpb24sXG4gICAgICBpbnNpZGVEZXN0aW5hdGlvblxuICAgIH0pO1xuICAgIGlmIChuZXdJbmRleCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNhbGN1bGF0ZVJlb3JkZXJJbXBhY3Qoe1xuICAgICAgZHJhZ2dhYmxlLFxuICAgICAgaW5zaWRlRGVzdGluYXRpb24sXG4gICAgICBkZXN0aW5hdGlvbixcbiAgICAgIHZpZXdwb3J0LFxuICAgICAgbGFzdDogcHJldmlvdXNJbXBhY3QuZGlzcGxhY2VkLFxuICAgICAgZGlzcGxhY2VkQnk6IHByZXZpb3VzSW1wYWN0LmRpc3BsYWNlZEJ5LFxuICAgICAgaW5kZXg6IG5ld0luZGV4XG4gICAgfSk7XG4gIH1cbiAgY29uc3QgbmV3SW5kZXggPSBmcm9tQ29tYmluZSh7XG4gICAgaXNNb3ZpbmdGb3J3YXJkLFxuICAgIGRlc3RpbmF0aW9uLFxuICAgIGRpc3BsYWNlZDogcHJldmlvdXNJbXBhY3QuZGlzcGxhY2VkLFxuICAgIGRyYWdnYWJsZXMsXG4gICAgY29tYmluZTogd2FzQXQuY29tYmluZSxcbiAgICBhZnRlckNyaXRpY2FsXG4gIH0pO1xuICBpZiAobmV3SW5kZXggPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBjYWxjdWxhdGVSZW9yZGVySW1wYWN0KHtcbiAgICBkcmFnZ2FibGUsXG4gICAgaW5zaWRlRGVzdGluYXRpb24sXG4gICAgZGVzdGluYXRpb24sXG4gICAgdmlld3BvcnQsXG4gICAgbGFzdDogcHJldmlvdXNJbXBhY3QuZGlzcGxhY2VkLFxuICAgIGRpc3BsYWNlZEJ5OiBwcmV2aW91c0ltcGFjdC5kaXNwbGFjZWRCeSxcbiAgICBpbmRleDogbmV3SW5kZXhcbiAgfSk7XG59KTtcblxudmFyIGdldENvbWJpbmVkSXRlbURpc3BsYWNlbWVudCA9ICgoe1xuICBkaXNwbGFjZWQsXG4gIGFmdGVyQ3JpdGljYWwsXG4gIGNvbWJpbmVXaXRoLFxuICBkaXNwbGFjZWRCeVxufSkgPT4ge1xuICBjb25zdCBpc0Rpc3BsYWNlZCA9IEJvb2xlYW4oZGlzcGxhY2VkLnZpc2libGVbY29tYmluZVdpdGhdIHx8IGRpc3BsYWNlZC5pbnZpc2libGVbY29tYmluZVdpdGhdKTtcbiAgaWYgKGRpZFN0YXJ0QWZ0ZXJDcml0aWNhbChjb21iaW5lV2l0aCwgYWZ0ZXJDcml0aWNhbCkpIHtcbiAgICByZXR1cm4gaXNEaXNwbGFjZWQgPyBvcmlnaW4gOiBuZWdhdGUoZGlzcGxhY2VkQnkucG9pbnQpO1xuICB9XG4gIHJldHVybiBpc0Rpc3BsYWNlZCA/IGRpc3BsYWNlZEJ5LnBvaW50IDogb3JpZ2luO1xufSk7XG5cbnZhciB3aGVuQ29tYmluaW5nID0gKCh7XG4gIGFmdGVyQ3JpdGljYWwsXG4gIGltcGFjdCxcbiAgZHJhZ2dhYmxlc1xufSkgPT4ge1xuICBjb25zdCBjb21iaW5lID0gdHJ5R2V0Q29tYmluZShpbXBhY3QpO1xuICAhY29tYmluZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICBjb25zdCBjb21iaW5lV2l0aCA9IGNvbWJpbmUuZHJhZ2dhYmxlSWQ7XG4gIGNvbnN0IGNlbnRlciA9IGRyYWdnYWJsZXNbY29tYmluZVdpdGhdLnBhZ2UuYm9yZGVyQm94LmNlbnRlcjtcbiAgY29uc3QgZGlzcGxhY2VCeSA9IGdldENvbWJpbmVkSXRlbURpc3BsYWNlbWVudCh7XG4gICAgZGlzcGxhY2VkOiBpbXBhY3QuZGlzcGxhY2VkLFxuICAgIGFmdGVyQ3JpdGljYWwsXG4gICAgY29tYmluZVdpdGgsXG4gICAgZGlzcGxhY2VkQnk6IGltcGFjdC5kaXNwbGFjZWRCeVxuICB9KTtcbiAgcmV0dXJuIGFkZChjZW50ZXIsIGRpc3BsYWNlQnkpO1xufSk7XG5cbmNvbnN0IGRpc3RhbmNlRnJvbVN0YXJ0VG9Cb3JkZXJCb3hDZW50ZXIgPSAoYXhpcywgYm94KSA9PiBib3gubWFyZ2luW2F4aXMuc3RhcnRdICsgYm94LmJvcmRlckJveFtheGlzLnNpemVdIC8gMjtcbmNvbnN0IGRpc3RhbmNlRnJvbUVuZFRvQm9yZGVyQm94Q2VudGVyID0gKGF4aXMsIGJveCkgPT4gYm94Lm1hcmdpbltheGlzLmVuZF0gKyBib3guYm9yZGVyQm94W2F4aXMuc2l6ZV0gLyAyO1xuY29uc3QgZ2V0Q3Jvc3NBeGlzQm9yZGVyQm94Q2VudGVyID0gKGF4aXMsIHRhcmdldCwgaXNNb3ZpbmcpID0+IHRhcmdldFtheGlzLmNyb3NzQXhpc1N0YXJ0XSArIGlzTW92aW5nLm1hcmdpbltheGlzLmNyb3NzQXhpc1N0YXJ0XSArIGlzTW92aW5nLmJvcmRlckJveFtheGlzLmNyb3NzQXhpc1NpemVdIC8gMjtcbmNvbnN0IGdvQWZ0ZXIgPSAoe1xuICBheGlzLFxuICBtb3ZlUmVsYXRpdmVUbyxcbiAgaXNNb3Zpbmdcbn0pID0+IHBhdGNoKGF4aXMubGluZSwgbW92ZVJlbGF0aXZlVG8ubWFyZ2luQm94W2F4aXMuZW5kXSArIGRpc3RhbmNlRnJvbVN0YXJ0VG9Cb3JkZXJCb3hDZW50ZXIoYXhpcywgaXNNb3ZpbmcpLCBnZXRDcm9zc0F4aXNCb3JkZXJCb3hDZW50ZXIoYXhpcywgbW92ZVJlbGF0aXZlVG8ubWFyZ2luQm94LCBpc01vdmluZykpO1xuY29uc3QgZ29CZWZvcmUgPSAoe1xuICBheGlzLFxuICBtb3ZlUmVsYXRpdmVUbyxcbiAgaXNNb3Zpbmdcbn0pID0+IHBhdGNoKGF4aXMubGluZSwgbW92ZVJlbGF0aXZlVG8ubWFyZ2luQm94W2F4aXMuc3RhcnRdIC0gZGlzdGFuY2VGcm9tRW5kVG9Cb3JkZXJCb3hDZW50ZXIoYXhpcywgaXNNb3ZpbmcpLCBnZXRDcm9zc0F4aXNCb3JkZXJCb3hDZW50ZXIoYXhpcywgbW92ZVJlbGF0aXZlVG8ubWFyZ2luQm94LCBpc01vdmluZykpO1xuY29uc3QgZ29JbnRvU3RhcnQgPSAoe1xuICBheGlzLFxuICBtb3ZlSW50byxcbiAgaXNNb3Zpbmdcbn0pID0+IHBhdGNoKGF4aXMubGluZSwgbW92ZUludG8uY29udGVudEJveFtheGlzLnN0YXJ0XSArIGRpc3RhbmNlRnJvbVN0YXJ0VG9Cb3JkZXJCb3hDZW50ZXIoYXhpcywgaXNNb3ZpbmcpLCBnZXRDcm9zc0F4aXNCb3JkZXJCb3hDZW50ZXIoYXhpcywgbW92ZUludG8uY29udGVudEJveCwgaXNNb3ZpbmcpKTtcblxudmFyIHdoZW5SZW9yZGVyaW5nID0gKCh7XG4gIGltcGFjdCxcbiAgZHJhZ2dhYmxlLFxuICBkcmFnZ2FibGVzLFxuICBkcm9wcGFibGUsXG4gIGFmdGVyQ3JpdGljYWxcbn0pID0+IHtcbiAgY29uc3QgaW5zaWRlRGVzdGluYXRpb24gPSBnZXREcmFnZ2FibGVzSW5zaWRlRHJvcHBhYmxlKGRyb3BwYWJsZS5kZXNjcmlwdG9yLmlkLCBkcmFnZ2FibGVzKTtcbiAgY29uc3QgZHJhZ2dhYmxlUGFnZSA9IGRyYWdnYWJsZS5wYWdlO1xuICBjb25zdCBheGlzID0gZHJvcHBhYmxlLmF4aXM7XG4gIGlmICghaW5zaWRlRGVzdGluYXRpb24ubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGdvSW50b1N0YXJ0KHtcbiAgICAgIGF4aXMsXG4gICAgICBtb3ZlSW50bzogZHJvcHBhYmxlLnBhZ2UsXG4gICAgICBpc01vdmluZzogZHJhZ2dhYmxlUGFnZVxuICAgIH0pO1xuICB9XG4gIGNvbnN0IHtcbiAgICBkaXNwbGFjZWQsXG4gICAgZGlzcGxhY2VkQnlcbiAgfSA9IGltcGFjdDtcbiAgY29uc3QgY2xvc2VzdEFmdGVyID0gZGlzcGxhY2VkLmFsbFswXTtcbiAgaWYgKGNsb3Nlc3RBZnRlcikge1xuICAgIGNvbnN0IGNsb3Nlc3QgPSBkcmFnZ2FibGVzW2Nsb3Nlc3RBZnRlcl07XG4gICAgaWYgKGRpZFN0YXJ0QWZ0ZXJDcml0aWNhbChjbG9zZXN0QWZ0ZXIsIGFmdGVyQ3JpdGljYWwpKSB7XG4gICAgICByZXR1cm4gZ29CZWZvcmUoe1xuICAgICAgICBheGlzLFxuICAgICAgICBtb3ZlUmVsYXRpdmVUbzogY2xvc2VzdC5wYWdlLFxuICAgICAgICBpc01vdmluZzogZHJhZ2dhYmxlUGFnZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHdpdGhEaXNwbGFjZW1lbnQgPSBvZmZzZXQoY2xvc2VzdC5wYWdlLCBkaXNwbGFjZWRCeS5wb2ludCk7XG4gICAgcmV0dXJuIGdvQmVmb3JlKHtcbiAgICAgIGF4aXMsXG4gICAgICBtb3ZlUmVsYXRpdmVUbzogd2l0aERpc3BsYWNlbWVudCxcbiAgICAgIGlzTW92aW5nOiBkcmFnZ2FibGVQYWdlXG4gICAgfSk7XG4gIH1cbiAgY29uc3QgbGFzdCA9IGluc2lkZURlc3RpbmF0aW9uW2luc2lkZURlc3RpbmF0aW9uLmxlbmd0aCAtIDFdO1xuICBpZiAobGFzdC5kZXNjcmlwdG9yLmlkID09PSBkcmFnZ2FibGUuZGVzY3JpcHRvci5pZCkge1xuICAgIHJldHVybiBkcmFnZ2FibGVQYWdlLmJvcmRlckJveC5jZW50ZXI7XG4gIH1cbiAgaWYgKGRpZFN0YXJ0QWZ0ZXJDcml0aWNhbChsYXN0LmRlc2NyaXB0b3IuaWQsIGFmdGVyQ3JpdGljYWwpKSB7XG4gICAgY29uc3QgcGFnZSA9IG9mZnNldChsYXN0LnBhZ2UsIG5lZ2F0ZShhZnRlckNyaXRpY2FsLmRpc3BsYWNlZEJ5LnBvaW50KSk7XG4gICAgcmV0dXJuIGdvQWZ0ZXIoe1xuICAgICAgYXhpcyxcbiAgICAgIG1vdmVSZWxhdGl2ZVRvOiBwYWdlLFxuICAgICAgaXNNb3Zpbmc6IGRyYWdnYWJsZVBhZ2VcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gZ29BZnRlcih7XG4gICAgYXhpcyxcbiAgICBtb3ZlUmVsYXRpdmVUbzogbGFzdC5wYWdlLFxuICAgIGlzTW92aW5nOiBkcmFnZ2FibGVQYWdlXG4gIH0pO1xufSk7XG5cbnZhciB3aXRoRHJvcHBhYmxlRGlzcGxhY2VtZW50ID0gKChkcm9wcGFibGUsIHBvaW50KSA9PiB7XG4gIGNvbnN0IGZyYW1lID0gZHJvcHBhYmxlLmZyYW1lO1xuICBpZiAoIWZyYW1lKSB7XG4gICAgcmV0dXJuIHBvaW50O1xuICB9XG4gIHJldHVybiBhZGQocG9pbnQsIGZyYW1lLnNjcm9sbC5kaWZmLmRpc3BsYWNlbWVudCk7XG59KTtcblxuY29uc3QgZ2V0UmVzdWx0V2l0aG91dERyb3BwYWJsZURpc3BsYWNlbWVudCA9ICh7XG4gIGltcGFjdCxcbiAgZHJhZ2dhYmxlLFxuICBkcm9wcGFibGUsXG4gIGRyYWdnYWJsZXMsXG4gIGFmdGVyQ3JpdGljYWxcbn0pID0+IHtcbiAgY29uc3Qgb3JpZ2luYWwgPSBkcmFnZ2FibGUucGFnZS5ib3JkZXJCb3guY2VudGVyO1xuICBjb25zdCBhdCA9IGltcGFjdC5hdDtcbiAgaWYgKCFkcm9wcGFibGUpIHtcbiAgICByZXR1cm4gb3JpZ2luYWw7XG4gIH1cbiAgaWYgKCFhdCkge1xuICAgIHJldHVybiBvcmlnaW5hbDtcbiAgfVxuICBpZiAoYXQudHlwZSA9PT0gJ1JFT1JERVInKSB7XG4gICAgcmV0dXJuIHdoZW5SZW9yZGVyaW5nKHtcbiAgICAgIGltcGFjdCxcbiAgICAgIGRyYWdnYWJsZSxcbiAgICAgIGRyYWdnYWJsZXMsXG4gICAgICBkcm9wcGFibGUsXG4gICAgICBhZnRlckNyaXRpY2FsXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHdoZW5Db21iaW5pbmcoe1xuICAgIGltcGFjdCxcbiAgICBkcmFnZ2FibGVzLFxuICAgIGFmdGVyQ3JpdGljYWxcbiAgfSk7XG59O1xudmFyIGdldFBhZ2VCb3JkZXJCb3hDZW50ZXJGcm9tSW1wYWN0ID0gKGFyZ3MgPT4ge1xuICBjb25zdCB3aXRob3V0RGlzcGxhY2VtZW50ID0gZ2V0UmVzdWx0V2l0aG91dERyb3BwYWJsZURpc3BsYWNlbWVudChhcmdzKTtcbiAgY29uc3QgZHJvcHBhYmxlID0gYXJncy5kcm9wcGFibGU7XG4gIGNvbnN0IHdpdGhEaXNwbGFjZW1lbnQgPSBkcm9wcGFibGUgPyB3aXRoRHJvcHBhYmxlRGlzcGxhY2VtZW50KGRyb3BwYWJsZSwgd2l0aG91dERpc3BsYWNlbWVudCkgOiB3aXRob3V0RGlzcGxhY2VtZW50O1xuICByZXR1cm4gd2l0aERpc3BsYWNlbWVudDtcbn0pO1xuXG52YXIgc2Nyb2xsVmlld3BvcnQgPSAoKHZpZXdwb3J0LCBuZXdTY3JvbGwpID0+IHtcbiAgY29uc3QgZGlmZiA9IHN1YnRyYWN0KG5ld1Njcm9sbCwgdmlld3BvcnQuc2Nyb2xsLmluaXRpYWwpO1xuICBjb25zdCBkaXNwbGFjZW1lbnQgPSBuZWdhdGUoZGlmZik7XG4gIGNvbnN0IGZyYW1lID0gZ2V0UmVjdCh7XG4gICAgdG9wOiBuZXdTY3JvbGwueSxcbiAgICBib3R0b206IG5ld1Njcm9sbC55ICsgdmlld3BvcnQuZnJhbWUuaGVpZ2h0LFxuICAgIGxlZnQ6IG5ld1Njcm9sbC54LFxuICAgIHJpZ2h0OiBuZXdTY3JvbGwueCArIHZpZXdwb3J0LmZyYW1lLndpZHRoXG4gIH0pO1xuICBjb25zdCB1cGRhdGVkID0ge1xuICAgIGZyYW1lLFxuICAgIHNjcm9sbDoge1xuICAgICAgaW5pdGlhbDogdmlld3BvcnQuc2Nyb2xsLmluaXRpYWwsXG4gICAgICBtYXg6IHZpZXdwb3J0LnNjcm9sbC5tYXgsXG4gICAgICBjdXJyZW50OiBuZXdTY3JvbGwsXG4gICAgICBkaWZmOiB7XG4gICAgICAgIHZhbHVlOiBkaWZmLFxuICAgICAgICBkaXNwbGFjZW1lbnRcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHJldHVybiB1cGRhdGVkO1xufSk7XG5cbmZ1bmN0aW9uIGdldERyYWdnYWJsZXMkMShpZHMsIGRyYWdnYWJsZXMpIHtcbiAgcmV0dXJuIGlkcy5tYXAoaWQgPT4gZHJhZ2dhYmxlc1tpZF0pO1xufVxuZnVuY3Rpb24gdHJ5R2V0VmlzaWJsZShpZCwgZ3JvdXBzKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgZGlzcGxhY2VtZW50ID0gZ3JvdXBzW2ldLnZpc2libGVbaWRdO1xuICAgIGlmIChkaXNwbGFjZW1lbnQpIHtcbiAgICAgIHJldHVybiBkaXNwbGFjZW1lbnQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxudmFyIHNwZWN1bGF0aXZlbHlJbmNyZWFzZSA9ICgoe1xuICBpbXBhY3QsXG4gIHZpZXdwb3J0LFxuICBkZXN0aW5hdGlvbixcbiAgZHJhZ2dhYmxlcyxcbiAgbWF4U2Nyb2xsQ2hhbmdlXG59KSA9PiB7XG4gIGNvbnN0IHNjcm9sbGVkVmlld3BvcnQgPSBzY3JvbGxWaWV3cG9ydCh2aWV3cG9ydCwgYWRkKHZpZXdwb3J0LnNjcm9sbC5jdXJyZW50LCBtYXhTY3JvbGxDaGFuZ2UpKTtcbiAgY29uc3Qgc2Nyb2xsZWREcm9wcGFibGUgPSBkZXN0aW5hdGlvbi5mcmFtZSA/IHNjcm9sbERyb3BwYWJsZShkZXN0aW5hdGlvbiwgYWRkKGRlc3RpbmF0aW9uLmZyYW1lLnNjcm9sbC5jdXJyZW50LCBtYXhTY3JvbGxDaGFuZ2UpKSA6IGRlc3RpbmF0aW9uO1xuICBjb25zdCBsYXN0ID0gaW1wYWN0LmRpc3BsYWNlZDtcbiAgY29uc3Qgd2l0aFZpZXdwb3J0U2Nyb2xsID0gZ2V0RGlzcGxhY2VtZW50R3JvdXBzKHtcbiAgICBhZnRlckRyYWdnaW5nOiBnZXREcmFnZ2FibGVzJDEobGFzdC5hbGwsIGRyYWdnYWJsZXMpLFxuICAgIGRlc3RpbmF0aW9uLFxuICAgIGRpc3BsYWNlZEJ5OiBpbXBhY3QuZGlzcGxhY2VkQnksXG4gICAgdmlld3BvcnQ6IHNjcm9sbGVkVmlld3BvcnQuZnJhbWUsXG4gICAgbGFzdCxcbiAgICBmb3JjZVNob3VsZEFuaW1hdGU6IGZhbHNlXG4gIH0pO1xuICBjb25zdCB3aXRoRHJvcHBhYmxlU2Nyb2xsID0gZ2V0RGlzcGxhY2VtZW50R3JvdXBzKHtcbiAgICBhZnRlckRyYWdnaW5nOiBnZXREcmFnZ2FibGVzJDEobGFzdC5hbGwsIGRyYWdnYWJsZXMpLFxuICAgIGRlc3RpbmF0aW9uOiBzY3JvbGxlZERyb3BwYWJsZSxcbiAgICBkaXNwbGFjZWRCeTogaW1wYWN0LmRpc3BsYWNlZEJ5LFxuICAgIHZpZXdwb3J0OiB2aWV3cG9ydC5mcmFtZSxcbiAgICBsYXN0LFxuICAgIGZvcmNlU2hvdWxkQW5pbWF0ZTogZmFsc2VcbiAgfSk7XG4gIGNvbnN0IGludmlzaWJsZSA9IHt9O1xuICBjb25zdCB2aXNpYmxlID0ge307XG4gIGNvbnN0IGdyb3VwcyA9IFtsYXN0LCB3aXRoVmlld3BvcnRTY3JvbGwsIHdpdGhEcm9wcGFibGVTY3JvbGxdO1xuICBsYXN0LmFsbC5mb3JFYWNoKGlkID0+IHtcbiAgICBjb25zdCBkaXNwbGFjZW1lbnQgPSB0cnlHZXRWaXNpYmxlKGlkLCBncm91cHMpO1xuICAgIGlmIChkaXNwbGFjZW1lbnQpIHtcbiAgICAgIHZpc2libGVbaWRdID0gZGlzcGxhY2VtZW50O1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpbnZpc2libGVbaWRdID0gdHJ1ZTtcbiAgfSk7XG4gIGNvbnN0IG5ld0ltcGFjdCA9IHtcbiAgICAuLi5pbXBhY3QsXG4gICAgZGlzcGxhY2VkOiB7XG4gICAgICBhbGw6IGxhc3QuYWxsLFxuICAgICAgaW52aXNpYmxlLFxuICAgICAgdmlzaWJsZVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIG5ld0ltcGFjdDtcbn0pO1xuXG52YXIgd2l0aFZpZXdwb3J0RGlzcGxhY2VtZW50ID0gKCh2aWV3cG9ydCwgcG9pbnQpID0+IGFkZCh2aWV3cG9ydC5zY3JvbGwuZGlmZi5kaXNwbGFjZW1lbnQsIHBvaW50KSk7XG5cbnZhciBnZXRDbGllbnRGcm9tUGFnZUJvcmRlckJveENlbnRlciA9ICgoe1xuICBwYWdlQm9yZGVyQm94Q2VudGVyLFxuICBkcmFnZ2FibGUsXG4gIHZpZXdwb3J0XG59KSA9PiB7XG4gIGNvbnN0IHdpdGhvdXRQYWdlU2Nyb2xsQ2hhbmdlID0gd2l0aFZpZXdwb3J0RGlzcGxhY2VtZW50KHZpZXdwb3J0LCBwYWdlQm9yZGVyQm94Q2VudGVyKTtcbiAgY29uc3Qgb2Zmc2V0ID0gc3VidHJhY3Qod2l0aG91dFBhZ2VTY3JvbGxDaGFuZ2UsIGRyYWdnYWJsZS5wYWdlLmJvcmRlckJveC5jZW50ZXIpO1xuICByZXR1cm4gYWRkKGRyYWdnYWJsZS5jbGllbnQuYm9yZGVyQm94LmNlbnRlciwgb2Zmc2V0KTtcbn0pO1xuXG52YXIgaXNUb3RhbGx5VmlzaWJsZUluTmV3TG9jYXRpb24gPSAoKHtcbiAgZHJhZ2dhYmxlLFxuICBkZXN0aW5hdGlvbixcbiAgbmV3UGFnZUJvcmRlckJveENlbnRlcixcbiAgdmlld3BvcnQsXG4gIHdpdGhEcm9wcGFibGVEaXNwbGFjZW1lbnQsXG4gIG9ubHlPbk1haW5BeGlzID0gZmFsc2Vcbn0pID0+IHtcbiAgY29uc3QgY2hhbmdlTmVlZGVkID0gc3VidHJhY3QobmV3UGFnZUJvcmRlckJveENlbnRlciwgZHJhZ2dhYmxlLnBhZ2UuYm9yZGVyQm94LmNlbnRlcik7XG4gIGNvbnN0IHNoaWZ0ZWQgPSBvZmZzZXRCeVBvc2l0aW9uKGRyYWdnYWJsZS5wYWdlLmJvcmRlckJveCwgY2hhbmdlTmVlZGVkKTtcbiAgY29uc3QgYXJncyA9IHtcbiAgICB0YXJnZXQ6IHNoaWZ0ZWQsXG4gICAgZGVzdGluYXRpb24sXG4gICAgd2l0aERyb3BwYWJsZURpc3BsYWNlbWVudCxcbiAgICB2aWV3cG9ydFxuICB9O1xuICByZXR1cm4gb25seU9uTWFpbkF4aXMgPyBpc1RvdGFsbHlWaXNpYmxlT25BeGlzKGFyZ3MpIDogaXNUb3RhbGx5VmlzaWJsZShhcmdzKTtcbn0pO1xuXG52YXIgbW92ZVRvTmV4dFBsYWNlID0gKCh7XG4gIGlzTW92aW5nRm9yd2FyZCxcbiAgZHJhZ2dhYmxlLFxuICBkZXN0aW5hdGlvbixcbiAgZHJhZ2dhYmxlcyxcbiAgcHJldmlvdXNJbXBhY3QsXG4gIHZpZXdwb3J0LFxuICBwcmV2aW91c1BhZ2VCb3JkZXJCb3hDZW50ZXIsXG4gIHByZXZpb3VzQ2xpZW50U2VsZWN0aW9uLFxuICBhZnRlckNyaXRpY2FsXG59KSA9PiB7XG4gIGlmICghZGVzdGluYXRpb24uaXNFbmFibGVkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgaW5zaWRlRGVzdGluYXRpb24gPSBnZXREcmFnZ2FibGVzSW5zaWRlRHJvcHBhYmxlKGRlc3RpbmF0aW9uLmRlc2NyaXB0b3IuaWQsIGRyYWdnYWJsZXMpO1xuICBjb25zdCBpc0luSG9tZUxpc3QgPSBpc0hvbWVPZihkcmFnZ2FibGUsIGRlc3RpbmF0aW9uKTtcbiAgY29uc3QgaW1wYWN0ID0gbW92ZVRvTmV4dENvbWJpbmUoe1xuICAgIGlzTW92aW5nRm9yd2FyZCxcbiAgICBkcmFnZ2FibGUsXG4gICAgZGVzdGluYXRpb24sXG4gICAgaW5zaWRlRGVzdGluYXRpb24sXG4gICAgcHJldmlvdXNJbXBhY3RcbiAgfSkgfHwgbW92ZVRvTmV4dEluZGV4KHtcbiAgICBpc01vdmluZ0ZvcndhcmQsXG4gICAgaXNJbkhvbWVMaXN0LFxuICAgIGRyYWdnYWJsZSxcbiAgICBkcmFnZ2FibGVzLFxuICAgIGRlc3RpbmF0aW9uLFxuICAgIGluc2lkZURlc3RpbmF0aW9uLFxuICAgIHByZXZpb3VzSW1wYWN0LFxuICAgIHZpZXdwb3J0LFxuICAgIGFmdGVyQ3JpdGljYWxcbiAgfSk7XG4gIGlmICghaW1wYWN0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgcGFnZUJvcmRlckJveENlbnRlciA9IGdldFBhZ2VCb3JkZXJCb3hDZW50ZXJGcm9tSW1wYWN0KHtcbiAgICBpbXBhY3QsXG4gICAgZHJhZ2dhYmxlLFxuICAgIGRyb3BwYWJsZTogZGVzdGluYXRpb24sXG4gICAgZHJhZ2dhYmxlcyxcbiAgICBhZnRlckNyaXRpY2FsXG4gIH0pO1xuICBjb25zdCBpc1Zpc2libGVJbk5ld0xvY2F0aW9uID0gaXNUb3RhbGx5VmlzaWJsZUluTmV3TG9jYXRpb24oe1xuICAgIGRyYWdnYWJsZSxcbiAgICBkZXN0aW5hdGlvbixcbiAgICBuZXdQYWdlQm9yZGVyQm94Q2VudGVyOiBwYWdlQm9yZGVyQm94Q2VudGVyLFxuICAgIHZpZXdwb3J0OiB2aWV3cG9ydC5mcmFtZSxcbiAgICB3aXRoRHJvcHBhYmxlRGlzcGxhY2VtZW50OiBmYWxzZSxcbiAgICBvbmx5T25NYWluQXhpczogdHJ1ZVxuICB9KTtcbiAgaWYgKGlzVmlzaWJsZUluTmV3TG9jYXRpb24pIHtcbiAgICBjb25zdCBjbGllbnRTZWxlY3Rpb24gPSBnZXRDbGllbnRGcm9tUGFnZUJvcmRlckJveENlbnRlcih7XG4gICAgICBwYWdlQm9yZGVyQm94Q2VudGVyLFxuICAgICAgZHJhZ2dhYmxlLFxuICAgICAgdmlld3BvcnRcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgY2xpZW50U2VsZWN0aW9uLFxuICAgICAgaW1wYWN0LFxuICAgICAgc2Nyb2xsSnVtcFJlcXVlc3Q6IG51bGxcbiAgICB9O1xuICB9XG4gIGNvbnN0IGRpc3RhbmNlID0gc3VidHJhY3QocGFnZUJvcmRlckJveENlbnRlciwgcHJldmlvdXNQYWdlQm9yZGVyQm94Q2VudGVyKTtcbiAgY29uc3QgY2F1dGlvdXMgPSBzcGVjdWxhdGl2ZWx5SW5jcmVhc2Uoe1xuICAgIGltcGFjdCxcbiAgICB2aWV3cG9ydCxcbiAgICBkZXN0aW5hdGlvbixcbiAgICBkcmFnZ2FibGVzLFxuICAgIG1heFNjcm9sbENoYW5nZTogZGlzdGFuY2VcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgY2xpZW50U2VsZWN0aW9uOiBwcmV2aW91c0NsaWVudFNlbGVjdGlvbixcbiAgICBpbXBhY3Q6IGNhdXRpb3VzLFxuICAgIHNjcm9sbEp1bXBSZXF1ZXN0OiBkaXN0YW5jZVxuICB9O1xufSk7XG5cbmNvbnN0IGdldEtub3duQWN0aXZlID0gZHJvcHBhYmxlID0+IHtcbiAgY29uc3QgcmVjdCA9IGRyb3BwYWJsZS5zdWJqZWN0LmFjdGl2ZTtcbiAgIXJlY3QgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgZ2V0IGNsaXBwZWQgYXJlYSBmcm9tIGRyb3BwYWJsZScpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgcmV0dXJuIHJlY3Q7XG59O1xudmFyIGdldEJlc3RDcm9zc0F4aXNEcm9wcGFibGUgPSAoKHtcbiAgaXNNb3ZpbmdGb3J3YXJkLFxuICBwYWdlQm9yZGVyQm94Q2VudGVyLFxuICBzb3VyY2UsXG4gIGRyb3BwYWJsZXMsXG4gIHZpZXdwb3J0XG59KSA9PiB7XG4gIGNvbnN0IGFjdGl2ZSA9IHNvdXJjZS5zdWJqZWN0LmFjdGl2ZTtcbiAgaWYgKCFhY3RpdmUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBheGlzID0gc291cmNlLmF4aXM7XG4gIGNvbnN0IGlzQmV0d2VlblNvdXJjZUNsaXBwZWQgPSBpc1dpdGhpbihhY3RpdmVbYXhpcy5zdGFydF0sIGFjdGl2ZVtheGlzLmVuZF0pO1xuICBjb25zdCBjYW5kaWRhdGVzID0gdG9Ecm9wcGFibGVMaXN0KGRyb3BwYWJsZXMpLmZpbHRlcihkcm9wcGFibGUgPT4gZHJvcHBhYmxlICE9PSBzb3VyY2UpLmZpbHRlcihkcm9wcGFibGUgPT4gZHJvcHBhYmxlLmlzRW5hYmxlZCkuZmlsdGVyKGRyb3BwYWJsZSA9PiBCb29sZWFuKGRyb3BwYWJsZS5zdWJqZWN0LmFjdGl2ZSkpLmZpbHRlcihkcm9wcGFibGUgPT4gaXNQYXJ0aWFsbHlWaXNpYmxlVGhyb3VnaEZyYW1lKHZpZXdwb3J0LmZyYW1lKShnZXRLbm93bkFjdGl2ZShkcm9wcGFibGUpKSkuZmlsdGVyKGRyb3BwYWJsZSA9PiB7XG4gICAgY29uc3QgYWN0aXZlT2ZUYXJnZXQgPSBnZXRLbm93bkFjdGl2ZShkcm9wcGFibGUpO1xuICAgIGlmIChpc01vdmluZ0ZvcndhcmQpIHtcbiAgICAgIHJldHVybiBhY3RpdmVbYXhpcy5jcm9zc0F4aXNFbmRdIDwgYWN0aXZlT2ZUYXJnZXRbYXhpcy5jcm9zc0F4aXNFbmRdO1xuICAgIH1cbiAgICByZXR1cm4gYWN0aXZlT2ZUYXJnZXRbYXhpcy5jcm9zc0F4aXNTdGFydF0gPCBhY3RpdmVbYXhpcy5jcm9zc0F4aXNTdGFydF07XG4gIH0pLmZpbHRlcihkcm9wcGFibGUgPT4ge1xuICAgIGNvbnN0IGFjdGl2ZU9mVGFyZ2V0ID0gZ2V0S25vd25BY3RpdmUoZHJvcHBhYmxlKTtcbiAgICBjb25zdCBpc0JldHdlZW5EZXN0aW5hdGlvbkNsaXBwZWQgPSBpc1dpdGhpbihhY3RpdmVPZlRhcmdldFtheGlzLnN0YXJ0XSwgYWN0aXZlT2ZUYXJnZXRbYXhpcy5lbmRdKTtcbiAgICByZXR1cm4gaXNCZXR3ZWVuU291cmNlQ2xpcHBlZChhY3RpdmVPZlRhcmdldFtheGlzLnN0YXJ0XSkgfHwgaXNCZXR3ZWVuU291cmNlQ2xpcHBlZChhY3RpdmVPZlRhcmdldFtheGlzLmVuZF0pIHx8IGlzQmV0d2VlbkRlc3RpbmF0aW9uQ2xpcHBlZChhY3RpdmVbYXhpcy5zdGFydF0pIHx8IGlzQmV0d2VlbkRlc3RpbmF0aW9uQ2xpcHBlZChhY3RpdmVbYXhpcy5lbmRdKTtcbiAgfSkuc29ydCgoYSwgYikgPT4ge1xuICAgIGNvbnN0IGZpcnN0ID0gZ2V0S25vd25BY3RpdmUoYSlbYXhpcy5jcm9zc0F4aXNTdGFydF07XG4gICAgY29uc3Qgc2Vjb25kID0gZ2V0S25vd25BY3RpdmUoYilbYXhpcy5jcm9zc0F4aXNTdGFydF07XG4gICAgaWYgKGlzTW92aW5nRm9yd2FyZCkge1xuICAgICAgcmV0dXJuIGZpcnN0IC0gc2Vjb25kO1xuICAgIH1cbiAgICByZXR1cm4gc2Vjb25kIC0gZmlyc3Q7XG4gIH0pLmZpbHRlcigoZHJvcHBhYmxlLCBpbmRleCwgYXJyYXkpID0+IGdldEtub3duQWN0aXZlKGRyb3BwYWJsZSlbYXhpcy5jcm9zc0F4aXNTdGFydF0gPT09IGdldEtub3duQWN0aXZlKGFycmF5WzBdKVtheGlzLmNyb3NzQXhpc1N0YXJ0XSk7XG4gIGlmICghY2FuZGlkYXRlcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoY2FuZGlkYXRlcy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gY2FuZGlkYXRlc1swXTtcbiAgfVxuICBjb25zdCBjb250YWlucyA9IGNhbmRpZGF0ZXMuZmlsdGVyKGRyb3BwYWJsZSA9PiB7XG4gICAgY29uc3QgaXNXaXRoaW5Ecm9wcGFibGUgPSBpc1dpdGhpbihnZXRLbm93bkFjdGl2ZShkcm9wcGFibGUpW2F4aXMuc3RhcnRdLCBnZXRLbm93bkFjdGl2ZShkcm9wcGFibGUpW2F4aXMuZW5kXSk7XG4gICAgcmV0dXJuIGlzV2l0aGluRHJvcHBhYmxlKHBhZ2VCb3JkZXJCb3hDZW50ZXJbYXhpcy5saW5lXSk7XG4gIH0pO1xuICBpZiAoY29udGFpbnMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5zWzBdO1xuICB9XG4gIGlmIChjb250YWlucy5sZW5ndGggPiAxKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5zLnNvcnQoKGEsIGIpID0+IGdldEtub3duQWN0aXZlKGEpW2F4aXMuc3RhcnRdIC0gZ2V0S25vd25BY3RpdmUoYilbYXhpcy5zdGFydF0pWzBdO1xuICB9XG4gIHJldHVybiBjYW5kaWRhdGVzLnNvcnQoKGEsIGIpID0+IHtcbiAgICBjb25zdCBmaXJzdCA9IGNsb3Nlc3QkMShwYWdlQm9yZGVyQm94Q2VudGVyLCBnZXRDb3JuZXJzKGdldEtub3duQWN0aXZlKGEpKSk7XG4gICAgY29uc3Qgc2Vjb25kID0gY2xvc2VzdCQxKHBhZ2VCb3JkZXJCb3hDZW50ZXIsIGdldENvcm5lcnMoZ2V0S25vd25BY3RpdmUoYikpKTtcbiAgICBpZiAoZmlyc3QgIT09IHNlY29uZCkge1xuICAgICAgcmV0dXJuIGZpcnN0IC0gc2Vjb25kO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0S25vd25BY3RpdmUoYSlbYXhpcy5zdGFydF0gLSBnZXRLbm93bkFjdGl2ZShiKVtheGlzLnN0YXJ0XTtcbiAgfSlbMF07XG59KTtcblxuY29uc3QgZ2V0Q3VycmVudFBhZ2VCb3JkZXJCb3hDZW50ZXIgPSAoZHJhZ2dhYmxlLCBhZnRlckNyaXRpY2FsKSA9PiB7XG4gIGNvbnN0IG9yaWdpbmFsID0gZHJhZ2dhYmxlLnBhZ2UuYm9yZGVyQm94LmNlbnRlcjtcbiAgcmV0dXJuIGRpZFN0YXJ0QWZ0ZXJDcml0aWNhbChkcmFnZ2FibGUuZGVzY3JpcHRvci5pZCwgYWZ0ZXJDcml0aWNhbCkgPyBzdWJ0cmFjdChvcmlnaW5hbCwgYWZ0ZXJDcml0aWNhbC5kaXNwbGFjZWRCeS5wb2ludCkgOiBvcmlnaW5hbDtcbn07XG5jb25zdCBnZXRDdXJyZW50UGFnZUJvcmRlckJveCA9IChkcmFnZ2FibGUsIGFmdGVyQ3JpdGljYWwpID0+IHtcbiAgY29uc3Qgb3JpZ2luYWwgPSBkcmFnZ2FibGUucGFnZS5ib3JkZXJCb3g7XG4gIHJldHVybiBkaWRTdGFydEFmdGVyQ3JpdGljYWwoZHJhZ2dhYmxlLmRlc2NyaXB0b3IuaWQsIGFmdGVyQ3JpdGljYWwpID8gb2Zmc2V0QnlQb3NpdGlvbihvcmlnaW5hbCwgbmVnYXRlKGFmdGVyQ3JpdGljYWwuZGlzcGxhY2VkQnkucG9pbnQpKSA6IG9yaWdpbmFsO1xufTtcblxudmFyIGdldENsb3Nlc3REcmFnZ2FibGUgPSAoKHtcbiAgcGFnZUJvcmRlckJveENlbnRlcixcbiAgdmlld3BvcnQsXG4gIGRlc3RpbmF0aW9uLFxuICBpbnNpZGVEZXN0aW5hdGlvbixcbiAgYWZ0ZXJDcml0aWNhbFxufSkgPT4ge1xuICBjb25zdCBzb3J0ZWQgPSBpbnNpZGVEZXN0aW5hdGlvbi5maWx0ZXIoZHJhZ2dhYmxlID0+IGlzVG90YWxseVZpc2libGUoe1xuICAgIHRhcmdldDogZ2V0Q3VycmVudFBhZ2VCb3JkZXJCb3goZHJhZ2dhYmxlLCBhZnRlckNyaXRpY2FsKSxcbiAgICBkZXN0aW5hdGlvbixcbiAgICB2aWV3cG9ydDogdmlld3BvcnQuZnJhbWUsXG4gICAgd2l0aERyb3BwYWJsZURpc3BsYWNlbWVudDogdHJ1ZVxuICB9KSkuc29ydCgoYSwgYikgPT4ge1xuICAgIGNvbnN0IGRpc3RhbmNlVG9BID0gZGlzdGFuY2UocGFnZUJvcmRlckJveENlbnRlciwgd2l0aERyb3BwYWJsZURpc3BsYWNlbWVudChkZXN0aW5hdGlvbiwgZ2V0Q3VycmVudFBhZ2VCb3JkZXJCb3hDZW50ZXIoYSwgYWZ0ZXJDcml0aWNhbCkpKTtcbiAgICBjb25zdCBkaXN0YW5jZVRvQiA9IGRpc3RhbmNlKHBhZ2VCb3JkZXJCb3hDZW50ZXIsIHdpdGhEcm9wcGFibGVEaXNwbGFjZW1lbnQoZGVzdGluYXRpb24sIGdldEN1cnJlbnRQYWdlQm9yZGVyQm94Q2VudGVyKGIsIGFmdGVyQ3JpdGljYWwpKSk7XG4gICAgaWYgKGRpc3RhbmNlVG9BIDwgZGlzdGFuY2VUb0IpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgaWYgKGRpc3RhbmNlVG9CIDwgZGlzdGFuY2VUb0EpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICByZXR1cm4gYS5kZXNjcmlwdG9yLmluZGV4IC0gYi5kZXNjcmlwdG9yLmluZGV4O1xuICB9KTtcbiAgcmV0dXJuIHNvcnRlZFswXSB8fCBudWxsO1xufSk7XG5cbnZhciBnZXREaXNwbGFjZWRCeSA9IG1lbW9pemVPbmUoZnVuY3Rpb24gZ2V0RGlzcGxhY2VkQnkoYXhpcywgZGlzcGxhY2VCeSkge1xuICBjb25zdCBkaXNwbGFjZW1lbnQgPSBkaXNwbGFjZUJ5W2F4aXMubGluZV07XG4gIHJldHVybiB7XG4gICAgdmFsdWU6IGRpc3BsYWNlbWVudCxcbiAgICBwb2ludDogcGF0Y2goYXhpcy5saW5lLCBkaXNwbGFjZW1lbnQpXG4gIH07XG59KTtcblxuY29uc3QgZ2V0UmVxdWlyZWRHcm93dGhGb3JQbGFjZWhvbGRlciA9IChkcm9wcGFibGUsIHBsYWNlaG9sZGVyU2l6ZSwgZHJhZ2dhYmxlcykgPT4ge1xuICBjb25zdCBheGlzID0gZHJvcHBhYmxlLmF4aXM7XG4gIGlmIChkcm9wcGFibGUuZGVzY3JpcHRvci5tb2RlID09PSAndmlydHVhbCcpIHtcbiAgICByZXR1cm4gcGF0Y2goYXhpcy5saW5lLCBwbGFjZWhvbGRlclNpemVbYXhpcy5saW5lXSk7XG4gIH1cbiAgY29uc3QgYXZhaWxhYmxlU3BhY2UgPSBkcm9wcGFibGUuc3ViamVjdC5wYWdlLmNvbnRlbnRCb3hbYXhpcy5zaXplXTtcbiAgY29uc3QgaW5zaWRlRHJvcHBhYmxlID0gZ2V0RHJhZ2dhYmxlc0luc2lkZURyb3BwYWJsZShkcm9wcGFibGUuZGVzY3JpcHRvci5pZCwgZHJhZ2dhYmxlcyk7XG4gIGNvbnN0IHNwYWNlVXNlZCA9IGluc2lkZURyb3BwYWJsZS5yZWR1Y2UoKHN1bSwgZGltZW5zaW9uKSA9PiBzdW0gKyBkaW1lbnNpb24uY2xpZW50Lm1hcmdpbkJveFtheGlzLnNpemVdLCAwKTtcbiAgY29uc3QgcmVxdWlyZWRTcGFjZSA9IHNwYWNlVXNlZCArIHBsYWNlaG9sZGVyU2l6ZVtheGlzLmxpbmVdO1xuICBjb25zdCBuZWVkc1RvR3Jvd0J5ID0gcmVxdWlyZWRTcGFjZSAtIGF2YWlsYWJsZVNwYWNlO1xuICBpZiAobmVlZHNUb0dyb3dCeSA8PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIHBhdGNoKGF4aXMubGluZSwgbmVlZHNUb0dyb3dCeSk7XG59O1xuY29uc3Qgd2l0aE1heFNjcm9sbCA9IChmcmFtZSwgbWF4KSA9PiAoe1xuICAuLi5mcmFtZSxcbiAgc2Nyb2xsOiB7XG4gICAgLi4uZnJhbWUuc2Nyb2xsLFxuICAgIG1heFxuICB9XG59KTtcbmNvbnN0IGFkZFBsYWNlaG9sZGVyID0gKGRyb3BwYWJsZSwgZHJhZ2dhYmxlLCBkcmFnZ2FibGVzKSA9PiB7XG4gIGNvbnN0IGZyYW1lID0gZHJvcHBhYmxlLmZyYW1lO1xuICAhIWlzSG9tZU9mKGRyYWdnYWJsZSwgZHJvcHBhYmxlKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ1Nob3VsZCBub3QgYWRkIHBsYWNlaG9sZGVyIHNwYWNlIHRvIGhvbWUgbGlzdCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgISFkcm9wcGFibGUuc3ViamVjdC53aXRoUGxhY2Vob2xkZXIgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgYWRkIHBsYWNlaG9sZGVyIHNpemUgdG8gYSBzdWJqZWN0IHdoZW4gaXQgYWxyZWFkeSBoYXMgb25lJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICBjb25zdCBwbGFjZWhvbGRlclNpemUgPSBnZXREaXNwbGFjZWRCeShkcm9wcGFibGUuYXhpcywgZHJhZ2dhYmxlLmRpc3BsYWNlQnkpLnBvaW50O1xuICBjb25zdCByZXF1aXJlZEdyb3d0aCA9IGdldFJlcXVpcmVkR3Jvd3RoRm9yUGxhY2Vob2xkZXIoZHJvcHBhYmxlLCBwbGFjZWhvbGRlclNpemUsIGRyYWdnYWJsZXMpO1xuICBjb25zdCBhZGRlZCA9IHtcbiAgICBwbGFjZWhvbGRlclNpemUsXG4gICAgaW5jcmVhc2VkQnk6IHJlcXVpcmVkR3Jvd3RoLFxuICAgIG9sZEZyYW1lTWF4U2Nyb2xsOiBkcm9wcGFibGUuZnJhbWUgPyBkcm9wcGFibGUuZnJhbWUuc2Nyb2xsLm1heCA6IG51bGxcbiAgfTtcbiAgaWYgKCFmcmFtZSkge1xuICAgIGNvbnN0IHN1YmplY3QgPSBnZXRTdWJqZWN0KHtcbiAgICAgIHBhZ2U6IGRyb3BwYWJsZS5zdWJqZWN0LnBhZ2UsXG4gICAgICB3aXRoUGxhY2Vob2xkZXI6IGFkZGVkLFxuICAgICAgYXhpczogZHJvcHBhYmxlLmF4aXMsXG4gICAgICBmcmFtZTogZHJvcHBhYmxlLmZyYW1lXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmRyb3BwYWJsZSxcbiAgICAgIHN1YmplY3RcbiAgICB9O1xuICB9XG4gIGNvbnN0IG1heFNjcm9sbCA9IHJlcXVpcmVkR3Jvd3RoID8gYWRkKGZyYW1lLnNjcm9sbC5tYXgsIHJlcXVpcmVkR3Jvd3RoKSA6IGZyYW1lLnNjcm9sbC5tYXg7XG4gIGNvbnN0IG5ld0ZyYW1lID0gd2l0aE1heFNjcm9sbChmcmFtZSwgbWF4U2Nyb2xsKTtcbiAgY29uc3Qgc3ViamVjdCA9IGdldFN1YmplY3Qoe1xuICAgIHBhZ2U6IGRyb3BwYWJsZS5zdWJqZWN0LnBhZ2UsXG4gICAgd2l0aFBsYWNlaG9sZGVyOiBhZGRlZCxcbiAgICBheGlzOiBkcm9wcGFibGUuYXhpcyxcbiAgICBmcmFtZTogbmV3RnJhbWVcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgLi4uZHJvcHBhYmxlLFxuICAgIHN1YmplY3QsXG4gICAgZnJhbWU6IG5ld0ZyYW1lXG4gIH07XG59O1xuY29uc3QgcmVtb3ZlUGxhY2Vob2xkZXIgPSBkcm9wcGFibGUgPT4ge1xuICBjb25zdCBhZGRlZCA9IGRyb3BwYWJsZS5zdWJqZWN0LndpdGhQbGFjZWhvbGRlcjtcbiAgIWFkZGVkID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHJlbW92ZSBwbGFjZWhvbGRlciBmb3JtIHN1YmplY3Qgd2hlbiB0aGVyZSB3YXMgbm9uZScpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgY29uc3QgZnJhbWUgPSBkcm9wcGFibGUuZnJhbWU7XG4gIGlmICghZnJhbWUpIHtcbiAgICBjb25zdCBzdWJqZWN0ID0gZ2V0U3ViamVjdCh7XG4gICAgICBwYWdlOiBkcm9wcGFibGUuc3ViamVjdC5wYWdlLFxuICAgICAgYXhpczogZHJvcHBhYmxlLmF4aXMsXG4gICAgICBmcmFtZTogbnVsbCxcbiAgICAgIHdpdGhQbGFjZWhvbGRlcjogbnVsbFxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5kcm9wcGFibGUsXG4gICAgICBzdWJqZWN0XG4gICAgfTtcbiAgfVxuICBjb25zdCBvbGRNYXhTY3JvbGwgPSBhZGRlZC5vbGRGcmFtZU1heFNjcm9sbDtcbiAgIW9sZE1heFNjcm9sbCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIGRyb3BwYWJsZSB3aXRoIGZyYW1lIHRvIGhhdmUgb2xkIG1heCBmcmFtZSBzY3JvbGwgd2hlbiByZW1vdmluZyBwbGFjZWhvbGRlcicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgY29uc3QgbmV3RnJhbWUgPSB3aXRoTWF4U2Nyb2xsKGZyYW1lLCBvbGRNYXhTY3JvbGwpO1xuICBjb25zdCBzdWJqZWN0ID0gZ2V0U3ViamVjdCh7XG4gICAgcGFnZTogZHJvcHBhYmxlLnN1YmplY3QucGFnZSxcbiAgICBheGlzOiBkcm9wcGFibGUuYXhpcyxcbiAgICBmcmFtZTogbmV3RnJhbWUsXG4gICAgd2l0aFBsYWNlaG9sZGVyOiBudWxsXG4gIH0pO1xuICByZXR1cm4ge1xuICAgIC4uLmRyb3BwYWJsZSxcbiAgICBzdWJqZWN0LFxuICAgIGZyYW1lOiBuZXdGcmFtZVxuICB9O1xufTtcblxudmFyIG1vdmVUb05ld0Ryb3BwYWJsZSA9ICgoe1xuICBwcmV2aW91c1BhZ2VCb3JkZXJCb3hDZW50ZXIsXG4gIG1vdmVSZWxhdGl2ZVRvLFxuICBpbnNpZGVEZXN0aW5hdGlvbixcbiAgZHJhZ2dhYmxlLFxuICBkcmFnZ2FibGVzLFxuICBkZXN0aW5hdGlvbixcbiAgdmlld3BvcnQsXG4gIGFmdGVyQ3JpdGljYWxcbn0pID0+IHtcbiAgaWYgKCFtb3ZlUmVsYXRpdmVUbykge1xuICAgIGlmIChpbnNpZGVEZXN0aW5hdGlvbi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBwcm9wb3NlZCA9IHtcbiAgICAgIGRpc3BsYWNlZDogZW1wdHlHcm91cHMsXG4gICAgICBkaXNwbGFjZWRCeTogbm9EaXNwbGFjZWRCeSxcbiAgICAgIGF0OiB7XG4gICAgICAgIHR5cGU6ICdSRU9SREVSJyxcbiAgICAgICAgZGVzdGluYXRpb246IHtcbiAgICAgICAgICBkcm9wcGFibGVJZDogZGVzdGluYXRpb24uZGVzY3JpcHRvci5pZCxcbiAgICAgICAgICBpbmRleDogMFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBwcm9wb3NlZFBhZ2VCb3JkZXJCb3hDZW50ZXIgPSBnZXRQYWdlQm9yZGVyQm94Q2VudGVyRnJvbUltcGFjdCh7XG4gICAgICBpbXBhY3Q6IHByb3Bvc2VkLFxuICAgICAgZHJhZ2dhYmxlLFxuICAgICAgZHJvcHBhYmxlOiBkZXN0aW5hdGlvbixcbiAgICAgIGRyYWdnYWJsZXMsXG4gICAgICBhZnRlckNyaXRpY2FsXG4gICAgfSk7XG4gICAgY29uc3Qgd2l0aFBsYWNlaG9sZGVyID0gaXNIb21lT2YoZHJhZ2dhYmxlLCBkZXN0aW5hdGlvbikgPyBkZXN0aW5hdGlvbiA6IGFkZFBsYWNlaG9sZGVyKGRlc3RpbmF0aW9uLCBkcmFnZ2FibGUsIGRyYWdnYWJsZXMpO1xuICAgIGNvbnN0IGlzVmlzaWJsZUluTmV3TG9jYXRpb24gPSBpc1RvdGFsbHlWaXNpYmxlSW5OZXdMb2NhdGlvbih7XG4gICAgICBkcmFnZ2FibGUsXG4gICAgICBkZXN0aW5hdGlvbjogd2l0aFBsYWNlaG9sZGVyLFxuICAgICAgbmV3UGFnZUJvcmRlckJveENlbnRlcjogcHJvcG9zZWRQYWdlQm9yZGVyQm94Q2VudGVyLFxuICAgICAgdmlld3BvcnQ6IHZpZXdwb3J0LmZyYW1lLFxuICAgICAgd2l0aERyb3BwYWJsZURpc3BsYWNlbWVudDogZmFsc2UsXG4gICAgICBvbmx5T25NYWluQXhpczogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBpc1Zpc2libGVJbk5ld0xvY2F0aW9uID8gcHJvcG9zZWQgOiBudWxsO1xuICB9XG4gIGNvbnN0IGlzR29pbmdCZWZvcmVUYXJnZXQgPSBCb29sZWFuKHByZXZpb3VzUGFnZUJvcmRlckJveENlbnRlcltkZXN0aW5hdGlvbi5heGlzLmxpbmVdIDw9IG1vdmVSZWxhdGl2ZVRvLnBhZ2UuYm9yZGVyQm94LmNlbnRlcltkZXN0aW5hdGlvbi5heGlzLmxpbmVdKTtcbiAgY29uc3QgcHJvcG9zZWRJbmRleCA9ICgoKSA9PiB7XG4gICAgY29uc3QgcmVsYXRpdmVUbyA9IG1vdmVSZWxhdGl2ZVRvLmRlc2NyaXB0b3IuaW5kZXg7XG4gICAgaWYgKG1vdmVSZWxhdGl2ZVRvLmRlc2NyaXB0b3IuaWQgPT09IGRyYWdnYWJsZS5kZXNjcmlwdG9yLmlkKSB7XG4gICAgICByZXR1cm4gcmVsYXRpdmVUbztcbiAgICB9XG4gICAgaWYgKGlzR29pbmdCZWZvcmVUYXJnZXQpIHtcbiAgICAgIHJldHVybiByZWxhdGl2ZVRvO1xuICAgIH1cbiAgICByZXR1cm4gcmVsYXRpdmVUbyArIDE7XG4gIH0pKCk7XG4gIGNvbnN0IGRpc3BsYWNlZEJ5ID0gZ2V0RGlzcGxhY2VkQnkoZGVzdGluYXRpb24uYXhpcywgZHJhZ2dhYmxlLmRpc3BsYWNlQnkpO1xuICByZXR1cm4gY2FsY3VsYXRlUmVvcmRlckltcGFjdCh7XG4gICAgZHJhZ2dhYmxlLFxuICAgIGluc2lkZURlc3RpbmF0aW9uLFxuICAgIGRlc3RpbmF0aW9uLFxuICAgIHZpZXdwb3J0LFxuICAgIGRpc3BsYWNlZEJ5LFxuICAgIGxhc3Q6IGVtcHR5R3JvdXBzLFxuICAgIGluZGV4OiBwcm9wb3NlZEluZGV4XG4gIH0pO1xufSk7XG5cbnZhciBtb3ZlQ3Jvc3NBeGlzID0gKCh7XG4gIGlzTW92aW5nRm9yd2FyZCxcbiAgcHJldmlvdXNQYWdlQm9yZGVyQm94Q2VudGVyLFxuICBkcmFnZ2FibGUsXG4gIGlzT3ZlcixcbiAgZHJhZ2dhYmxlcyxcbiAgZHJvcHBhYmxlcyxcbiAgdmlld3BvcnQsXG4gIGFmdGVyQ3JpdGljYWxcbn0pID0+IHtcbiAgY29uc3QgZGVzdGluYXRpb24gPSBnZXRCZXN0Q3Jvc3NBeGlzRHJvcHBhYmxlKHtcbiAgICBpc01vdmluZ0ZvcndhcmQsXG4gICAgcGFnZUJvcmRlckJveENlbnRlcjogcHJldmlvdXNQYWdlQm9yZGVyQm94Q2VudGVyLFxuICAgIHNvdXJjZTogaXNPdmVyLFxuICAgIGRyb3BwYWJsZXMsXG4gICAgdmlld3BvcnRcbiAgfSk7XG4gIGlmICghZGVzdGluYXRpb24pIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBpbnNpZGVEZXN0aW5hdGlvbiA9IGdldERyYWdnYWJsZXNJbnNpZGVEcm9wcGFibGUoZGVzdGluYXRpb24uZGVzY3JpcHRvci5pZCwgZHJhZ2dhYmxlcyk7XG4gIGNvbnN0IG1vdmVSZWxhdGl2ZVRvID0gZ2V0Q2xvc2VzdERyYWdnYWJsZSh7XG4gICAgcGFnZUJvcmRlckJveENlbnRlcjogcHJldmlvdXNQYWdlQm9yZGVyQm94Q2VudGVyLFxuICAgIHZpZXdwb3J0LFxuICAgIGRlc3RpbmF0aW9uLFxuICAgIGluc2lkZURlc3RpbmF0aW9uLFxuICAgIGFmdGVyQ3JpdGljYWxcbiAgfSk7XG4gIGNvbnN0IGltcGFjdCA9IG1vdmVUb05ld0Ryb3BwYWJsZSh7XG4gICAgcHJldmlvdXNQYWdlQm9yZGVyQm94Q2VudGVyLFxuICAgIGRlc3RpbmF0aW9uLFxuICAgIGRyYWdnYWJsZSxcbiAgICBkcmFnZ2FibGVzLFxuICAgIG1vdmVSZWxhdGl2ZVRvLFxuICAgIGluc2lkZURlc3RpbmF0aW9uLFxuICAgIHZpZXdwb3J0LFxuICAgIGFmdGVyQ3JpdGljYWxcbiAgfSk7XG4gIGlmICghaW1wYWN0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgcGFnZUJvcmRlckJveENlbnRlciA9IGdldFBhZ2VCb3JkZXJCb3hDZW50ZXJGcm9tSW1wYWN0KHtcbiAgICBpbXBhY3QsXG4gICAgZHJhZ2dhYmxlLFxuICAgIGRyb3BwYWJsZTogZGVzdGluYXRpb24sXG4gICAgZHJhZ2dhYmxlcyxcbiAgICBhZnRlckNyaXRpY2FsXG4gIH0pO1xuICBjb25zdCBjbGllbnRTZWxlY3Rpb24gPSBnZXRDbGllbnRGcm9tUGFnZUJvcmRlckJveENlbnRlcih7XG4gICAgcGFnZUJvcmRlckJveENlbnRlcixcbiAgICBkcmFnZ2FibGUsXG4gICAgdmlld3BvcnRcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgY2xpZW50U2VsZWN0aW9uLFxuICAgIGltcGFjdCxcbiAgICBzY3JvbGxKdW1wUmVxdWVzdDogbnVsbFxuICB9O1xufSk7XG5cbnZhciB3aGF0SXNEcmFnZ2VkT3ZlciA9IChpbXBhY3QgPT4ge1xuICBjb25zdCBhdCA9IGltcGFjdC5hdDtcbiAgaWYgKCFhdCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChhdC50eXBlID09PSAnUkVPUkRFUicpIHtcbiAgICByZXR1cm4gYXQuZGVzdGluYXRpb24uZHJvcHBhYmxlSWQ7XG4gIH1cbiAgcmV0dXJuIGF0LmNvbWJpbmUuZHJvcHBhYmxlSWQ7XG59KTtcblxuY29uc3QgZ2V0RHJvcHBhYmxlT3ZlciQxID0gKGltcGFjdCwgZHJvcHBhYmxlcykgPT4ge1xuICBjb25zdCBpZCA9IHdoYXRJc0RyYWdnZWRPdmVyKGltcGFjdCk7XG4gIHJldHVybiBpZCA/IGRyb3BwYWJsZXNbaWRdIDogbnVsbDtcbn07XG52YXIgbW92ZUluRGlyZWN0aW9uID0gKCh7XG4gIHN0YXRlLFxuICB0eXBlXG59KSA9PiB7XG4gIGNvbnN0IGlzQWN0dWFsbHlPdmVyID0gZ2V0RHJvcHBhYmxlT3ZlciQxKHN0YXRlLmltcGFjdCwgc3RhdGUuZGltZW5zaW9ucy5kcm9wcGFibGVzKTtcbiAgY29uc3QgaXNNYWluQXhpc01vdmVtZW50QWxsb3dlZCA9IEJvb2xlYW4oaXNBY3R1YWxseU92ZXIpO1xuICBjb25zdCBob21lID0gc3RhdGUuZGltZW5zaW9ucy5kcm9wcGFibGVzW3N0YXRlLmNyaXRpY2FsLmRyb3BwYWJsZS5pZF07XG4gIGNvbnN0IGlzT3ZlciA9IGlzQWN0dWFsbHlPdmVyIHx8IGhvbWU7XG4gIGNvbnN0IGRpcmVjdGlvbiA9IGlzT3Zlci5heGlzLmRpcmVjdGlvbjtcbiAgY29uc3QgaXNNb3ZpbmdPbk1haW5BeGlzID0gZGlyZWN0aW9uID09PSAndmVydGljYWwnICYmICh0eXBlID09PSAnTU9WRV9VUCcgfHwgdHlwZSA9PT0gJ01PVkVfRE9XTicpIHx8IGRpcmVjdGlvbiA9PT0gJ2hvcml6b250YWwnICYmICh0eXBlID09PSAnTU9WRV9MRUZUJyB8fCB0eXBlID09PSAnTU9WRV9SSUdIVCcpO1xuICBpZiAoaXNNb3ZpbmdPbk1haW5BeGlzICYmICFpc01haW5BeGlzTW92ZW1lbnRBbGxvd2VkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgaXNNb3ZpbmdGb3J3YXJkID0gdHlwZSA9PT0gJ01PVkVfRE9XTicgfHwgdHlwZSA9PT0gJ01PVkVfUklHSFQnO1xuICBjb25zdCBkcmFnZ2FibGUgPSBzdGF0ZS5kaW1lbnNpb25zLmRyYWdnYWJsZXNbc3RhdGUuY3JpdGljYWwuZHJhZ2dhYmxlLmlkXTtcbiAgY29uc3QgcHJldmlvdXNQYWdlQm9yZGVyQm94Q2VudGVyID0gc3RhdGUuY3VycmVudC5wYWdlLmJvcmRlckJveENlbnRlcjtcbiAgY29uc3Qge1xuICAgIGRyYWdnYWJsZXMsXG4gICAgZHJvcHBhYmxlc1xuICB9ID0gc3RhdGUuZGltZW5zaW9ucztcbiAgcmV0dXJuIGlzTW92aW5nT25NYWluQXhpcyA/IG1vdmVUb05leHRQbGFjZSh7XG4gICAgaXNNb3ZpbmdGb3J3YXJkLFxuICAgIHByZXZpb3VzUGFnZUJvcmRlckJveENlbnRlcixcbiAgICBkcmFnZ2FibGUsXG4gICAgZGVzdGluYXRpb246IGlzT3ZlcixcbiAgICBkcmFnZ2FibGVzLFxuICAgIHZpZXdwb3J0OiBzdGF0ZS52aWV3cG9ydCxcbiAgICBwcmV2aW91c0NsaWVudFNlbGVjdGlvbjogc3RhdGUuY3VycmVudC5jbGllbnQuc2VsZWN0aW9uLFxuICAgIHByZXZpb3VzSW1wYWN0OiBzdGF0ZS5pbXBhY3QsXG4gICAgYWZ0ZXJDcml0aWNhbDogc3RhdGUuYWZ0ZXJDcml0aWNhbFxuICB9KSA6IG1vdmVDcm9zc0F4aXMoe1xuICAgIGlzTW92aW5nRm9yd2FyZCxcbiAgICBwcmV2aW91c1BhZ2VCb3JkZXJCb3hDZW50ZXIsXG4gICAgZHJhZ2dhYmxlLFxuICAgIGlzT3ZlcixcbiAgICBkcmFnZ2FibGVzLFxuICAgIGRyb3BwYWJsZXMsXG4gICAgdmlld3BvcnQ6IHN0YXRlLnZpZXdwb3J0LFxuICAgIGFmdGVyQ3JpdGljYWw6IHN0YXRlLmFmdGVyQ3JpdGljYWxcbiAgfSk7XG59KTtcblxuZnVuY3Rpb24gaXNNb3ZlbWVudEFsbG93ZWQoc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLnBoYXNlID09PSAnRFJBR0dJTkcnIHx8IHN0YXRlLnBoYXNlID09PSAnQ09MTEVDVElORyc7XG59XG5cbmZ1bmN0aW9uIGlzUG9zaXRpb25JbkZyYW1lKGZyYW1lKSB7XG4gIGNvbnN0IGlzV2l0aGluVmVydGljYWwgPSBpc1dpdGhpbihmcmFtZS50b3AsIGZyYW1lLmJvdHRvbSk7XG4gIGNvbnN0IGlzV2l0aGluSG9yaXpvbnRhbCA9IGlzV2l0aGluKGZyYW1lLmxlZnQsIGZyYW1lLnJpZ2h0KTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHJ1bihwb2ludCkge1xuICAgIHJldHVybiBpc1dpdGhpblZlcnRpY2FsKHBvaW50LnkpICYmIGlzV2l0aGluSG9yaXpvbnRhbChwb2ludC54KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0SGFzT3ZlcmxhcChmaXJzdCwgc2Vjb25kKSB7XG4gIHJldHVybiBmaXJzdC5sZWZ0IDwgc2Vjb25kLnJpZ2h0ICYmIGZpcnN0LnJpZ2h0ID4gc2Vjb25kLmxlZnQgJiYgZmlyc3QudG9wIDwgc2Vjb25kLmJvdHRvbSAmJiBmaXJzdC5ib3R0b20gPiBzZWNvbmQudG9wO1xufVxuZnVuY3Rpb24gZ2V0RnVydGhlc3RBd2F5KHtcbiAgcGFnZUJvcmRlckJveCxcbiAgZHJhZ2dhYmxlLFxuICBjYW5kaWRhdGVzXG59KSB7XG4gIGNvbnN0IHN0YXJ0Q2VudGVyID0gZHJhZ2dhYmxlLnBhZ2UuYm9yZGVyQm94LmNlbnRlcjtcbiAgY29uc3Qgc29ydGVkID0gY2FuZGlkYXRlcy5tYXAoY2FuZGlkYXRlID0+IHtcbiAgICBjb25zdCBheGlzID0gY2FuZGlkYXRlLmF4aXM7XG4gICAgY29uc3QgdGFyZ2V0ID0gcGF0Y2goY2FuZGlkYXRlLmF4aXMubGluZSwgcGFnZUJvcmRlckJveC5jZW50ZXJbYXhpcy5saW5lXSwgY2FuZGlkYXRlLnBhZ2UuYm9yZGVyQm94LmNlbnRlcltheGlzLmNyb3NzQXhpc0xpbmVdKTtcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IGNhbmRpZGF0ZS5kZXNjcmlwdG9yLmlkLFxuICAgICAgZGlzdGFuY2U6IGRpc3RhbmNlKHN0YXJ0Q2VudGVyLCB0YXJnZXQpXG4gICAgfTtcbiAgfSkuc29ydCgoYSwgYikgPT4gYi5kaXN0YW5jZSAtIGEuZGlzdGFuY2UpO1xuICByZXR1cm4gc29ydGVkWzBdID8gc29ydGVkWzBdLmlkIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGdldERyb3BwYWJsZU92ZXIoe1xuICBwYWdlQm9yZGVyQm94LFxuICBkcmFnZ2FibGUsXG4gIGRyb3BwYWJsZXNcbn0pIHtcbiAgY29uc3QgY2FuZGlkYXRlcyA9IHRvRHJvcHBhYmxlTGlzdChkcm9wcGFibGVzKS5maWx0ZXIoaXRlbSA9PiB7XG4gICAgaWYgKCFpdGVtLmlzRW5hYmxlZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBhY3RpdmUgPSBpdGVtLnN1YmplY3QuYWN0aXZlO1xuICAgIGlmICghYWN0aXZlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghZ2V0SGFzT3ZlcmxhcChwYWdlQm9yZGVyQm94LCBhY3RpdmUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChpc1Bvc2l0aW9uSW5GcmFtZShhY3RpdmUpKHBhZ2VCb3JkZXJCb3guY2VudGVyKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGF4aXMgPSBpdGVtLmF4aXM7XG4gICAgY29uc3QgY2hpbGRDZW50ZXIgPSBhY3RpdmUuY2VudGVyW2F4aXMuY3Jvc3NBeGlzTGluZV07XG4gICAgY29uc3QgY3Jvc3NBeGlzU3RhcnQgPSBwYWdlQm9yZGVyQm94W2F4aXMuY3Jvc3NBeGlzU3RhcnRdO1xuICAgIGNvbnN0IGNyb3NzQXhpc0VuZCA9IHBhZ2VCb3JkZXJCb3hbYXhpcy5jcm9zc0F4aXNFbmRdO1xuICAgIGNvbnN0IGlzQ29udGFpbmVkID0gaXNXaXRoaW4oYWN0aXZlW2F4aXMuY3Jvc3NBeGlzU3RhcnRdLCBhY3RpdmVbYXhpcy5jcm9zc0F4aXNFbmRdKTtcbiAgICBjb25zdCBpc1N0YXJ0Q29udGFpbmVkID0gaXNDb250YWluZWQoY3Jvc3NBeGlzU3RhcnQpO1xuICAgIGNvbnN0IGlzRW5kQ29udGFpbmVkID0gaXNDb250YWluZWQoY3Jvc3NBeGlzRW5kKTtcbiAgICBpZiAoIWlzU3RhcnRDb250YWluZWQgJiYgIWlzRW5kQ29udGFpbmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGlzU3RhcnRDb250YWluZWQpIHtcbiAgICAgIHJldHVybiBjcm9zc0F4aXNTdGFydCA8IGNoaWxkQ2VudGVyO1xuICAgIH1cbiAgICByZXR1cm4gY3Jvc3NBeGlzRW5kID4gY2hpbGRDZW50ZXI7XG4gIH0pO1xuICBpZiAoIWNhbmRpZGF0ZXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKGNhbmRpZGF0ZXMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGNhbmRpZGF0ZXNbMF0uZGVzY3JpcHRvci5pZDtcbiAgfVxuICByZXR1cm4gZ2V0RnVydGhlc3RBd2F5KHtcbiAgICBwYWdlQm9yZGVyQm94LFxuICAgIGRyYWdnYWJsZSxcbiAgICBjYW5kaWRhdGVzXG4gIH0pO1xufVxuXG5jb25zdCBvZmZzZXRSZWN0QnlQb3NpdGlvbiA9IChyZWN0LCBwb2ludCkgPT4gZ2V0UmVjdChvZmZzZXRCeVBvc2l0aW9uKHJlY3QsIHBvaW50KSk7XG5cbnZhciB3aXRoRHJvcHBhYmxlU2Nyb2xsID0gKChkcm9wcGFibGUsIGFyZWEpID0+IHtcbiAgY29uc3QgZnJhbWUgPSBkcm9wcGFibGUuZnJhbWU7XG4gIGlmICghZnJhbWUpIHtcbiAgICByZXR1cm4gYXJlYTtcbiAgfVxuICByZXR1cm4gb2Zmc2V0UmVjdEJ5UG9zaXRpb24oYXJlYSwgZnJhbWUuc2Nyb2xsLmRpZmYudmFsdWUpO1xufSk7XG5cbmZ1bmN0aW9uIGdldElzRGlzcGxhY2VkKHtcbiAgZGlzcGxhY2VkLFxuICBpZFxufSkge1xuICByZXR1cm4gQm9vbGVhbihkaXNwbGFjZWQudmlzaWJsZVtpZF0gfHwgZGlzcGxhY2VkLmludmlzaWJsZVtpZF0pO1xufVxuXG5mdW5jdGlvbiBhdEluZGV4KHtcbiAgZHJhZ2dhYmxlLFxuICBjbG9zZXN0LFxuICBpbkhvbWVMaXN0XG59KSB7XG4gIGlmICghY2xvc2VzdCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmICghaW5Ib21lTGlzdCkge1xuICAgIHJldHVybiBjbG9zZXN0LmRlc2NyaXB0b3IuaW5kZXg7XG4gIH1cbiAgaWYgKGNsb3Nlc3QuZGVzY3JpcHRvci5pbmRleCA+IGRyYWdnYWJsZS5kZXNjcmlwdG9yLmluZGV4KSB7XG4gICAgcmV0dXJuIGNsb3Nlc3QuZGVzY3JpcHRvci5pbmRleCAtIDE7XG4gIH1cbiAgcmV0dXJuIGNsb3Nlc3QuZGVzY3JpcHRvci5pbmRleDtcbn1cbnZhciBnZXRSZW9yZGVySW1wYWN0ID0gKCh7XG4gIHBhZ2VCb3JkZXJCb3hXaXRoRHJvcHBhYmxlU2Nyb2xsOiB0YXJnZXRSZWN0LFxuICBkcmFnZ2FibGUsXG4gIGRlc3RpbmF0aW9uLFxuICBpbnNpZGVEZXN0aW5hdGlvbixcbiAgbGFzdCxcbiAgdmlld3BvcnQsXG4gIGFmdGVyQ3JpdGljYWxcbn0pID0+IHtcbiAgY29uc3QgYXhpcyA9IGRlc3RpbmF0aW9uLmF4aXM7XG4gIGNvbnN0IGRpc3BsYWNlZEJ5ID0gZ2V0RGlzcGxhY2VkQnkoZGVzdGluYXRpb24uYXhpcywgZHJhZ2dhYmxlLmRpc3BsYWNlQnkpO1xuICBjb25zdCBkaXNwbGFjZW1lbnQgPSBkaXNwbGFjZWRCeS52YWx1ZTtcbiAgY29uc3QgdGFyZ2V0U3RhcnQgPSB0YXJnZXRSZWN0W2F4aXMuc3RhcnRdO1xuICBjb25zdCB0YXJnZXRFbmQgPSB0YXJnZXRSZWN0W2F4aXMuZW5kXTtcbiAgY29uc3Qgd2l0aG91dERyYWdnaW5nID0gcmVtb3ZlRHJhZ2dhYmxlRnJvbUxpc3QoZHJhZ2dhYmxlLCBpbnNpZGVEZXN0aW5hdGlvbik7XG4gIGNvbnN0IGNsb3Nlc3QgPSB3aXRob3V0RHJhZ2dpbmcuZmluZChjaGlsZCA9PiB7XG4gICAgY29uc3QgaWQgPSBjaGlsZC5kZXNjcmlwdG9yLmlkO1xuICAgIGNvbnN0IGNoaWxkQ2VudGVyID0gY2hpbGQucGFnZS5ib3JkZXJCb3guY2VudGVyW2F4aXMubGluZV07XG4gICAgY29uc3QgZGlkU3RhcnRBZnRlckNyaXRpY2FsJDEgPSBkaWRTdGFydEFmdGVyQ3JpdGljYWwoaWQsIGFmdGVyQ3JpdGljYWwpO1xuICAgIGNvbnN0IGlzRGlzcGxhY2VkID0gZ2V0SXNEaXNwbGFjZWQoe1xuICAgICAgZGlzcGxhY2VkOiBsYXN0LFxuICAgICAgaWRcbiAgICB9KTtcbiAgICBpZiAoZGlkU3RhcnRBZnRlckNyaXRpY2FsJDEpIHtcbiAgICAgIGlmIChpc0Rpc3BsYWNlZCkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0RW5kIDw9IGNoaWxkQ2VudGVyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhcmdldFN0YXJ0IDwgY2hpbGRDZW50ZXIgLSBkaXNwbGFjZW1lbnQ7XG4gICAgfVxuICAgIGlmIChpc0Rpc3BsYWNlZCkge1xuICAgICAgcmV0dXJuIHRhcmdldEVuZCA8PSBjaGlsZENlbnRlciArIGRpc3BsYWNlbWVudDtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldFN0YXJ0IDwgY2hpbGRDZW50ZXI7XG4gIH0pIHx8IG51bGw7XG4gIGNvbnN0IG5ld0luZGV4ID0gYXRJbmRleCh7XG4gICAgZHJhZ2dhYmxlLFxuICAgIGNsb3Nlc3QsXG4gICAgaW5Ib21lTGlzdDogaXNIb21lT2YoZHJhZ2dhYmxlLCBkZXN0aW5hdGlvbilcbiAgfSk7XG4gIHJldHVybiBjYWxjdWxhdGVSZW9yZGVySW1wYWN0KHtcbiAgICBkcmFnZ2FibGUsXG4gICAgaW5zaWRlRGVzdGluYXRpb24sXG4gICAgZGVzdGluYXRpb24sXG4gICAgdmlld3BvcnQsXG4gICAgbGFzdCxcbiAgICBkaXNwbGFjZWRCeSxcbiAgICBpbmRleDogbmV3SW5kZXhcbiAgfSk7XG59KTtcblxuY29uc3QgY29tYmluZVRocmVzaG9sZERpdmlzb3IgPSA0O1xudmFyIGdldENvbWJpbmVJbXBhY3QgPSAoKHtcbiAgZHJhZ2dhYmxlLFxuICBwYWdlQm9yZGVyQm94V2l0aERyb3BwYWJsZVNjcm9sbDogdGFyZ2V0UmVjdCxcbiAgcHJldmlvdXNJbXBhY3QsXG4gIGRlc3RpbmF0aW9uLFxuICBpbnNpZGVEZXN0aW5hdGlvbixcbiAgYWZ0ZXJDcml0aWNhbFxufSkgPT4ge1xuICBpZiAoIWRlc3RpbmF0aW9uLmlzQ29tYmluZUVuYWJsZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBheGlzID0gZGVzdGluYXRpb24uYXhpcztcbiAgY29uc3QgZGlzcGxhY2VkQnkgPSBnZXREaXNwbGFjZWRCeShkZXN0aW5hdGlvbi5heGlzLCBkcmFnZ2FibGUuZGlzcGxhY2VCeSk7XG4gIGNvbnN0IGRpc3BsYWNlbWVudCA9IGRpc3BsYWNlZEJ5LnZhbHVlO1xuICBjb25zdCB0YXJnZXRTdGFydCA9IHRhcmdldFJlY3RbYXhpcy5zdGFydF07XG4gIGNvbnN0IHRhcmdldEVuZCA9IHRhcmdldFJlY3RbYXhpcy5lbmRdO1xuICBjb25zdCB3aXRob3V0RHJhZ2dpbmcgPSByZW1vdmVEcmFnZ2FibGVGcm9tTGlzdChkcmFnZ2FibGUsIGluc2lkZURlc3RpbmF0aW9uKTtcbiAgY29uc3QgY29tYmluZVdpdGggPSB3aXRob3V0RHJhZ2dpbmcuZmluZChjaGlsZCA9PiB7XG4gICAgY29uc3QgaWQgPSBjaGlsZC5kZXNjcmlwdG9yLmlkO1xuICAgIGNvbnN0IGNoaWxkUmVjdCA9IGNoaWxkLnBhZ2UuYm9yZGVyQm94O1xuICAgIGNvbnN0IGNoaWxkU2l6ZSA9IGNoaWxkUmVjdFtheGlzLnNpemVdO1xuICAgIGNvbnN0IHRocmVzaG9sZCA9IGNoaWxkU2l6ZSAvIGNvbWJpbmVUaHJlc2hvbGREaXZpc29yO1xuICAgIGNvbnN0IGRpZFN0YXJ0QWZ0ZXJDcml0aWNhbCQxID0gZGlkU3RhcnRBZnRlckNyaXRpY2FsKGlkLCBhZnRlckNyaXRpY2FsKTtcbiAgICBjb25zdCBpc0Rpc3BsYWNlZCA9IGdldElzRGlzcGxhY2VkKHtcbiAgICAgIGRpc3BsYWNlZDogcHJldmlvdXNJbXBhY3QuZGlzcGxhY2VkLFxuICAgICAgaWRcbiAgICB9KTtcbiAgICBpZiAoZGlkU3RhcnRBZnRlckNyaXRpY2FsJDEpIHtcbiAgICAgIGlmIChpc0Rpc3BsYWNlZCkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0RW5kID4gY2hpbGRSZWN0W2F4aXMuc3RhcnRdICsgdGhyZXNob2xkICYmIHRhcmdldEVuZCA8IGNoaWxkUmVjdFtheGlzLmVuZF0gLSB0aHJlc2hvbGQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0U3RhcnQgPiBjaGlsZFJlY3RbYXhpcy5zdGFydF0gLSBkaXNwbGFjZW1lbnQgKyB0aHJlc2hvbGQgJiYgdGFyZ2V0U3RhcnQgPCBjaGlsZFJlY3RbYXhpcy5lbmRdIC0gZGlzcGxhY2VtZW50IC0gdGhyZXNob2xkO1xuICAgIH1cbiAgICBpZiAoaXNEaXNwbGFjZWQpIHtcbiAgICAgIHJldHVybiB0YXJnZXRFbmQgPiBjaGlsZFJlY3RbYXhpcy5zdGFydF0gKyBkaXNwbGFjZW1lbnQgKyB0aHJlc2hvbGQgJiYgdGFyZ2V0RW5kIDwgY2hpbGRSZWN0W2F4aXMuZW5kXSArIGRpc3BsYWNlbWVudCAtIHRocmVzaG9sZDtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldFN0YXJ0ID4gY2hpbGRSZWN0W2F4aXMuc3RhcnRdICsgdGhyZXNob2xkICYmIHRhcmdldFN0YXJ0IDwgY2hpbGRSZWN0W2F4aXMuZW5kXSAtIHRocmVzaG9sZDtcbiAgfSk7XG4gIGlmICghY29tYmluZVdpdGgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBpbXBhY3QgPSB7XG4gICAgZGlzcGxhY2VkQnksXG4gICAgZGlzcGxhY2VkOiBwcmV2aW91c0ltcGFjdC5kaXNwbGFjZWQsXG4gICAgYXQ6IHtcbiAgICAgIHR5cGU6ICdDT01CSU5FJyxcbiAgICAgIGNvbWJpbmU6IHtcbiAgICAgICAgZHJhZ2dhYmxlSWQ6IGNvbWJpbmVXaXRoLmRlc2NyaXB0b3IuaWQsXG4gICAgICAgIGRyb3BwYWJsZUlkOiBkZXN0aW5hdGlvbi5kZXNjcmlwdG9yLmlkXG4gICAgICB9XG4gICAgfVxuICB9O1xuICByZXR1cm4gaW1wYWN0O1xufSk7XG5cbnZhciBnZXREcmFnSW1wYWN0ID0gKCh7XG4gIHBhZ2VPZmZzZXQsXG4gIGRyYWdnYWJsZSxcbiAgZHJhZ2dhYmxlcyxcbiAgZHJvcHBhYmxlcyxcbiAgcHJldmlvdXNJbXBhY3QsXG4gIHZpZXdwb3J0LFxuICBhZnRlckNyaXRpY2FsXG59KSA9PiB7XG4gIGNvbnN0IHBhZ2VCb3JkZXJCb3ggPSBvZmZzZXRSZWN0QnlQb3NpdGlvbihkcmFnZ2FibGUucGFnZS5ib3JkZXJCb3gsIHBhZ2VPZmZzZXQpO1xuICBjb25zdCBkZXN0aW5hdGlvbklkID0gZ2V0RHJvcHBhYmxlT3Zlcih7XG4gICAgcGFnZUJvcmRlckJveCxcbiAgICBkcmFnZ2FibGUsXG4gICAgZHJvcHBhYmxlc1xuICB9KTtcbiAgaWYgKCFkZXN0aW5hdGlvbklkKSB7XG4gICAgcmV0dXJuIG5vSW1wYWN0JDE7XG4gIH1cbiAgY29uc3QgZGVzdGluYXRpb24gPSBkcm9wcGFibGVzW2Rlc3RpbmF0aW9uSWRdO1xuICBjb25zdCBpbnNpZGVEZXN0aW5hdGlvbiA9IGdldERyYWdnYWJsZXNJbnNpZGVEcm9wcGFibGUoZGVzdGluYXRpb24uZGVzY3JpcHRvci5pZCwgZHJhZ2dhYmxlcyk7XG4gIGNvbnN0IHBhZ2VCb3JkZXJCb3hXaXRoRHJvcHBhYmxlU2Nyb2xsID0gd2l0aERyb3BwYWJsZVNjcm9sbChkZXN0aW5hdGlvbiwgcGFnZUJvcmRlckJveCk7XG4gIHJldHVybiBnZXRDb21iaW5lSW1wYWN0KHtcbiAgICBwYWdlQm9yZGVyQm94V2l0aERyb3BwYWJsZVNjcm9sbCxcbiAgICBkcmFnZ2FibGUsXG4gICAgcHJldmlvdXNJbXBhY3QsXG4gICAgZGVzdGluYXRpb24sXG4gICAgaW5zaWRlRGVzdGluYXRpb24sXG4gICAgYWZ0ZXJDcml0aWNhbFxuICB9KSB8fCBnZXRSZW9yZGVySW1wYWN0KHtcbiAgICBwYWdlQm9yZGVyQm94V2l0aERyb3BwYWJsZVNjcm9sbCxcbiAgICBkcmFnZ2FibGUsXG4gICAgZGVzdGluYXRpb24sXG4gICAgaW5zaWRlRGVzdGluYXRpb24sXG4gICAgbGFzdDogcHJldmlvdXNJbXBhY3QuZGlzcGxhY2VkLFxuICAgIHZpZXdwb3J0LFxuICAgIGFmdGVyQ3JpdGljYWxcbiAgfSk7XG59KTtcblxudmFyIHBhdGNoRHJvcHBhYmxlTWFwID0gKChkcm9wcGFibGVzLCB1cGRhdGVkKSA9PiAoe1xuICAuLi5kcm9wcGFibGVzLFxuICBbdXBkYXRlZC5kZXNjcmlwdG9yLmlkXTogdXBkYXRlZFxufSkpO1xuXG5jb25zdCBjbGVhclVudXNlZFBsYWNlaG9sZGVyID0gKHtcbiAgcHJldmlvdXNJbXBhY3QsXG4gIGltcGFjdCxcbiAgZHJvcHBhYmxlc1xufSkgPT4ge1xuICBjb25zdCBsYXN0ID0gd2hhdElzRHJhZ2dlZE92ZXIocHJldmlvdXNJbXBhY3QpO1xuICBjb25zdCBub3cgPSB3aGF0SXNEcmFnZ2VkT3ZlcihpbXBhY3QpO1xuICBpZiAoIWxhc3QpIHtcbiAgICByZXR1cm4gZHJvcHBhYmxlcztcbiAgfVxuICBpZiAobGFzdCA9PT0gbm93KSB7XG4gICAgcmV0dXJuIGRyb3BwYWJsZXM7XG4gIH1cbiAgY29uc3QgbGFzdERyb3BwYWJsZSA9IGRyb3BwYWJsZXNbbGFzdF07XG4gIGlmICghbGFzdERyb3BwYWJsZS5zdWJqZWN0LndpdGhQbGFjZWhvbGRlcikge1xuICAgIHJldHVybiBkcm9wcGFibGVzO1xuICB9XG4gIGNvbnN0IHVwZGF0ZWQgPSByZW1vdmVQbGFjZWhvbGRlcihsYXN0RHJvcHBhYmxlKTtcbiAgcmV0dXJuIHBhdGNoRHJvcHBhYmxlTWFwKGRyb3BwYWJsZXMsIHVwZGF0ZWQpO1xufTtcbnZhciByZWNvbXB1dGVQbGFjZWhvbGRlcnMgPSAoKHtcbiAgZHJhZ2dhYmxlLFxuICBkcmFnZ2FibGVzLFxuICBkcm9wcGFibGVzLFxuICBwcmV2aW91c0ltcGFjdCxcbiAgaW1wYWN0XG59KSA9PiB7XG4gIGNvbnN0IGNsZWFuZWQgPSBjbGVhclVudXNlZFBsYWNlaG9sZGVyKHtcbiAgICBwcmV2aW91c0ltcGFjdCxcbiAgICBpbXBhY3QsXG4gICAgZHJvcHBhYmxlc1xuICB9KTtcbiAgY29uc3QgaXNPdmVyID0gd2hhdElzRHJhZ2dlZE92ZXIoaW1wYWN0KTtcbiAgaWYgKCFpc092ZXIpIHtcbiAgICByZXR1cm4gY2xlYW5lZDtcbiAgfVxuICBjb25zdCBkcm9wcGFibGUgPSBkcm9wcGFibGVzW2lzT3Zlcl07XG4gIGlmIChpc0hvbWVPZihkcmFnZ2FibGUsIGRyb3BwYWJsZSkpIHtcbiAgICByZXR1cm4gY2xlYW5lZDtcbiAgfVxuICBpZiAoZHJvcHBhYmxlLnN1YmplY3Qud2l0aFBsYWNlaG9sZGVyKSB7XG4gICAgcmV0dXJuIGNsZWFuZWQ7XG4gIH1cbiAgY29uc3QgcGF0Y2hlZCA9IGFkZFBsYWNlaG9sZGVyKGRyb3BwYWJsZSwgZHJhZ2dhYmxlLCBkcmFnZ2FibGVzKTtcbiAgcmV0dXJuIHBhdGNoRHJvcHBhYmxlTWFwKGNsZWFuZWQsIHBhdGNoZWQpO1xufSk7XG5cbnZhciB1cGRhdGUgPSAoKHtcbiAgc3RhdGUsXG4gIGNsaWVudFNlbGVjdGlvbjogZm9yY2VkQ2xpZW50U2VsZWN0aW9uLFxuICBkaW1lbnNpb25zOiBmb3JjZWREaW1lbnNpb25zLFxuICB2aWV3cG9ydDogZm9yY2VkVmlld3BvcnQsXG4gIGltcGFjdDogZm9yY2VkSW1wYWN0LFxuICBzY3JvbGxKdW1wUmVxdWVzdFxufSkgPT4ge1xuICBjb25zdCB2aWV3cG9ydCA9IGZvcmNlZFZpZXdwb3J0IHx8IHN0YXRlLnZpZXdwb3J0O1xuICBjb25zdCBkaW1lbnNpb25zID0gZm9yY2VkRGltZW5zaW9ucyB8fCBzdGF0ZS5kaW1lbnNpb25zO1xuICBjb25zdCBjbGllbnRTZWxlY3Rpb24gPSBmb3JjZWRDbGllbnRTZWxlY3Rpb24gfHwgc3RhdGUuY3VycmVudC5jbGllbnQuc2VsZWN0aW9uO1xuICBjb25zdCBvZmZzZXQgPSBzdWJ0cmFjdChjbGllbnRTZWxlY3Rpb24sIHN0YXRlLmluaXRpYWwuY2xpZW50LnNlbGVjdGlvbik7XG4gIGNvbnN0IGNsaWVudCA9IHtcbiAgICBvZmZzZXQsXG4gICAgc2VsZWN0aW9uOiBjbGllbnRTZWxlY3Rpb24sXG4gICAgYm9yZGVyQm94Q2VudGVyOiBhZGQoc3RhdGUuaW5pdGlhbC5jbGllbnQuYm9yZGVyQm94Q2VudGVyLCBvZmZzZXQpXG4gIH07XG4gIGNvbnN0IHBhZ2UgPSB7XG4gICAgc2VsZWN0aW9uOiBhZGQoY2xpZW50LnNlbGVjdGlvbiwgdmlld3BvcnQuc2Nyb2xsLmN1cnJlbnQpLFxuICAgIGJvcmRlckJveENlbnRlcjogYWRkKGNsaWVudC5ib3JkZXJCb3hDZW50ZXIsIHZpZXdwb3J0LnNjcm9sbC5jdXJyZW50KSxcbiAgICBvZmZzZXQ6IGFkZChjbGllbnQub2Zmc2V0LCB2aWV3cG9ydC5zY3JvbGwuZGlmZi52YWx1ZSlcbiAgfTtcbiAgY29uc3QgY3VycmVudCA9IHtcbiAgICBjbGllbnQsXG4gICAgcGFnZVxuICB9O1xuICBpZiAoc3RhdGUucGhhc2UgPT09ICdDT0xMRUNUSU5HJykge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIGRpbWVuc2lvbnMsXG4gICAgICB2aWV3cG9ydCxcbiAgICAgIGN1cnJlbnRcbiAgICB9O1xuICB9XG4gIGNvbnN0IGRyYWdnYWJsZSA9IGRpbWVuc2lvbnMuZHJhZ2dhYmxlc1tzdGF0ZS5jcml0aWNhbC5kcmFnZ2FibGUuaWRdO1xuICBjb25zdCBuZXdJbXBhY3QgPSBmb3JjZWRJbXBhY3QgfHwgZ2V0RHJhZ0ltcGFjdCh7XG4gICAgcGFnZU9mZnNldDogcGFnZS5vZmZzZXQsXG4gICAgZHJhZ2dhYmxlLFxuICAgIGRyYWdnYWJsZXM6IGRpbWVuc2lvbnMuZHJhZ2dhYmxlcyxcbiAgICBkcm9wcGFibGVzOiBkaW1lbnNpb25zLmRyb3BwYWJsZXMsXG4gICAgcHJldmlvdXNJbXBhY3Q6IHN0YXRlLmltcGFjdCxcbiAgICB2aWV3cG9ydCxcbiAgICBhZnRlckNyaXRpY2FsOiBzdGF0ZS5hZnRlckNyaXRpY2FsXG4gIH0pO1xuICBjb25zdCB3aXRoVXBkYXRlZFBsYWNlaG9sZGVycyA9IHJlY29tcHV0ZVBsYWNlaG9sZGVycyh7XG4gICAgZHJhZ2dhYmxlLFxuICAgIGltcGFjdDogbmV3SW1wYWN0LFxuICAgIHByZXZpb3VzSW1wYWN0OiBzdGF0ZS5pbXBhY3QsXG4gICAgZHJhZ2dhYmxlczogZGltZW5zaW9ucy5kcmFnZ2FibGVzLFxuICAgIGRyb3BwYWJsZXM6IGRpbWVuc2lvbnMuZHJvcHBhYmxlc1xuICB9KTtcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIC4uLnN0YXRlLFxuICAgIGN1cnJlbnQsXG4gICAgZGltZW5zaW9uczoge1xuICAgICAgZHJhZ2dhYmxlczogZGltZW5zaW9ucy5kcmFnZ2FibGVzLFxuICAgICAgZHJvcHBhYmxlczogd2l0aFVwZGF0ZWRQbGFjZWhvbGRlcnNcbiAgICB9LFxuICAgIGltcGFjdDogbmV3SW1wYWN0LFxuICAgIHZpZXdwb3J0LFxuICAgIHNjcm9sbEp1bXBSZXF1ZXN0OiBzY3JvbGxKdW1wUmVxdWVzdCB8fCBudWxsLFxuICAgIGZvcmNlU2hvdWxkQW5pbWF0ZTogc2Nyb2xsSnVtcFJlcXVlc3QgPyBmYWxzZSA6IG51bGxcbiAgfTtcbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuXG5mdW5jdGlvbiBnZXREcmFnZ2FibGVzKGlkcywgZHJhZ2dhYmxlcykge1xuICByZXR1cm4gaWRzLm1hcChpZCA9PiBkcmFnZ2FibGVzW2lkXSk7XG59XG52YXIgcmVjb21wdXRlID0gKCh7XG4gIGltcGFjdCxcbiAgdmlld3BvcnQsXG4gIGRyYWdnYWJsZXMsXG4gIGRlc3RpbmF0aW9uLFxuICBmb3JjZVNob3VsZEFuaW1hdGVcbn0pID0+IHtcbiAgY29uc3QgbGFzdCA9IGltcGFjdC5kaXNwbGFjZWQ7XG4gIGNvbnN0IGFmdGVyRHJhZ2dpbmcgPSBnZXREcmFnZ2FibGVzKGxhc3QuYWxsLCBkcmFnZ2FibGVzKTtcbiAgY29uc3QgZGlzcGxhY2VkID0gZ2V0RGlzcGxhY2VtZW50R3JvdXBzKHtcbiAgICBhZnRlckRyYWdnaW5nLFxuICAgIGRlc3RpbmF0aW9uLFxuICAgIGRpc3BsYWNlZEJ5OiBpbXBhY3QuZGlzcGxhY2VkQnksXG4gICAgdmlld3BvcnQ6IHZpZXdwb3J0LmZyYW1lLFxuICAgIGZvcmNlU2hvdWxkQW5pbWF0ZSxcbiAgICBsYXN0XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIC4uLmltcGFjdCxcbiAgICBkaXNwbGFjZWRcbiAgfTtcbn0pO1xuXG52YXIgZ2V0Q2xpZW50Qm9yZGVyQm94Q2VudGVyID0gKCh7XG4gIGltcGFjdCxcbiAgZHJhZ2dhYmxlLFxuICBkcm9wcGFibGUsXG4gIGRyYWdnYWJsZXMsXG4gIHZpZXdwb3J0LFxuICBhZnRlckNyaXRpY2FsXG59KSA9PiB7XG4gIGNvbnN0IHBhZ2VCb3JkZXJCb3hDZW50ZXIgPSBnZXRQYWdlQm9yZGVyQm94Q2VudGVyRnJvbUltcGFjdCh7XG4gICAgaW1wYWN0LFxuICAgIGRyYWdnYWJsZSxcbiAgICBkcmFnZ2FibGVzLFxuICAgIGRyb3BwYWJsZSxcbiAgICBhZnRlckNyaXRpY2FsXG4gIH0pO1xuICByZXR1cm4gZ2V0Q2xpZW50RnJvbVBhZ2VCb3JkZXJCb3hDZW50ZXIoe1xuICAgIHBhZ2VCb3JkZXJCb3hDZW50ZXIsXG4gICAgZHJhZ2dhYmxlLFxuICAgIHZpZXdwb3J0XG4gIH0pO1xufSk7XG5cbnZhciByZWZyZXNoU25hcCA9ICgoe1xuICBzdGF0ZSxcbiAgZGltZW5zaW9uczogZm9yY2VkRGltZW5zaW9ucyxcbiAgdmlld3BvcnQ6IGZvcmNlZFZpZXdwb3J0XG59KSA9PiB7XG4gICEoc3RhdGUubW92ZW1lbnRNb2RlID09PSAnU05BUCcpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIGNvbnN0IG5lZWRzVmlzaWJpbGl0eUNoZWNrID0gc3RhdGUuaW1wYWN0O1xuICBjb25zdCB2aWV3cG9ydCA9IGZvcmNlZFZpZXdwb3J0IHx8IHN0YXRlLnZpZXdwb3J0O1xuICBjb25zdCBkaW1lbnNpb25zID0gZm9yY2VkRGltZW5zaW9ucyB8fCBzdGF0ZS5kaW1lbnNpb25zO1xuICBjb25zdCB7XG4gICAgZHJhZ2dhYmxlcyxcbiAgICBkcm9wcGFibGVzXG4gIH0gPSBkaW1lbnNpb25zO1xuICBjb25zdCBkcmFnZ2FibGUgPSBkcmFnZ2FibGVzW3N0YXRlLmNyaXRpY2FsLmRyYWdnYWJsZS5pZF07XG4gIGNvbnN0IGlzT3ZlciA9IHdoYXRJc0RyYWdnZWRPdmVyKG5lZWRzVmlzaWJpbGl0eUNoZWNrKTtcbiAgIWlzT3ZlciA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ011c3QgYmUgb3ZlciBhIGRlc3RpbmF0aW9uIGluIFNOQVAgbW92ZW1lbnQgbW9kZScpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgY29uc3QgZGVzdGluYXRpb24gPSBkcm9wcGFibGVzW2lzT3Zlcl07XG4gIGNvbnN0IGltcGFjdCA9IHJlY29tcHV0ZSh7XG4gICAgaW1wYWN0OiBuZWVkc1Zpc2liaWxpdHlDaGVjayxcbiAgICB2aWV3cG9ydCxcbiAgICBkZXN0aW5hdGlvbixcbiAgICBkcmFnZ2FibGVzXG4gIH0pO1xuICBjb25zdCBjbGllbnRTZWxlY3Rpb24gPSBnZXRDbGllbnRCb3JkZXJCb3hDZW50ZXIoe1xuICAgIGltcGFjdCxcbiAgICBkcmFnZ2FibGUsXG4gICAgZHJvcHBhYmxlOiBkZXN0aW5hdGlvbixcbiAgICBkcmFnZ2FibGVzLFxuICAgIHZpZXdwb3J0LFxuICAgIGFmdGVyQ3JpdGljYWw6IHN0YXRlLmFmdGVyQ3JpdGljYWxcbiAgfSk7XG4gIHJldHVybiB1cGRhdGUoe1xuICAgIGltcGFjdCxcbiAgICBjbGllbnRTZWxlY3Rpb24sXG4gICAgc3RhdGUsXG4gICAgZGltZW5zaW9ucyxcbiAgICB2aWV3cG9ydFxuICB9KTtcbn0pO1xuXG52YXIgZ2V0SG9tZUxvY2F0aW9uID0gKGRlc2NyaXB0b3IgPT4gKHtcbiAgaW5kZXg6IGRlc2NyaXB0b3IuaW5kZXgsXG4gIGRyb3BwYWJsZUlkOiBkZXNjcmlwdG9yLmRyb3BwYWJsZUlkXG59KSk7XG5cbnZhciBnZXRMaWZ0RWZmZWN0ID0gKCh7XG4gIGRyYWdnYWJsZSxcbiAgaG9tZSxcbiAgZHJhZ2dhYmxlcyxcbiAgdmlld3BvcnRcbn0pID0+IHtcbiAgY29uc3QgZGlzcGxhY2VkQnkgPSBnZXREaXNwbGFjZWRCeShob21lLmF4aXMsIGRyYWdnYWJsZS5kaXNwbGFjZUJ5KTtcbiAgY29uc3QgaW5zaWRlSG9tZSA9IGdldERyYWdnYWJsZXNJbnNpZGVEcm9wcGFibGUoaG9tZS5kZXNjcmlwdG9yLmlkLCBkcmFnZ2FibGVzKTtcbiAgY29uc3QgcmF3SW5kZXggPSBpbnNpZGVIb21lLmluZGV4T2YoZHJhZ2dhYmxlKTtcbiAgIShyYXdJbmRleCAhPT0gLTEpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgZHJhZ2dhYmxlIHRvIGJlIGluc2lkZSBob21lIGxpc3QnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIGNvbnN0IGFmdGVyRHJhZ2dpbmcgPSBpbnNpZGVIb21lLnNsaWNlKHJhd0luZGV4ICsgMSk7XG4gIGNvbnN0IGVmZmVjdGVkID0gYWZ0ZXJEcmFnZ2luZy5yZWR1Y2UoKHByZXZpb3VzLCBpdGVtKSA9PiB7XG4gICAgcHJldmlvdXNbaXRlbS5kZXNjcmlwdG9yLmlkXSA9IHRydWU7XG4gICAgcmV0dXJuIHByZXZpb3VzO1xuICB9LCB7fSk7XG4gIGNvbnN0IGFmdGVyQ3JpdGljYWwgPSB7XG4gICAgaW5WaXJ0dWFsTGlzdDogaG9tZS5kZXNjcmlwdG9yLm1vZGUgPT09ICd2aXJ0dWFsJyxcbiAgICBkaXNwbGFjZWRCeSxcbiAgICBlZmZlY3RlZFxuICB9O1xuICBjb25zdCBkaXNwbGFjZWQgPSBnZXREaXNwbGFjZW1lbnRHcm91cHMoe1xuICAgIGFmdGVyRHJhZ2dpbmcsXG4gICAgZGVzdGluYXRpb246IGhvbWUsXG4gICAgZGlzcGxhY2VkQnksXG4gICAgbGFzdDogbnVsbCxcbiAgICB2aWV3cG9ydDogdmlld3BvcnQuZnJhbWUsXG4gICAgZm9yY2VTaG91bGRBbmltYXRlOiBmYWxzZVxuICB9KTtcbiAgY29uc3QgaW1wYWN0ID0ge1xuICAgIGRpc3BsYWNlZCxcbiAgICBkaXNwbGFjZWRCeSxcbiAgICBhdDoge1xuICAgICAgdHlwZTogJ1JFT1JERVInLFxuICAgICAgZGVzdGluYXRpb246IGdldEhvbWVMb2NhdGlvbihkcmFnZ2FibGUuZGVzY3JpcHRvcilcbiAgICB9XG4gIH07XG4gIHJldHVybiB7XG4gICAgaW1wYWN0LFxuICAgIGFmdGVyQ3JpdGljYWxcbiAgfTtcbn0pO1xuXG52YXIgcGF0Y2hEaW1lbnNpb25NYXAgPSAoKGRpbWVuc2lvbnMsIHVwZGF0ZWQpID0+ICh7XG4gIGRyYWdnYWJsZXM6IGRpbWVuc2lvbnMuZHJhZ2dhYmxlcyxcbiAgZHJvcHBhYmxlczogcGF0Y2hEcm9wcGFibGVNYXAoZGltZW5zaW9ucy5kcm9wcGFibGVzLCB1cGRhdGVkKVxufSkpO1xuXG5jb25zdCBzdGFydCA9IGtleSA9PiB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxufTtcbmNvbnN0IGZpbmlzaCA9IGtleSA9PiB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxufTtcblxudmFyIG9mZnNldERyYWdnYWJsZSA9ICgoe1xuICBkcmFnZ2FibGUsXG4gIG9mZnNldDogb2Zmc2V0JDEsXG4gIGluaXRpYWxXaW5kb3dTY3JvbGxcbn0pID0+IHtcbiAgY29uc3QgY2xpZW50ID0gb2Zmc2V0KGRyYWdnYWJsZS5jbGllbnQsIG9mZnNldCQxKTtcbiAgY29uc3QgcGFnZSA9IHdpdGhTY3JvbGwoY2xpZW50LCBpbml0aWFsV2luZG93U2Nyb2xsKTtcbiAgY29uc3QgbW92ZWQgPSB7XG4gICAgLi4uZHJhZ2dhYmxlLFxuICAgIHBsYWNlaG9sZGVyOiB7XG4gICAgICAuLi5kcmFnZ2FibGUucGxhY2Vob2xkZXIsXG4gICAgICBjbGllbnRcbiAgICB9LFxuICAgIGNsaWVudCxcbiAgICBwYWdlXG4gIH07XG4gIHJldHVybiBtb3ZlZDtcbn0pO1xuXG52YXIgZ2V0RnJhbWUgPSAoZHJvcHBhYmxlID0+IHtcbiAgY29uc3QgZnJhbWUgPSBkcm9wcGFibGUuZnJhbWU7XG4gICFmcmFtZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIERyb3BwYWJsZSB0byBoYXZlIGEgZnJhbWUnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIHJldHVybiBmcmFtZTtcbn0pO1xuXG52YXIgYWRqdXN0QWRkaXRpb25zRm9yU2Nyb2xsQ2hhbmdlcyA9ICgoe1xuICBhZGRpdGlvbnMsXG4gIHVwZGF0ZWREcm9wcGFibGVzLFxuICB2aWV3cG9ydFxufSkgPT4ge1xuICBjb25zdCB3aW5kb3dTY3JvbGxDaGFuZ2UgPSB2aWV3cG9ydC5zY3JvbGwuZGlmZi52YWx1ZTtcbiAgcmV0dXJuIGFkZGl0aW9ucy5tYXAoZHJhZ2dhYmxlID0+IHtcbiAgICBjb25zdCBkcm9wcGFibGVJZCA9IGRyYWdnYWJsZS5kZXNjcmlwdG9yLmRyb3BwYWJsZUlkO1xuICAgIGNvbnN0IG1vZGlmaWVkID0gdXBkYXRlZERyb3BwYWJsZXNbZHJvcHBhYmxlSWRdO1xuICAgIGNvbnN0IGZyYW1lID0gZ2V0RnJhbWUobW9kaWZpZWQpO1xuICAgIGNvbnN0IGRyb3BwYWJsZVNjcm9sbENoYW5nZSA9IGZyYW1lLnNjcm9sbC5kaWZmLnZhbHVlO1xuICAgIGNvbnN0IHRvdGFsQ2hhbmdlID0gYWRkKHdpbmRvd1Njcm9sbENoYW5nZSwgZHJvcHBhYmxlU2Nyb2xsQ2hhbmdlKTtcbiAgICBjb25zdCBtb3ZlZCA9IG9mZnNldERyYWdnYWJsZSh7XG4gICAgICBkcmFnZ2FibGUsXG4gICAgICBvZmZzZXQ6IHRvdGFsQ2hhbmdlLFxuICAgICAgaW5pdGlhbFdpbmRvd1Njcm9sbDogdmlld3BvcnQuc2Nyb2xsLmluaXRpYWxcbiAgICB9KTtcbiAgICByZXR1cm4gbW92ZWQ7XG4gIH0pO1xufSk7XG5cbmNvbnN0IHRpbWluZ3NLZXkgPSAnUHJvY2Vzc2luZyBkeW5hbWljIGNoYW5nZXMnO1xudmFyIHB1Ymxpc2hXaGlsZURyYWdnaW5nSW5WaXJ0dWFsID0gKCh7XG4gIHN0YXRlLFxuICBwdWJsaXNoZWRcbn0pID0+IHtcbiAgc3RhcnQoKTtcbiAgY29uc3Qgd2l0aFNjcm9sbENoYW5nZSA9IHB1Ymxpc2hlZC5tb2RpZmllZC5tYXAodXBkYXRlID0+IHtcbiAgICBjb25zdCBleGlzdGluZyA9IHN0YXRlLmRpbWVuc2lvbnMuZHJvcHBhYmxlc1t1cGRhdGUuZHJvcHBhYmxlSWRdO1xuICAgIGNvbnN0IHNjcm9sbGVkID0gc2Nyb2xsRHJvcHBhYmxlKGV4aXN0aW5nLCB1cGRhdGUuc2Nyb2xsKTtcbiAgICByZXR1cm4gc2Nyb2xsZWQ7XG4gIH0pO1xuICBjb25zdCBkcm9wcGFibGVzID0ge1xuICAgIC4uLnN0YXRlLmRpbWVuc2lvbnMuZHJvcHBhYmxlcyxcbiAgICAuLi50b0Ryb3BwYWJsZU1hcCh3aXRoU2Nyb2xsQ2hhbmdlKVxuICB9O1xuICBjb25zdCB1cGRhdGVkQWRkaXRpb25zID0gdG9EcmFnZ2FibGVNYXAoYWRqdXN0QWRkaXRpb25zRm9yU2Nyb2xsQ2hhbmdlcyh7XG4gICAgYWRkaXRpb25zOiBwdWJsaXNoZWQuYWRkaXRpb25zLFxuICAgIHVwZGF0ZWREcm9wcGFibGVzOiBkcm9wcGFibGVzLFxuICAgIHZpZXdwb3J0OiBzdGF0ZS52aWV3cG9ydFxuICB9KSk7XG4gIGNvbnN0IGRyYWdnYWJsZXMgPSB7XG4gICAgLi4uc3RhdGUuZGltZW5zaW9ucy5kcmFnZ2FibGVzLFxuICAgIC4uLnVwZGF0ZWRBZGRpdGlvbnNcbiAgfTtcbiAgcHVibGlzaGVkLnJlbW92YWxzLmZvckVhY2goaWQgPT4ge1xuICAgIGRlbGV0ZSBkcmFnZ2FibGVzW2lkXTtcbiAgfSk7XG4gIGNvbnN0IGRpbWVuc2lvbnMgPSB7XG4gICAgZHJvcHBhYmxlcyxcbiAgICBkcmFnZ2FibGVzXG4gIH07XG4gIGNvbnN0IHdhc092ZXJJZCA9IHdoYXRJc0RyYWdnZWRPdmVyKHN0YXRlLmltcGFjdCk7XG4gIGNvbnN0IHdhc092ZXIgPSB3YXNPdmVySWQgPyBkaW1lbnNpb25zLmRyb3BwYWJsZXNbd2FzT3ZlcklkXSA6IG51bGw7XG4gIGNvbnN0IGRyYWdnYWJsZSA9IGRpbWVuc2lvbnMuZHJhZ2dhYmxlc1tzdGF0ZS5jcml0aWNhbC5kcmFnZ2FibGUuaWRdO1xuICBjb25zdCBob21lID0gZGltZW5zaW9ucy5kcm9wcGFibGVzW3N0YXRlLmNyaXRpY2FsLmRyb3BwYWJsZS5pZF07XG4gIGNvbnN0IHtcbiAgICBpbXBhY3Q6IG9uTGlmdEltcGFjdCxcbiAgICBhZnRlckNyaXRpY2FsXG4gIH0gPSBnZXRMaWZ0RWZmZWN0KHtcbiAgICBkcmFnZ2FibGUsXG4gICAgaG9tZSxcbiAgICBkcmFnZ2FibGVzLFxuICAgIHZpZXdwb3J0OiBzdGF0ZS52aWV3cG9ydFxuICB9KTtcbiAgY29uc3QgcHJldmlvdXNJbXBhY3QgPSB3YXNPdmVyICYmIHdhc092ZXIuaXNDb21iaW5lRW5hYmxlZCA/IHN0YXRlLmltcGFjdCA6IG9uTGlmdEltcGFjdDtcbiAgY29uc3QgaW1wYWN0ID0gZ2V0RHJhZ0ltcGFjdCh7XG4gICAgcGFnZU9mZnNldDogc3RhdGUuY3VycmVudC5wYWdlLm9mZnNldCxcbiAgICBkcmFnZ2FibGU6IGRpbWVuc2lvbnMuZHJhZ2dhYmxlc1tzdGF0ZS5jcml0aWNhbC5kcmFnZ2FibGUuaWRdLFxuICAgIGRyYWdnYWJsZXM6IGRpbWVuc2lvbnMuZHJhZ2dhYmxlcyxcbiAgICBkcm9wcGFibGVzOiBkaW1lbnNpb25zLmRyb3BwYWJsZXMsXG4gICAgcHJldmlvdXNJbXBhY3QsXG4gICAgdmlld3BvcnQ6IHN0YXRlLnZpZXdwb3J0LFxuICAgIGFmdGVyQ3JpdGljYWxcbiAgfSk7XG4gIGZpbmlzaCh0aW1pbmdzS2V5KTtcbiAgY29uc3QgZHJhZ2dpbmdTdGF0ZSA9IHtcbiAgICAuLi5zdGF0ZSxcbiAgICBwaGFzZTogJ0RSQUdHSU5HJyxcbiAgICBpbXBhY3QsXG4gICAgb25MaWZ0SW1wYWN0LFxuICAgIGRpbWVuc2lvbnMsXG4gICAgYWZ0ZXJDcml0aWNhbCxcbiAgICBmb3JjZVNob3VsZEFuaW1hdGU6IGZhbHNlXG4gIH07XG4gIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0NPTExFQ1RJTkcnKSB7XG4gICAgcmV0dXJuIGRyYWdnaW5nU3RhdGU7XG4gIH1cbiAgY29uc3QgZHJvcFBlbmRpbmcgPSB7XG4gICAgLi4uZHJhZ2dpbmdTdGF0ZSxcbiAgICBwaGFzZTogJ0RST1BfUEVORElORycsXG4gICAgcmVhc29uOiBzdGF0ZS5yZWFzb24sXG4gICAgaXNXYWl0aW5nOiBmYWxzZVxuICB9O1xuICByZXR1cm4gZHJvcFBlbmRpbmc7XG59KTtcblxuY29uc3QgaXNTbmFwcGluZyA9IHN0YXRlID0+IHN0YXRlLm1vdmVtZW50TW9kZSA9PT0gJ1NOQVAnO1xuY29uc3QgcG9zdERyb3BwYWJsZUNoYW5nZSA9IChzdGF0ZSwgdXBkYXRlZCwgaXNFbmFibGVkQ2hhbmdpbmcpID0+IHtcbiAgY29uc3QgZGltZW5zaW9ucyA9IHBhdGNoRGltZW5zaW9uTWFwKHN0YXRlLmRpbWVuc2lvbnMsIHVwZGF0ZWQpO1xuICBpZiAoIWlzU25hcHBpbmcoc3RhdGUpIHx8IGlzRW5hYmxlZENoYW5naW5nKSB7XG4gICAgcmV0dXJuIHVwZGF0ZSh7XG4gICAgICBzdGF0ZSxcbiAgICAgIGRpbWVuc2lvbnNcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcmVmcmVzaFNuYXAoe1xuICAgIHN0YXRlLFxuICAgIGRpbWVuc2lvbnNcbiAgfSk7XG59O1xuZnVuY3Rpb24gcmVtb3ZlU2Nyb2xsSnVtcFJlcXVlc3Qoc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmlzRHJhZ2dpbmcgJiYgc3RhdGUubW92ZW1lbnRNb2RlID09PSAnU05BUCcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc3RhdGUsXG4gICAgICBzY3JvbGxKdW1wUmVxdWVzdDogbnVsbFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHN0YXRlO1xufVxuY29uc3QgaWRsZSQyID0ge1xuICBwaGFzZTogJ0lETEUnLFxuICBjb21wbGV0ZWQ6IG51bGwsXG4gIHNob3VsZEZsdXNoOiBmYWxzZVxufTtcbnZhciByZWR1Y2VyID0gKChzdGF0ZSA9IGlkbGUkMiwgYWN0aW9uKSA9PiB7XG4gIGlmIChhY3Rpb24udHlwZSA9PT0gJ0ZMVVNIJykge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5pZGxlJDIsXG4gICAgICBzaG91bGRGbHVzaDogdHJ1ZVxuICAgIH07XG4gIH1cbiAgaWYgKGFjdGlvbi50eXBlID09PSAnSU5JVElBTF9QVUJMSVNIJykge1xuICAgICEoc3RhdGUucGhhc2UgPT09ICdJRExFJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdJTklUSUFMX1BVQkxJU0ggbXVzdCBjb21lIGFmdGVyIGEgSURMRSBwaGFzZScpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBjb25zdCB7XG4gICAgICBjcml0aWNhbCxcbiAgICAgIGNsaWVudFNlbGVjdGlvbixcbiAgICAgIHZpZXdwb3J0LFxuICAgICAgZGltZW5zaW9ucyxcbiAgICAgIG1vdmVtZW50TW9kZVxuICAgIH0gPSBhY3Rpb24ucGF5bG9hZDtcbiAgICBjb25zdCBkcmFnZ2FibGUgPSBkaW1lbnNpb25zLmRyYWdnYWJsZXNbY3JpdGljYWwuZHJhZ2dhYmxlLmlkXTtcbiAgICBjb25zdCBob21lID0gZGltZW5zaW9ucy5kcm9wcGFibGVzW2NyaXRpY2FsLmRyb3BwYWJsZS5pZF07XG4gICAgY29uc3QgY2xpZW50ID0ge1xuICAgICAgc2VsZWN0aW9uOiBjbGllbnRTZWxlY3Rpb24sXG4gICAgICBib3JkZXJCb3hDZW50ZXI6IGRyYWdnYWJsZS5jbGllbnQuYm9yZGVyQm94LmNlbnRlcixcbiAgICAgIG9mZnNldDogb3JpZ2luXG4gICAgfTtcbiAgICBjb25zdCBpbml0aWFsID0ge1xuICAgICAgY2xpZW50LFxuICAgICAgcGFnZToge1xuICAgICAgICBzZWxlY3Rpb246IGFkZChjbGllbnQuc2VsZWN0aW9uLCB2aWV3cG9ydC5zY3JvbGwuaW5pdGlhbCksXG4gICAgICAgIGJvcmRlckJveENlbnRlcjogYWRkKGNsaWVudC5zZWxlY3Rpb24sIHZpZXdwb3J0LnNjcm9sbC5pbml0aWFsKSxcbiAgICAgICAgb2Zmc2V0OiBhZGQoY2xpZW50LnNlbGVjdGlvbiwgdmlld3BvcnQuc2Nyb2xsLmRpZmYudmFsdWUpXG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBpc1dpbmRvd1Njcm9sbEFsbG93ZWQgPSB0b0Ryb3BwYWJsZUxpc3QoZGltZW5zaW9ucy5kcm9wcGFibGVzKS5ldmVyeShpdGVtID0+ICFpdGVtLmlzRml4ZWRPblBhZ2UpO1xuICAgIGNvbnN0IHtcbiAgICAgIGltcGFjdCxcbiAgICAgIGFmdGVyQ3JpdGljYWxcbiAgICB9ID0gZ2V0TGlmdEVmZmVjdCh7XG4gICAgICBkcmFnZ2FibGUsXG4gICAgICBob21lLFxuICAgICAgZHJhZ2dhYmxlczogZGltZW5zaW9ucy5kcmFnZ2FibGVzLFxuICAgICAgdmlld3BvcnRcbiAgICB9KTtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICBwaGFzZTogJ0RSQUdHSU5HJyxcbiAgICAgIGlzRHJhZ2dpbmc6IHRydWUsXG4gICAgICBjcml0aWNhbCxcbiAgICAgIG1vdmVtZW50TW9kZSxcbiAgICAgIGRpbWVuc2lvbnMsXG4gICAgICBpbml0aWFsLFxuICAgICAgY3VycmVudDogaW5pdGlhbCxcbiAgICAgIGlzV2luZG93U2Nyb2xsQWxsb3dlZCxcbiAgICAgIGltcGFjdCxcbiAgICAgIGFmdGVyQ3JpdGljYWwsXG4gICAgICBvbkxpZnRJbXBhY3Q6IGltcGFjdCxcbiAgICAgIHZpZXdwb3J0LFxuICAgICAgc2Nyb2xsSnVtcFJlcXVlc3Q6IG51bGwsXG4gICAgICBmb3JjZVNob3VsZEFuaW1hdGU6IG51bGxcbiAgICB9O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaWYgKGFjdGlvbi50eXBlID09PSAnQ09MTEVDVElPTl9TVEFSVElORycpIHtcbiAgICBpZiAoc3RhdGUucGhhc2UgPT09ICdDT0xMRUNUSU5HJyB8fCBzdGF0ZS5waGFzZSA9PT0gJ0RST1BfUEVORElORycpIHtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG4gICAgIShzdGF0ZS5waGFzZSA9PT0gJ0RSQUdHSU5HJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGBDb2xsZWN0aW9uIGNhbm5vdCBzdGFydCBmcm9tIHBoYXNlICR7c3RhdGUucGhhc2V9YCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgcGhhc2U6ICdDT0xMRUNUSU5HJ1xuICAgIH07XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpZiAoYWN0aW9uLnR5cGUgPT09ICdQVUJMSVNIX1dISUxFX0RSQUdHSU5HJykge1xuICAgICEoc3RhdGUucGhhc2UgPT09ICdDT0xMRUNUSU5HJyB8fCBzdGF0ZS5waGFzZSA9PT0gJ0RST1BfUEVORElORycpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBgVW5leHBlY3RlZCAke2FjdGlvbi50eXBlfSByZWNlaXZlZCBpbiBwaGFzZSAke3N0YXRlLnBoYXNlfWApIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gcHVibGlzaFdoaWxlRHJhZ2dpbmdJblZpcnR1YWwoe1xuICAgICAgc3RhdGUsXG4gICAgICBwdWJsaXNoZWQ6IGFjdGlvbi5wYXlsb2FkXG4gICAgfSk7XG4gIH1cbiAgaWYgKGFjdGlvbi50eXBlID09PSAnTU9WRScpIHtcbiAgICBpZiAoc3RhdGUucGhhc2UgPT09ICdEUk9QX1BFTkRJTkcnKSB7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgICFpc01vdmVtZW50QWxsb3dlZChzdGF0ZSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGAke2FjdGlvbi50eXBlfSBub3QgcGVybWl0dGVkIGluIHBoYXNlICR7c3RhdGUucGhhc2V9YCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIGNvbnN0IHtcbiAgICAgIGNsaWVudDogY2xpZW50U2VsZWN0aW9uXG4gICAgfSA9IGFjdGlvbi5wYXlsb2FkO1xuICAgIGlmIChpc0VxdWFsJDEoY2xpZW50U2VsZWN0aW9uLCBzdGF0ZS5jdXJyZW50LmNsaWVudC5zZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgIHJldHVybiB1cGRhdGUoe1xuICAgICAgc3RhdGUsXG4gICAgICBjbGllbnRTZWxlY3Rpb24sXG4gICAgICBpbXBhY3Q6IGlzU25hcHBpbmcoc3RhdGUpID8gc3RhdGUuaW1wYWN0IDogbnVsbFxuICAgIH0pO1xuICB9XG4gIGlmIChhY3Rpb24udHlwZSA9PT0gJ1VQREFURV9EUk9QUEFCTEVfU0NST0xMJykge1xuICAgIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0RST1BfUEVORElORycpIHtcbiAgICAgIHJldHVybiByZW1vdmVTY3JvbGxKdW1wUmVxdWVzdChzdGF0ZSk7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0NPTExFQ1RJTkcnKSB7XG4gICAgICByZXR1cm4gcmVtb3ZlU2Nyb2xsSnVtcFJlcXVlc3Qoc3RhdGUpO1xuICAgIH1cbiAgICAhaXNNb3ZlbWVudEFsbG93ZWQoc3RhdGUpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBgJHthY3Rpb24udHlwZX0gbm90IHBlcm1pdHRlZCBpbiBwaGFzZSAke3N0YXRlLnBoYXNlfWApIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBjb25zdCB7XG4gICAgICBpZCxcbiAgICAgIG5ld1Njcm9sbFxuICAgIH0gPSBhY3Rpb24ucGF5bG9hZDtcbiAgICBjb25zdCB0YXJnZXQgPSBzdGF0ZS5kaW1lbnNpb25zLmRyb3BwYWJsZXNbaWRdO1xuICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgIGNvbnN0IHNjcm9sbGVkID0gc2Nyb2xsRHJvcHBhYmxlKHRhcmdldCwgbmV3U2Nyb2xsKTtcbiAgICByZXR1cm4gcG9zdERyb3BwYWJsZUNoYW5nZShzdGF0ZSwgc2Nyb2xsZWQsIGZhbHNlKTtcbiAgfVxuICBpZiAoYWN0aW9uLnR5cGUgPT09ICdVUERBVEVfRFJPUFBBQkxFX0lTX0VOQUJMRUQnKSB7XG4gICAgaWYgKHN0YXRlLnBoYXNlID09PSAnRFJPUF9QRU5ESU5HJykge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICAhaXNNb3ZlbWVudEFsbG93ZWQoc3RhdGUpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBgQXR0ZW1wdGluZyB0byBtb3ZlIGluIGFuIHVuc3VwcG9ydGVkIHBoYXNlICR7c3RhdGUucGhhc2V9YCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIGNvbnN0IHtcbiAgICAgIGlkLFxuICAgICAgaXNFbmFibGVkXG4gICAgfSA9IGFjdGlvbi5wYXlsb2FkO1xuICAgIGNvbnN0IHRhcmdldCA9IHN0YXRlLmRpbWVuc2lvbnMuZHJvcHBhYmxlc1tpZF07XG4gICAgIXRhcmdldCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYENhbm5vdCBmaW5kIERyb3BwYWJsZVtpZDogJHtpZH1dIHRvIHRvZ2dsZSBpdHMgZW5hYmxlZCBzdGF0ZWApIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAhKHRhcmdldC5pc0VuYWJsZWQgIT09IGlzRW5hYmxlZCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGBUcnlpbmcgdG8gc2V0IGRyb3BwYWJsZSBpc0VuYWJsZWQgdG8gJHtTdHJpbmcoaXNFbmFibGVkKX1cbiAgICAgIGJ1dCBpdCBpcyBhbHJlYWR5ICR7U3RyaW5nKHRhcmdldC5pc0VuYWJsZWQpfWApIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBjb25zdCB1cGRhdGVkID0ge1xuICAgICAgLi4udGFyZ2V0LFxuICAgICAgaXNFbmFibGVkXG4gICAgfTtcbiAgICByZXR1cm4gcG9zdERyb3BwYWJsZUNoYW5nZShzdGF0ZSwgdXBkYXRlZCwgdHJ1ZSk7XG4gIH1cbiAgaWYgKGFjdGlvbi50eXBlID09PSAnVVBEQVRFX0RST1BQQUJMRV9JU19DT01CSU5FX0VOQUJMRUQnKSB7XG4gICAgaWYgKHN0YXRlLnBoYXNlID09PSAnRFJPUF9QRU5ESU5HJykge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICAhaXNNb3ZlbWVudEFsbG93ZWQoc3RhdGUpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBgQXR0ZW1wdGluZyB0byBtb3ZlIGluIGFuIHVuc3VwcG9ydGVkIHBoYXNlICR7c3RhdGUucGhhc2V9YCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIGNvbnN0IHtcbiAgICAgIGlkLFxuICAgICAgaXNDb21iaW5lRW5hYmxlZFxuICAgIH0gPSBhY3Rpb24ucGF5bG9hZDtcbiAgICBjb25zdCB0YXJnZXQgPSBzdGF0ZS5kaW1lbnNpb25zLmRyb3BwYWJsZXNbaWRdO1xuICAgICF0YXJnZXQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGBDYW5ub3QgZmluZCBEcm9wcGFibGVbaWQ6ICR7aWR9XSB0byB0b2dnbGUgaXRzIGlzQ29tYmluZUVuYWJsZWQgc3RhdGVgKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgISh0YXJnZXQuaXNDb21iaW5lRW5hYmxlZCAhPT0gaXNDb21iaW5lRW5hYmxlZCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGBUcnlpbmcgdG8gc2V0IGRyb3BwYWJsZSBpc0NvbWJpbmVFbmFibGVkIHRvICR7U3RyaW5nKGlzQ29tYmluZUVuYWJsZWQpfVxuICAgICAgYnV0IGl0IGlzIGFscmVhZHkgJHtTdHJpbmcodGFyZ2V0LmlzQ29tYmluZUVuYWJsZWQpfWApIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBjb25zdCB1cGRhdGVkID0ge1xuICAgICAgLi4udGFyZ2V0LFxuICAgICAgaXNDb21iaW5lRW5hYmxlZFxuICAgIH07XG4gICAgcmV0dXJuIHBvc3REcm9wcGFibGVDaGFuZ2Uoc3RhdGUsIHVwZGF0ZWQsIHRydWUpO1xuICB9XG4gIGlmIChhY3Rpb24udHlwZSA9PT0gJ01PVkVfQllfV0lORE9XX1NDUk9MTCcpIHtcbiAgICBpZiAoc3RhdGUucGhhc2UgPT09ICdEUk9QX1BFTkRJTkcnIHx8IHN0YXRlLnBoYXNlID09PSAnRFJPUF9BTklNQVRJTkcnKSB7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgICFpc01vdmVtZW50QWxsb3dlZChzdGF0ZSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGBDYW5ub3QgbW92ZSBieSB3aW5kb3cgaW4gcGhhc2UgJHtzdGF0ZS5waGFzZX1gKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgIXN0YXRlLmlzV2luZG93U2Nyb2xsQWxsb3dlZCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ1dpbmRvdyBzY3JvbGxpbmcgaXMgY3VycmVudGx5IG5vdCBzdXBwb3J0ZWQgZm9yIGZpeGVkIGxpc3RzJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIGNvbnN0IG5ld1Njcm9sbCA9IGFjdGlvbi5wYXlsb2FkLm5ld1Njcm9sbDtcbiAgICBpZiAoaXNFcXVhbCQxKHN0YXRlLnZpZXdwb3J0LnNjcm9sbC5jdXJyZW50LCBuZXdTY3JvbGwpKSB7XG4gICAgICByZXR1cm4gcmVtb3ZlU2Nyb2xsSnVtcFJlcXVlc3Qoc3RhdGUpO1xuICAgIH1cbiAgICBjb25zdCB2aWV3cG9ydCA9IHNjcm9sbFZpZXdwb3J0KHN0YXRlLnZpZXdwb3J0LCBuZXdTY3JvbGwpO1xuICAgIGlmIChpc1NuYXBwaW5nKHN0YXRlKSkge1xuICAgICAgcmV0dXJuIHJlZnJlc2hTbmFwKHtcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIHZpZXdwb3J0XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHVwZGF0ZSh7XG4gICAgICBzdGF0ZSxcbiAgICAgIHZpZXdwb3J0XG4gICAgfSk7XG4gIH1cbiAgaWYgKGFjdGlvbi50eXBlID09PSAnVVBEQVRFX1ZJRVdQT1JUX01BWF9TQ1JPTEwnKSB7XG4gICAgaWYgKCFpc01vdmVtZW50QWxsb3dlZChzdGF0ZSkpIHtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG4gICAgY29uc3QgbWF4U2Nyb2xsID0gYWN0aW9uLnBheWxvYWQubWF4U2Nyb2xsO1xuICAgIGlmIChpc0VxdWFsJDEobWF4U2Nyb2xsLCBzdGF0ZS52aWV3cG9ydC5zY3JvbGwubWF4KSkge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICBjb25zdCB3aXRoTWF4U2Nyb2xsID0ge1xuICAgICAgLi4uc3RhdGUudmlld3BvcnQsXG4gICAgICBzY3JvbGw6IHtcbiAgICAgICAgLi4uc3RhdGUudmlld3BvcnQuc2Nyb2xsLFxuICAgICAgICBtYXg6IG1heFNjcm9sbFxuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgdmlld3BvcnQ6IHdpdGhNYXhTY3JvbGxcbiAgICB9O1xuICB9XG4gIGlmIChhY3Rpb24udHlwZSA9PT0gJ01PVkVfVVAnIHx8IGFjdGlvbi50eXBlID09PSAnTU9WRV9ET1dOJyB8fCBhY3Rpb24udHlwZSA9PT0gJ01PVkVfTEVGVCcgfHwgYWN0aW9uLnR5cGUgPT09ICdNT1ZFX1JJR0hUJykge1xuICAgIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0NPTExFQ1RJTkcnIHx8IHN0YXRlLnBoYXNlID09PSAnRFJPUF9QRU5ESU5HJykge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICAhKHN0YXRlLnBoYXNlID09PSAnRFJBR0dJTkcnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYCR7YWN0aW9uLnR5cGV9IHJlY2VpdmVkIHdoaWxlIG5vdCBpbiBEUkFHR0lORyBwaGFzZWApIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBjb25zdCByZXN1bHQgPSBtb3ZlSW5EaXJlY3Rpb24oe1xuICAgICAgc3RhdGUsXG4gICAgICB0eXBlOiBhY3Rpb24udHlwZVxuICAgIH0pO1xuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgIHJldHVybiB1cGRhdGUoe1xuICAgICAgc3RhdGUsXG4gICAgICBpbXBhY3Q6IHJlc3VsdC5pbXBhY3QsXG4gICAgICBjbGllbnRTZWxlY3Rpb246IHJlc3VsdC5jbGllbnRTZWxlY3Rpb24sXG4gICAgICBzY3JvbGxKdW1wUmVxdWVzdDogcmVzdWx0LnNjcm9sbEp1bXBSZXF1ZXN0XG4gICAgfSk7XG4gIH1cbiAgaWYgKGFjdGlvbi50eXBlID09PSAnRFJPUF9QRU5ESU5HJykge1xuICAgIGNvbnN0IHJlYXNvbiA9IGFjdGlvbi5wYXlsb2FkLnJlYXNvbjtcbiAgICAhKHN0YXRlLnBoYXNlID09PSAnQ09MTEVDVElORycpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2FuIG9ubHkgbW92ZSBpbnRvIHRoZSBEUk9QX1BFTkRJTkcgcGhhc2UgZnJvbSB0aGUgQ09MTEVDVElORyBwaGFzZScpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgcGhhc2U6ICdEUk9QX1BFTkRJTkcnLFxuICAgICAgaXNXYWl0aW5nOiB0cnVlLFxuICAgICAgcmVhc29uXG4gICAgfTtcbiAgICByZXR1cm4gbmV3U3RhdGU7XG4gIH1cbiAgaWYgKGFjdGlvbi50eXBlID09PSAnRFJPUF9BTklNQVRFJykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbXBsZXRlZCxcbiAgICAgIGRyb3BEdXJhdGlvbixcbiAgICAgIG5ld0hvbWVDbGllbnRPZmZzZXRcbiAgICB9ID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgIShzdGF0ZS5waGFzZSA9PT0gJ0RSQUdHSU5HJyB8fCBzdGF0ZS5waGFzZSA9PT0gJ0RST1BfUEVORElORycpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBgQ2Fubm90IGFuaW1hdGUgZHJvcCBmcm9tIHBoYXNlICR7c3RhdGUucGhhc2V9YCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgIHBoYXNlOiAnRFJPUF9BTklNQVRJTkcnLFxuICAgICAgY29tcGxldGVkLFxuICAgICAgZHJvcER1cmF0aW9uLFxuICAgICAgbmV3SG9tZUNsaWVudE9mZnNldCxcbiAgICAgIGRpbWVuc2lvbnM6IHN0YXRlLmRpbWVuc2lvbnNcbiAgICB9O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaWYgKGFjdGlvbi50eXBlID09PSAnRFJPUF9DT01QTEVURScpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21wbGV0ZWRcbiAgICB9ID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBoYXNlOiAnSURMRScsXG4gICAgICBjb21wbGV0ZWQsXG4gICAgICBzaG91bGRGbHVzaDogZmFsc2VcbiAgICB9O1xuICB9XG4gIHJldHVybiBzdGF0ZTtcbn0pO1xuXG5jb25zdCBiZWZvcmVJbml0aWFsQ2FwdHVyZSA9IGFyZ3MgPT4gKHtcbiAgdHlwZTogJ0JFRk9SRV9JTklUSUFMX0NBUFRVUkUnLFxuICBwYXlsb2FkOiBhcmdzXG59KTtcbmNvbnN0IGxpZnQkMSA9IGFyZ3MgPT4gKHtcbiAgdHlwZTogJ0xJRlQnLFxuICBwYXlsb2FkOiBhcmdzXG59KTtcbmNvbnN0IGluaXRpYWxQdWJsaXNoID0gYXJncyA9PiAoe1xuICB0eXBlOiAnSU5JVElBTF9QVUJMSVNIJyxcbiAgcGF5bG9hZDogYXJnc1xufSk7XG5jb25zdCBwdWJsaXNoV2hpbGVEcmFnZ2luZyA9IGFyZ3MgPT4gKHtcbiAgdHlwZTogJ1BVQkxJU0hfV0hJTEVfRFJBR0dJTkcnLFxuICBwYXlsb2FkOiBhcmdzXG59KTtcbmNvbnN0IGNvbGxlY3Rpb25TdGFydGluZyA9ICgpID0+ICh7XG4gIHR5cGU6ICdDT0xMRUNUSU9OX1NUQVJUSU5HJyxcbiAgcGF5bG9hZDogbnVsbFxufSk7XG5jb25zdCB1cGRhdGVEcm9wcGFibGVTY3JvbGwgPSBhcmdzID0+ICh7XG4gIHR5cGU6ICdVUERBVEVfRFJPUFBBQkxFX1NDUk9MTCcsXG4gIHBheWxvYWQ6IGFyZ3Ncbn0pO1xuY29uc3QgdXBkYXRlRHJvcHBhYmxlSXNFbmFibGVkID0gYXJncyA9PiAoe1xuICB0eXBlOiAnVVBEQVRFX0RST1BQQUJMRV9JU19FTkFCTEVEJyxcbiAgcGF5bG9hZDogYXJnc1xufSk7XG5jb25zdCB1cGRhdGVEcm9wcGFibGVJc0NvbWJpbmVFbmFibGVkID0gYXJncyA9PiAoe1xuICB0eXBlOiAnVVBEQVRFX0RST1BQQUJMRV9JU19DT01CSU5FX0VOQUJMRUQnLFxuICBwYXlsb2FkOiBhcmdzXG59KTtcbmNvbnN0IG1vdmUgPSBhcmdzID0+ICh7XG4gIHR5cGU6ICdNT1ZFJyxcbiAgcGF5bG9hZDogYXJnc1xufSk7XG5jb25zdCBtb3ZlQnlXaW5kb3dTY3JvbGwgPSBhcmdzID0+ICh7XG4gIHR5cGU6ICdNT1ZFX0JZX1dJTkRPV19TQ1JPTEwnLFxuICBwYXlsb2FkOiBhcmdzXG59KTtcbmNvbnN0IHVwZGF0ZVZpZXdwb3J0TWF4U2Nyb2xsID0gYXJncyA9PiAoe1xuICB0eXBlOiAnVVBEQVRFX1ZJRVdQT1JUX01BWF9TQ1JPTEwnLFxuICBwYXlsb2FkOiBhcmdzXG59KTtcbmNvbnN0IG1vdmVVcCA9ICgpID0+ICh7XG4gIHR5cGU6ICdNT1ZFX1VQJyxcbiAgcGF5bG9hZDogbnVsbFxufSk7XG5jb25zdCBtb3ZlRG93biA9ICgpID0+ICh7XG4gIHR5cGU6ICdNT1ZFX0RPV04nLFxuICBwYXlsb2FkOiBudWxsXG59KTtcbmNvbnN0IG1vdmVSaWdodCA9ICgpID0+ICh7XG4gIHR5cGU6ICdNT1ZFX1JJR0hUJyxcbiAgcGF5bG9hZDogbnVsbFxufSk7XG5jb25zdCBtb3ZlTGVmdCA9ICgpID0+ICh7XG4gIHR5cGU6ICdNT1ZFX0xFRlQnLFxuICBwYXlsb2FkOiBudWxsXG59KTtcbmNvbnN0IGZsdXNoID0gKCkgPT4gKHtcbiAgdHlwZTogJ0ZMVVNIJyxcbiAgcGF5bG9hZDogbnVsbFxufSk7XG5jb25zdCBhbmltYXRlRHJvcCA9IGFyZ3MgPT4gKHtcbiAgdHlwZTogJ0RST1BfQU5JTUFURScsXG4gIHBheWxvYWQ6IGFyZ3Ncbn0pO1xuY29uc3QgY29tcGxldGVEcm9wID0gYXJncyA9PiAoe1xuICB0eXBlOiAnRFJPUF9DT01QTEVURScsXG4gIHBheWxvYWQ6IGFyZ3Ncbn0pO1xuY29uc3QgZHJvcCQxID0gYXJncyA9PiAoe1xuICB0eXBlOiAnRFJPUCcsXG4gIHBheWxvYWQ6IGFyZ3Ncbn0pO1xuY29uc3QgZHJvcFBlbmRpbmcgPSBhcmdzID0+ICh7XG4gIHR5cGU6ICdEUk9QX1BFTkRJTkcnLFxuICBwYXlsb2FkOiBhcmdzXG59KTtcbmNvbnN0IGRyb3BBbmltYXRpb25GaW5pc2hlZCA9ICgpID0+ICh7XG4gIHR5cGU6ICdEUk9QX0FOSU1BVElPTl9GSU5JU0hFRCcsXG4gIHBheWxvYWQ6IG51bGxcbn0pO1xuXG5mdW5jdGlvbiBjaGVja0luZGV4ZXMoaW5zaWRlRGVzdGluYXRpb24pIHtcbiAgaWYgKGluc2lkZURlc3RpbmF0aW9uLmxlbmd0aCA8PSAxKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGluZGV4ZXMgPSBpbnNpZGVEZXN0aW5hdGlvbi5tYXAoZCA9PiBkLmRlc2NyaXB0b3IuaW5kZXgpO1xuICBjb25zdCBlcnJvcnMgPSB7fTtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBpbmRleGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY3VycmVudCA9IGluZGV4ZXNbaV07XG4gICAgY29uc3QgcHJldmlvdXMgPSBpbmRleGVzW2kgLSAxXTtcbiAgICBpZiAoY3VycmVudCAhPT0gcHJldmlvdXMgKyAxKSB7XG4gICAgICBlcnJvcnNbY3VycmVudF0gPSB0cnVlO1xuICAgIH1cbiAgfVxuICBpZiAoIU9iamVjdC5rZXlzKGVycm9ycykubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGZvcm1hdHRlZCA9IGluZGV4ZXMubWFwKGluZGV4ID0+IHtcbiAgICBjb25zdCBoYXNFcnJvciA9IEJvb2xlYW4oZXJyb3JzW2luZGV4XSk7XG4gICAgcmV0dXJuIGhhc0Vycm9yID8gYFvwn5SlJHtpbmRleH1dYCA6IGAke2luZGV4fWA7XG4gIH0pLmpvaW4oJywgJyk7XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoYFxuICAgIERldGVjdGVkIG5vbi1jb25zZWN1dGl2ZSA8RHJhZ2dhYmxlIC8+IGluZGV4ZXMuXG5cbiAgICAoVGhpcyBjYW4gY2F1c2UgdW5leHBlY3RlZCBidWdzKVxuXG4gICAgJHtmb3JtYXR0ZWR9XG4gIGApIDogdm9pZCAwO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVEaW1lbnNpb25zKGNyaXRpY2FsLCBkaW1lbnNpb25zKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY29uc3QgaW5zaWRlRGVzdGluYXRpb24gPSBnZXREcmFnZ2FibGVzSW5zaWRlRHJvcHBhYmxlKGNyaXRpY2FsLmRyb3BwYWJsZS5pZCwgZGltZW5zaW9ucy5kcmFnZ2FibGVzKTtcbiAgICBjaGVja0luZGV4ZXMoaW5zaWRlRGVzdGluYXRpb24pO1xuICB9XG59XG5cbnZhciBsaWZ0ID0gKG1hcnNoYWwgPT4gKHtcbiAgZ2V0U3RhdGUsXG4gIGRpc3BhdGNoXG59KSA9PiBuZXh0ID0+IGFjdGlvbiA9PiB7XG4gIGlmIChhY3Rpb24udHlwZSAhPT0gJ0xJRlQnKSB7XG4gICAgbmV4dChhY3Rpb24pO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB7XG4gICAgaWQsXG4gICAgY2xpZW50U2VsZWN0aW9uLFxuICAgIG1vdmVtZW50TW9kZVxuICB9ID0gYWN0aW9uLnBheWxvYWQ7XG4gIGNvbnN0IGluaXRpYWwgPSBnZXRTdGF0ZSgpO1xuICBpZiAoaW5pdGlhbC5waGFzZSA9PT0gJ0RST1BfQU5JTUFUSU5HJykge1xuICAgIGRpc3BhdGNoKGNvbXBsZXRlRHJvcCh7XG4gICAgICBjb21wbGV0ZWQ6IGluaXRpYWwuY29tcGxldGVkXG4gICAgfSkpO1xuICB9XG4gICEoZ2V0U3RhdGUoKS5waGFzZSA9PT0gJ0lETEUnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ1VuZXhwZWN0ZWQgcGhhc2UgdG8gc3RhcnQgYSBkcmFnJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICBkaXNwYXRjaChmbHVzaCgpKTtcbiAgZGlzcGF0Y2goYmVmb3JlSW5pdGlhbENhcHR1cmUoe1xuICAgIGRyYWdnYWJsZUlkOiBpZCxcbiAgICBtb3ZlbWVudE1vZGVcbiAgfSkpO1xuICBjb25zdCBzY3JvbGxPcHRpb25zID0ge1xuICAgIHNob3VsZFB1Ymxpc2hJbW1lZGlhdGVseTogbW92ZW1lbnRNb2RlID09PSAnU05BUCdcbiAgfTtcbiAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICBkcmFnZ2FibGVJZDogaWQsXG4gICAgc2Nyb2xsT3B0aW9uc1xuICB9O1xuICBjb25zdCB7XG4gICAgY3JpdGljYWwsXG4gICAgZGltZW5zaW9ucyxcbiAgICB2aWV3cG9ydFxuICB9ID0gbWFyc2hhbC5zdGFydFB1Ymxpc2hpbmcocmVxdWVzdCk7XG4gIHZhbGlkYXRlRGltZW5zaW9ucyhjcml0aWNhbCwgZGltZW5zaW9ucyk7XG4gIGRpc3BhdGNoKGluaXRpYWxQdWJsaXNoKHtcbiAgICBjcml0aWNhbCxcbiAgICBkaW1lbnNpb25zLFxuICAgIGNsaWVudFNlbGVjdGlvbixcbiAgICBtb3ZlbWVudE1vZGUsXG4gICAgdmlld3BvcnRcbiAgfSkpO1xufSk7XG5cbnZhciBzdHlsZSA9IChtYXJzaGFsID0+ICgpID0+IG5leHQgPT4gYWN0aW9uID0+IHtcbiAgaWYgKGFjdGlvbi50eXBlID09PSAnSU5JVElBTF9QVUJMSVNIJykge1xuICAgIG1hcnNoYWwuZHJhZ2dpbmcoKTtcbiAgfVxuICBpZiAoYWN0aW9uLnR5cGUgPT09ICdEUk9QX0FOSU1BVEUnKSB7XG4gICAgbWFyc2hhbC5kcm9wcGluZyhhY3Rpb24ucGF5bG9hZC5jb21wbGV0ZWQucmVzdWx0LnJlYXNvbik7XG4gIH1cbiAgaWYgKGFjdGlvbi50eXBlID09PSAnRkxVU0gnIHx8IGFjdGlvbi50eXBlID09PSAnRFJPUF9DT01QTEVURScpIHtcbiAgICBtYXJzaGFsLnJlc3RpbmcoKTtcbiAgfVxuICBuZXh0KGFjdGlvbik7XG59KTtcblxuY29uc3QgY3VydmVzID0ge1xuICBvdXRPZlRoZVdheTogJ2N1YmljLWJlemllcigwLjIsIDAsIDAsIDEpJyxcbiAgZHJvcDogJ2N1YmljLWJlemllciguMiwxLC4xLDEpJ1xufTtcbmNvbnN0IGNvbWJpbmUgPSB7XG4gIG9wYWNpdHk6IHtcbiAgICBkcm9wOiAwLFxuICAgIGNvbWJpbmluZzogMC43XG4gIH0sXG4gIHNjYWxlOiB7XG4gICAgZHJvcDogMC43NVxuICB9XG59O1xuY29uc3QgdGltaW5ncyA9IHtcbiAgb3V0T2ZUaGVXYXk6IDAuMixcbiAgbWluRHJvcFRpbWU6IDAuMzMsXG4gIG1heERyb3BUaW1lOiAwLjU1XG59O1xuY29uc3Qgb3V0T2ZUaGVXYXlUaW1pbmcgPSBgJHt0aW1pbmdzLm91dE9mVGhlV2F5fXMgJHtjdXJ2ZXMub3V0T2ZUaGVXYXl9YDtcbmNvbnN0IHRyYW5zaXRpb25zID0ge1xuICBmbHVpZDogYG9wYWNpdHkgJHtvdXRPZlRoZVdheVRpbWluZ31gLFxuICBzbmFwOiBgdHJhbnNmb3JtICR7b3V0T2ZUaGVXYXlUaW1pbmd9LCBvcGFjaXR5ICR7b3V0T2ZUaGVXYXlUaW1pbmd9YCxcbiAgZHJvcDogZHVyYXRpb24gPT4ge1xuICAgIGNvbnN0IHRpbWluZyA9IGAke2R1cmF0aW9ufXMgJHtjdXJ2ZXMuZHJvcH1gO1xuICAgIHJldHVybiBgdHJhbnNmb3JtICR7dGltaW5nfSwgb3BhY2l0eSAke3RpbWluZ31gO1xuICB9LFxuICBvdXRPZlRoZVdheTogYHRyYW5zZm9ybSAke291dE9mVGhlV2F5VGltaW5nfWAsXG4gIHBsYWNlaG9sZGVyOiBgaGVpZ2h0ICR7b3V0T2ZUaGVXYXlUaW1pbmd9LCB3aWR0aCAke291dE9mVGhlV2F5VGltaW5nfSwgbWFyZ2luICR7b3V0T2ZUaGVXYXlUaW1pbmd9YFxufTtcbmNvbnN0IG1vdmVUbyA9IG9mZnNldCA9PiBpc0VxdWFsJDEob2Zmc2V0LCBvcmlnaW4pID8gdW5kZWZpbmVkIDogYHRyYW5zbGF0ZSgke29mZnNldC54fXB4LCAke29mZnNldC55fXB4KWA7XG5jb25zdCB0cmFuc2Zvcm1zID0ge1xuICBtb3ZlVG8sXG4gIGRyb3A6IChvZmZzZXQsIGlzQ29tYmluaW5nKSA9PiB7XG4gICAgY29uc3QgdHJhbnNsYXRlID0gbW92ZVRvKG9mZnNldCk7XG4gICAgaWYgKCF0cmFuc2xhdGUpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmICghaXNDb21iaW5pbmcpIHtcbiAgICAgIHJldHVybiB0cmFuc2xhdGU7XG4gICAgfVxuICAgIHJldHVybiBgJHt0cmFuc2xhdGV9IHNjYWxlKCR7Y29tYmluZS5zY2FsZS5kcm9wfSlgO1xuICB9XG59O1xuXG5jb25zdCB7XG4gIG1pbkRyb3BUaW1lLFxuICBtYXhEcm9wVGltZVxufSA9IHRpbWluZ3M7XG5jb25zdCBkcm9wVGltZVJhbmdlID0gbWF4RHJvcFRpbWUgLSBtaW5Ecm9wVGltZTtcbmNvbnN0IG1heERyb3BUaW1lQXREaXN0YW5jZSA9IDE1MDA7XG5jb25zdCBjYW5jZWxEcm9wTW9kaWZpZXIgPSAwLjY7XG52YXIgZ2V0RHJvcER1cmF0aW9uID0gKCh7XG4gIGN1cnJlbnQsXG4gIGRlc3RpbmF0aW9uLFxuICByZWFzb25cbn0pID0+IHtcbiAgY29uc3QgZGlzdGFuY2UkMSA9IGRpc3RhbmNlKGN1cnJlbnQsIGRlc3RpbmF0aW9uKTtcbiAgaWYgKGRpc3RhbmNlJDEgPD0gMCkge1xuICAgIHJldHVybiBtaW5Ecm9wVGltZTtcbiAgfVxuICBpZiAoZGlzdGFuY2UkMSA+PSBtYXhEcm9wVGltZUF0RGlzdGFuY2UpIHtcbiAgICByZXR1cm4gbWF4RHJvcFRpbWU7XG4gIH1cbiAgY29uc3QgcGVyY2VudGFnZSA9IGRpc3RhbmNlJDEgLyBtYXhEcm9wVGltZUF0RGlzdGFuY2U7XG4gIGNvbnN0IGR1cmF0aW9uID0gbWluRHJvcFRpbWUgKyBkcm9wVGltZVJhbmdlICogcGVyY2VudGFnZTtcbiAgY29uc3Qgd2l0aER1cmF0aW9uID0gcmVhc29uID09PSAnQ0FOQ0VMJyA/IGR1cmF0aW9uICogY2FuY2VsRHJvcE1vZGlmaWVyIDogZHVyYXRpb247XG4gIHJldHVybiBOdW1iZXIod2l0aER1cmF0aW9uLnRvRml4ZWQoMikpO1xufSk7XG5cbnZhciBnZXROZXdIb21lQ2xpZW50T2Zmc2V0ID0gKCh7XG4gIGltcGFjdCxcbiAgZHJhZ2dhYmxlLFxuICBkaW1lbnNpb25zLFxuICB2aWV3cG9ydCxcbiAgYWZ0ZXJDcml0aWNhbFxufSkgPT4ge1xuICBjb25zdCB7XG4gICAgZHJhZ2dhYmxlcyxcbiAgICBkcm9wcGFibGVzXG4gIH0gPSBkaW1lbnNpb25zO1xuICBjb25zdCBkcm9wcGFibGVJZCA9IHdoYXRJc0RyYWdnZWRPdmVyKGltcGFjdCk7XG4gIGNvbnN0IGRlc3RpbmF0aW9uID0gZHJvcHBhYmxlSWQgPyBkcm9wcGFibGVzW2Ryb3BwYWJsZUlkXSA6IG51bGw7XG4gIGNvbnN0IGhvbWUgPSBkcm9wcGFibGVzW2RyYWdnYWJsZS5kZXNjcmlwdG9yLmRyb3BwYWJsZUlkXTtcbiAgY29uc3QgbmV3Q2xpZW50Q2VudGVyID0gZ2V0Q2xpZW50Qm9yZGVyQm94Q2VudGVyKHtcbiAgICBpbXBhY3QsXG4gICAgZHJhZ2dhYmxlLFxuICAgIGRyYWdnYWJsZXMsXG4gICAgYWZ0ZXJDcml0aWNhbCxcbiAgICBkcm9wcGFibGU6IGRlc3RpbmF0aW9uIHx8IGhvbWUsXG4gICAgdmlld3BvcnRcbiAgfSk7XG4gIGNvbnN0IG9mZnNldCA9IHN1YnRyYWN0KG5ld0NsaWVudENlbnRlciwgZHJhZ2dhYmxlLmNsaWVudC5ib3JkZXJCb3guY2VudGVyKTtcbiAgcmV0dXJuIG9mZnNldDtcbn0pO1xuXG52YXIgZ2V0RHJvcEltcGFjdCA9ICgoe1xuICBkcmFnZ2FibGVzLFxuICByZWFzb24sXG4gIGxhc3RJbXBhY3QsXG4gIGhvbWUsXG4gIHZpZXdwb3J0LFxuICBvbkxpZnRJbXBhY3Rcbn0pID0+IHtcbiAgaWYgKCFsYXN0SW1wYWN0LmF0IHx8IHJlYXNvbiAhPT0gJ0RST1AnKSB7XG4gICAgY29uc3QgcmVjb21wdXRlZEhvbWVJbXBhY3QgPSByZWNvbXB1dGUoe1xuICAgICAgZHJhZ2dhYmxlcyxcbiAgICAgIGltcGFjdDogb25MaWZ0SW1wYWN0LFxuICAgICAgZGVzdGluYXRpb246IGhvbWUsXG4gICAgICB2aWV3cG9ydCxcbiAgICAgIGZvcmNlU2hvdWxkQW5pbWF0ZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBpbXBhY3Q6IHJlY29tcHV0ZWRIb21lSW1wYWN0LFxuICAgICAgZGlkRHJvcEluc2lkZURyb3BwYWJsZTogZmFsc2VcbiAgICB9O1xuICB9XG4gIGlmIChsYXN0SW1wYWN0LmF0LnR5cGUgPT09ICdSRU9SREVSJykge1xuICAgIHJldHVybiB7XG4gICAgICBpbXBhY3Q6IGxhc3RJbXBhY3QsXG4gICAgICBkaWREcm9wSW5zaWRlRHJvcHBhYmxlOiB0cnVlXG4gICAgfTtcbiAgfVxuICBjb25zdCB3aXRob3V0TW92ZW1lbnQgPSB7XG4gICAgLi4ubGFzdEltcGFjdCxcbiAgICBkaXNwbGFjZWQ6IGVtcHR5R3JvdXBzXG4gIH07XG4gIHJldHVybiB7XG4gICAgaW1wYWN0OiB3aXRob3V0TW92ZW1lbnQsXG4gICAgZGlkRHJvcEluc2lkZURyb3BwYWJsZTogdHJ1ZVxuICB9O1xufSk7XG5cbmNvbnN0IGRyb3BNaWRkbGV3YXJlID0gKHtcbiAgZ2V0U3RhdGUsXG4gIGRpc3BhdGNoXG59KSA9PiBuZXh0ID0+IGFjdGlvbiA9PiB7XG4gIGlmIChhY3Rpb24udHlwZSAhPT0gJ0RST1AnKSB7XG4gICAgbmV4dChhY3Rpb24pO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBzdGF0ZSA9IGdldFN0YXRlKCk7XG4gIGNvbnN0IHJlYXNvbiA9IGFjdGlvbi5wYXlsb2FkLnJlYXNvbjtcbiAgaWYgKHN0YXRlLnBoYXNlID09PSAnQ09MTEVDVElORycpIHtcbiAgICBkaXNwYXRjaChkcm9wUGVuZGluZyh7XG4gICAgICByZWFzb25cbiAgICB9KSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0lETEUnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGlzV2FpdGluZ0ZvckRyb3AgPSBzdGF0ZS5waGFzZSA9PT0gJ0RST1BfUEVORElORycgJiYgc3RhdGUuaXNXYWl0aW5nO1xuICAhIWlzV2FpdGluZ0ZvckRyb3AgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdBIERST1AgYWN0aW9uIG9jY3VycmVkIHdoaWxlIERST1BfUEVORElORyBhbmQgc3RpbGwgd2FpdGluZycpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgIShzdGF0ZS5waGFzZSA9PT0gJ0RSQUdHSU5HJyB8fCBzdGF0ZS5waGFzZSA9PT0gJ0RST1BfUEVORElORycpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBgQ2Fubm90IGRyb3AgaW4gcGhhc2U6ICR7c3RhdGUucGhhc2V9YCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICBjb25zdCBjcml0aWNhbCA9IHN0YXRlLmNyaXRpY2FsO1xuICBjb25zdCBkaW1lbnNpb25zID0gc3RhdGUuZGltZW5zaW9ucztcbiAgY29uc3QgZHJhZ2dhYmxlID0gZGltZW5zaW9ucy5kcmFnZ2FibGVzW3N0YXRlLmNyaXRpY2FsLmRyYWdnYWJsZS5pZF07XG4gIGNvbnN0IHtcbiAgICBpbXBhY3QsXG4gICAgZGlkRHJvcEluc2lkZURyb3BwYWJsZVxuICB9ID0gZ2V0RHJvcEltcGFjdCh7XG4gICAgcmVhc29uLFxuICAgIGxhc3RJbXBhY3Q6IHN0YXRlLmltcGFjdCxcbiAgICBhZnRlckNyaXRpY2FsOiBzdGF0ZS5hZnRlckNyaXRpY2FsLFxuICAgIG9uTGlmdEltcGFjdDogc3RhdGUub25MaWZ0SW1wYWN0LFxuICAgIGhvbWU6IHN0YXRlLmRpbWVuc2lvbnMuZHJvcHBhYmxlc1tzdGF0ZS5jcml0aWNhbC5kcm9wcGFibGUuaWRdLFxuICAgIHZpZXdwb3J0OiBzdGF0ZS52aWV3cG9ydCxcbiAgICBkcmFnZ2FibGVzOiBzdGF0ZS5kaW1lbnNpb25zLmRyYWdnYWJsZXNcbiAgfSk7XG4gIGNvbnN0IGRlc3RpbmF0aW9uID0gZGlkRHJvcEluc2lkZURyb3BwYWJsZSA/IHRyeUdldERlc3RpbmF0aW9uKGltcGFjdCkgOiBudWxsO1xuICBjb25zdCBjb21iaW5lID0gZGlkRHJvcEluc2lkZURyb3BwYWJsZSA/IHRyeUdldENvbWJpbmUoaW1wYWN0KSA6IG51bGw7XG4gIGNvbnN0IHNvdXJjZSA9IHtcbiAgICBpbmRleDogY3JpdGljYWwuZHJhZ2dhYmxlLmluZGV4LFxuICAgIGRyb3BwYWJsZUlkOiBjcml0aWNhbC5kcm9wcGFibGUuaWRcbiAgfTtcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIGRyYWdnYWJsZUlkOiBkcmFnZ2FibGUuZGVzY3JpcHRvci5pZCxcbiAgICB0eXBlOiBkcmFnZ2FibGUuZGVzY3JpcHRvci50eXBlLFxuICAgIHNvdXJjZSxcbiAgICByZWFzb24sXG4gICAgbW9kZTogc3RhdGUubW92ZW1lbnRNb2RlLFxuICAgIGRlc3RpbmF0aW9uLFxuICAgIGNvbWJpbmVcbiAgfTtcbiAgY29uc3QgbmV3SG9tZUNsaWVudE9mZnNldCA9IGdldE5ld0hvbWVDbGllbnRPZmZzZXQoe1xuICAgIGltcGFjdCxcbiAgICBkcmFnZ2FibGUsXG4gICAgZGltZW5zaW9ucyxcbiAgICB2aWV3cG9ydDogc3RhdGUudmlld3BvcnQsXG4gICAgYWZ0ZXJDcml0aWNhbDogc3RhdGUuYWZ0ZXJDcml0aWNhbFxuICB9KTtcbiAgY29uc3QgY29tcGxldGVkID0ge1xuICAgIGNyaXRpY2FsOiBzdGF0ZS5jcml0aWNhbCxcbiAgICBhZnRlckNyaXRpY2FsOiBzdGF0ZS5hZnRlckNyaXRpY2FsLFxuICAgIHJlc3VsdCxcbiAgICBpbXBhY3RcbiAgfTtcbiAgY29uc3QgaXNBbmltYXRpb25SZXF1aXJlZCA9ICFpc0VxdWFsJDEoc3RhdGUuY3VycmVudC5jbGllbnQub2Zmc2V0LCBuZXdIb21lQ2xpZW50T2Zmc2V0KSB8fCBCb29sZWFuKHJlc3VsdC5jb21iaW5lKTtcbiAgaWYgKCFpc0FuaW1hdGlvblJlcXVpcmVkKSB7XG4gICAgZGlzcGF0Y2goY29tcGxldGVEcm9wKHtcbiAgICAgIGNvbXBsZXRlZFxuICAgIH0pKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgZHJvcER1cmF0aW9uID0gZ2V0RHJvcER1cmF0aW9uKHtcbiAgICBjdXJyZW50OiBzdGF0ZS5jdXJyZW50LmNsaWVudC5vZmZzZXQsXG4gICAgZGVzdGluYXRpb246IG5ld0hvbWVDbGllbnRPZmZzZXQsXG4gICAgcmVhc29uXG4gIH0pO1xuICBjb25zdCBhcmdzID0ge1xuICAgIG5ld0hvbWVDbGllbnRPZmZzZXQsXG4gICAgZHJvcER1cmF0aW9uLFxuICAgIGNvbXBsZXRlZFxuICB9O1xuICBkaXNwYXRjaChhbmltYXRlRHJvcChhcmdzKSk7XG59O1xudmFyIGRyb3AgPSBkcm9wTWlkZGxld2FyZTtcblxudmFyIGdldFdpbmRvd1Njcm9sbCA9ICgoKSA9PiAoe1xuICB4OiB3aW5kb3cucGFnZVhPZmZzZXQsXG4gIHk6IHdpbmRvdy5wYWdlWU9mZnNldFxufSkpO1xuXG5mdW5jdGlvbiBnZXRXaW5kb3dTY3JvbGxCaW5kaW5nKHVwZGF0ZSkge1xuICByZXR1cm4ge1xuICAgIGV2ZW50TmFtZTogJ3Njcm9sbCcsXG4gICAgb3B0aW9uczoge1xuICAgICAgcGFzc2l2ZTogdHJ1ZSxcbiAgICAgIGNhcHR1cmU6IGZhbHNlXG4gICAgfSxcbiAgICBmbjogZXZlbnQgPT4ge1xuICAgICAgaWYgKGV2ZW50LnRhcmdldCAhPT0gd2luZG93ICYmIGV2ZW50LnRhcmdldCAhPT0gd2luZG93LmRvY3VtZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHVwZGF0ZSgpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFNjcm9sbExpc3RlbmVyKHtcbiAgb25XaW5kb3dTY3JvbGxcbn0pIHtcbiAgZnVuY3Rpb24gdXBkYXRlU2Nyb2xsKCkge1xuICAgIG9uV2luZG93U2Nyb2xsKGdldFdpbmRvd1Njcm9sbCgpKTtcbiAgfVxuICBjb25zdCBzY2hlZHVsZWQgPSByYWZTY2hkKHVwZGF0ZVNjcm9sbCk7XG4gIGNvbnN0IGJpbmRpbmcgPSBnZXRXaW5kb3dTY3JvbGxCaW5kaW5nKHNjaGVkdWxlZCk7XG4gIGxldCB1bmJpbmQgPSBub29wJDI7XG4gIGZ1bmN0aW9uIGlzQWN0aXZlKCkge1xuICAgIHJldHVybiB1bmJpbmQgIT09IG5vb3AkMjtcbiAgfVxuICBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAhIWlzQWN0aXZlKCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3Qgc3RhcnQgc2Nyb2xsIGxpc3RlbmVyIHdoZW4gYWxyZWFkeSBhY3RpdmUnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgdW5iaW5kID0gYmluZEV2ZW50cyh3aW5kb3csIFtiaW5kaW5nXSk7XG4gIH1cbiAgZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAhaXNBY3RpdmUoKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBzdG9wIHNjcm9sbCBsaXN0ZW5lciB3aGVuIG5vdCBhY3RpdmUnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgc2NoZWR1bGVkLmNhbmNlbCgpO1xuICAgIHVuYmluZCgpO1xuICAgIHVuYmluZCA9IG5vb3AkMjtcbiAgfVxuICByZXR1cm4ge1xuICAgIHN0YXJ0LFxuICAgIHN0b3AsXG4gICAgaXNBY3RpdmVcbiAgfTtcbn1cblxuY29uc3Qgc2hvdWxkRW5kID0gYWN0aW9uID0+IGFjdGlvbi50eXBlID09PSAnRFJPUF9DT01QTEVURScgfHwgYWN0aW9uLnR5cGUgPT09ICdEUk9QX0FOSU1BVEUnIHx8IGFjdGlvbi50eXBlID09PSAnRkxVU0gnO1xuY29uc3Qgc2Nyb2xsTGlzdGVuZXIgPSBzdG9yZSA9PiB7XG4gIGNvbnN0IGxpc3RlbmVyID0gZ2V0U2Nyb2xsTGlzdGVuZXIoe1xuICAgIG9uV2luZG93U2Nyb2xsOiBuZXdTY3JvbGwgPT4ge1xuICAgICAgc3RvcmUuZGlzcGF0Y2gobW92ZUJ5V2luZG93U2Nyb2xsKHtcbiAgICAgICAgbmV3U2Nyb2xsXG4gICAgICB9KSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG5leHQgPT4gYWN0aW9uID0+IHtcbiAgICBpZiAoIWxpc3RlbmVyLmlzQWN0aXZlKCkgJiYgYWN0aW9uLnR5cGUgPT09ICdJTklUSUFMX1BVQkxJU0gnKSB7XG4gICAgICBsaXN0ZW5lci5zdGFydCgpO1xuICAgIH1cbiAgICBpZiAobGlzdGVuZXIuaXNBY3RpdmUoKSAmJiBzaG91bGRFbmQoYWN0aW9uKSkge1xuICAgICAgbGlzdGVuZXIuc3RvcCgpO1xuICAgIH1cbiAgICBuZXh0KGFjdGlvbik7XG4gIH07XG59O1xudmFyIHNjcm9sbExpc3RlbmVyJDEgPSBzY3JvbGxMaXN0ZW5lcjtcblxudmFyIGdldEV4cGlyaW5nQW5ub3VuY2UgPSAoYW5ub3VuY2UgPT4ge1xuICBsZXQgd2FzQ2FsbGVkID0gZmFsc2U7XG4gIGxldCBpc0V4cGlyZWQgPSBmYWxzZTtcbiAgY29uc3QgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgaXNFeHBpcmVkID0gdHJ1ZTtcbiAgfSk7XG4gIGNvbnN0IHJlc3VsdCA9IG1lc3NhZ2UgPT4ge1xuICAgIGlmICh3YXNDYWxsZWQpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoJ0Fubm91bmNlbWVudCBhbHJlYWR5IG1hZGUuIE5vdCBtYWtpbmcgYSBzZWNvbmQgYW5ub3VuY2VtZW50JykgOiB2b2lkIDA7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpc0V4cGlyZWQpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoYFxuICAgICAgICBBbm5vdW5jZW1lbnRzIGNhbm5vdCBiZSBtYWRlIGFzeW5jaHJvbm91c2x5LlxuICAgICAgICBEZWZhdWx0IG1lc3NhZ2UgaGFzIGFscmVhZHkgYmVlbiBhbm5vdW5jZWQuXG4gICAgICBgKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgd2FzQ2FsbGVkID0gdHJ1ZTtcbiAgICBhbm5vdW5jZShtZXNzYWdlKTtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgfTtcbiAgcmVzdWx0Lndhc0NhbGxlZCA9ICgpID0+IHdhc0NhbGxlZDtcbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuXG52YXIgZ2V0QXN5bmNNYXJzaGFsID0gKCgpID0+IHtcbiAgY29uc3QgZW50cmllcyA9IFtdO1xuICBjb25zdCBleGVjdXRlID0gdGltZXJJZCA9PiB7XG4gICAgY29uc3QgaW5kZXggPSBlbnRyaWVzLmZpbmRJbmRleChpdGVtID0+IGl0ZW0udGltZXJJZCA9PT0gdGltZXJJZCk7XG4gICAgIShpbmRleCAhPT0gLTEpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ291bGQgbm90IGZpbmQgdGltZXInKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgY29uc3QgW2VudHJ5XSA9IGVudHJpZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICBlbnRyeS5jYWxsYmFjaygpO1xuICB9O1xuICBjb25zdCBhZGQgPSBmbiA9PiB7XG4gICAgY29uc3QgdGltZXJJZCA9IHNldFRpbWVvdXQoKCkgPT4gZXhlY3V0ZSh0aW1lcklkKSk7XG4gICAgY29uc3QgZW50cnkgPSB7XG4gICAgICB0aW1lcklkLFxuICAgICAgY2FsbGJhY2s6IGZuXG4gICAgfTtcbiAgICBlbnRyaWVzLnB1c2goZW50cnkpO1xuICB9O1xuICBjb25zdCBmbHVzaCA9ICgpID0+IHtcbiAgICBpZiAoIWVudHJpZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNoYWxsb3cgPSBbLi4uZW50cmllc107XG4gICAgZW50cmllcy5sZW5ndGggPSAwO1xuICAgIHNoYWxsb3cuZm9yRWFjaChlbnRyeSA9PiB7XG4gICAgICBjbGVhclRpbWVvdXQoZW50cnkudGltZXJJZCk7XG4gICAgICBlbnRyeS5jYWxsYmFjaygpO1xuICAgIH0pO1xuICB9O1xuICByZXR1cm4ge1xuICAgIGFkZCxcbiAgICBmbHVzaFxuICB9O1xufSk7XG5cbmNvbnN0IGFyZUxvY2F0aW9uc0VxdWFsID0gKGZpcnN0LCBzZWNvbmQpID0+IHtcbiAgaWYgKGZpcnN0ID09IG51bGwgJiYgc2Vjb25kID09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoZmlyc3QgPT0gbnVsbCB8fCBzZWNvbmQgPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gZmlyc3QuZHJvcHBhYmxlSWQgPT09IHNlY29uZC5kcm9wcGFibGVJZCAmJiBmaXJzdC5pbmRleCA9PT0gc2Vjb25kLmluZGV4O1xufTtcbmNvbnN0IGlzQ29tYmluZUVxdWFsID0gKGZpcnN0LCBzZWNvbmQpID0+IHtcbiAgaWYgKGZpcnN0ID09IG51bGwgJiYgc2Vjb25kID09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoZmlyc3QgPT0gbnVsbCB8fCBzZWNvbmQgPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gZmlyc3QuZHJhZ2dhYmxlSWQgPT09IHNlY29uZC5kcmFnZ2FibGVJZCAmJiBmaXJzdC5kcm9wcGFibGVJZCA9PT0gc2Vjb25kLmRyb3BwYWJsZUlkO1xufTtcbmNvbnN0IGlzQ3JpdGljYWxFcXVhbCA9IChmaXJzdCwgc2Vjb25kKSA9PiB7XG4gIGlmIChmaXJzdCA9PT0gc2Vjb25kKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgaXNEcmFnZ2FibGVFcXVhbCA9IGZpcnN0LmRyYWdnYWJsZS5pZCA9PT0gc2Vjb25kLmRyYWdnYWJsZS5pZCAmJiBmaXJzdC5kcmFnZ2FibGUuZHJvcHBhYmxlSWQgPT09IHNlY29uZC5kcmFnZ2FibGUuZHJvcHBhYmxlSWQgJiYgZmlyc3QuZHJhZ2dhYmxlLnR5cGUgPT09IHNlY29uZC5kcmFnZ2FibGUudHlwZSAmJiBmaXJzdC5kcmFnZ2FibGUuaW5kZXggPT09IHNlY29uZC5kcmFnZ2FibGUuaW5kZXg7XG4gIGNvbnN0IGlzRHJvcHBhYmxlRXF1YWwgPSBmaXJzdC5kcm9wcGFibGUuaWQgPT09IHNlY29uZC5kcm9wcGFibGUuaWQgJiYgZmlyc3QuZHJvcHBhYmxlLnR5cGUgPT09IHNlY29uZC5kcm9wcGFibGUudHlwZTtcbiAgcmV0dXJuIGlzRHJhZ2dhYmxlRXF1YWwgJiYgaXNEcm9wcGFibGVFcXVhbDtcbn07XG5cbmNvbnN0IHdpdGhUaW1pbmdzID0gKGtleSwgZm4pID0+IHtcbiAgc3RhcnQoKTtcbiAgZm4oKTtcbiAgZmluaXNoKCk7XG59O1xuY29uc3QgZ2V0RHJhZ1N0YXJ0ID0gKGNyaXRpY2FsLCBtb2RlKSA9PiAoe1xuICBkcmFnZ2FibGVJZDogY3JpdGljYWwuZHJhZ2dhYmxlLmlkLFxuICB0eXBlOiBjcml0aWNhbC5kcm9wcGFibGUudHlwZSxcbiAgc291cmNlOiB7XG4gICAgZHJvcHBhYmxlSWQ6IGNyaXRpY2FsLmRyb3BwYWJsZS5pZCxcbiAgICBpbmRleDogY3JpdGljYWwuZHJhZ2dhYmxlLmluZGV4XG4gIH0sXG4gIG1vZGVcbn0pO1xuZnVuY3Rpb24gZXhlY3V0ZShyZXNwb25kZXIsIGRhdGEsIGFubm91bmNlLCBnZXREZWZhdWx0TWVzc2FnZSkge1xuICBpZiAoIXJlc3BvbmRlcikge1xuICAgIGFubm91bmNlKGdldERlZmF1bHRNZXNzYWdlKGRhdGEpKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgd2lsbEV4cGlyZSA9IGdldEV4cGlyaW5nQW5ub3VuY2UoYW5ub3VuY2UpO1xuICBjb25zdCBwcm92aWRlZCA9IHtcbiAgICBhbm5vdW5jZTogd2lsbEV4cGlyZVxuICB9O1xuICByZXNwb25kZXIoZGF0YSwgcHJvdmlkZWQpO1xuICBpZiAoIXdpbGxFeHBpcmUud2FzQ2FsbGVkKCkpIHtcbiAgICBhbm5vdW5jZShnZXREZWZhdWx0TWVzc2FnZShkYXRhKSk7XG4gIH1cbn1cbnZhciBnZXRQdWJsaXNoZXIgPSAoKGdldFJlc3BvbmRlcnMsIGFubm91bmNlKSA9PiB7XG4gIGNvbnN0IGFzeW5jTWFyc2hhbCA9IGdldEFzeW5jTWFyc2hhbCgpO1xuICBsZXQgZHJhZ2dpbmcgPSBudWxsO1xuICBjb25zdCBiZWZvcmVDYXB0dXJlID0gKGRyYWdnYWJsZUlkLCBtb2RlKSA9PiB7XG4gICAgISFkcmFnZ2luZyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBmaXJlIG9uQmVmb3JlQ2FwdHVyZSBhcyBhIGRyYWcgc3RhcnQgaGFzIGFscmVhZHkgYmVlbiBwdWJsaXNoZWQnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgd2l0aFRpbWluZ3MoJ29uQmVmb3JlQ2FwdHVyZScsICgpID0+IHtcbiAgICAgIGNvbnN0IGZuID0gZ2V0UmVzcG9uZGVycygpLm9uQmVmb3JlQ2FwdHVyZTtcbiAgICAgIGlmIChmbikge1xuICAgICAgICBjb25zdCBiZWZvcmUgPSB7XG4gICAgICAgICAgZHJhZ2dhYmxlSWQsXG4gICAgICAgICAgbW9kZVxuICAgICAgICB9O1xuICAgICAgICBmbihiZWZvcmUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICBjb25zdCBiZWZvcmVTdGFydCA9IChjcml0aWNhbCwgbW9kZSkgPT4ge1xuICAgICEhZHJhZ2dpbmcgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgZmlyZSBvbkJlZm9yZURyYWdTdGFydCBhcyBhIGRyYWcgc3RhcnQgaGFzIGFscmVhZHkgYmVlbiBwdWJsaXNoZWQnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgd2l0aFRpbWluZ3MoJ29uQmVmb3JlRHJhZ1N0YXJ0JywgKCkgPT4ge1xuICAgICAgY29uc3QgZm4gPSBnZXRSZXNwb25kZXJzKCkub25CZWZvcmVEcmFnU3RhcnQ7XG4gICAgICBpZiAoZm4pIHtcbiAgICAgICAgZm4oZ2V0RHJhZ1N0YXJ0KGNyaXRpY2FsLCBtb2RlKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IHN0YXJ0ID0gKGNyaXRpY2FsLCBtb2RlKSA9PiB7XG4gICAgISFkcmFnZ2luZyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBmaXJlIG9uQmVmb3JlRHJhZ1N0YXJ0IGFzIGEgZHJhZyBzdGFydCBoYXMgYWxyZWFkeSBiZWVuIHB1Ymxpc2hlZCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBjb25zdCBkYXRhID0gZ2V0RHJhZ1N0YXJ0KGNyaXRpY2FsLCBtb2RlKTtcbiAgICBkcmFnZ2luZyA9IHtcbiAgICAgIG1vZGUsXG4gICAgICBsYXN0Q3JpdGljYWw6IGNyaXRpY2FsLFxuICAgICAgbGFzdExvY2F0aW9uOiBkYXRhLnNvdXJjZSxcbiAgICAgIGxhc3RDb21iaW5lOiBudWxsXG4gICAgfTtcbiAgICBhc3luY01hcnNoYWwuYWRkKCgpID0+IHtcbiAgICAgIHdpdGhUaW1pbmdzKCdvbkRyYWdTdGFydCcsICgpID0+IGV4ZWN1dGUoZ2V0UmVzcG9uZGVycygpLm9uRHJhZ1N0YXJ0LCBkYXRhLCBhbm5vdW5jZSwgcHJlc2V0JDEub25EcmFnU3RhcnQpKTtcbiAgICB9KTtcbiAgfTtcbiAgY29uc3QgdXBkYXRlID0gKGNyaXRpY2FsLCBpbXBhY3QpID0+IHtcbiAgICBjb25zdCBsb2NhdGlvbiA9IHRyeUdldERlc3RpbmF0aW9uKGltcGFjdCk7XG4gICAgY29uc3QgY29tYmluZSA9IHRyeUdldENvbWJpbmUoaW1wYWN0KTtcbiAgICAhZHJhZ2dpbmcgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgZmlyZSBvbkRyYWdNb3ZlIHdoZW4gb25EcmFnU3RhcnQgaGFzIG5vdCBiZWVuIGNhbGxlZCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBjb25zdCBoYXNDcml0aWNhbENoYW5nZWQgPSAhaXNDcml0aWNhbEVxdWFsKGNyaXRpY2FsLCBkcmFnZ2luZy5sYXN0Q3JpdGljYWwpO1xuICAgIGlmIChoYXNDcml0aWNhbENoYW5nZWQpIHtcbiAgICAgIGRyYWdnaW5nLmxhc3RDcml0aWNhbCA9IGNyaXRpY2FsO1xuICAgIH1cbiAgICBjb25zdCBoYXNMb2NhdGlvbkNoYW5nZWQgPSAhYXJlTG9jYXRpb25zRXF1YWwoZHJhZ2dpbmcubGFzdExvY2F0aW9uLCBsb2NhdGlvbik7XG4gICAgaWYgKGhhc0xvY2F0aW9uQ2hhbmdlZCkge1xuICAgICAgZHJhZ2dpbmcubGFzdExvY2F0aW9uID0gbG9jYXRpb247XG4gICAgfVxuICAgIGNvbnN0IGhhc0dyb3VwaW5nQ2hhbmdlZCA9ICFpc0NvbWJpbmVFcXVhbChkcmFnZ2luZy5sYXN0Q29tYmluZSwgY29tYmluZSk7XG4gICAgaWYgKGhhc0dyb3VwaW5nQ2hhbmdlZCkge1xuICAgICAgZHJhZ2dpbmcubGFzdENvbWJpbmUgPSBjb21iaW5lO1xuICAgIH1cbiAgICBpZiAoIWhhc0NyaXRpY2FsQ2hhbmdlZCAmJiAhaGFzTG9jYXRpb25DaGFuZ2VkICYmICFoYXNHcm91cGluZ0NoYW5nZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IHtcbiAgICAgIC4uLmdldERyYWdTdGFydChjcml0aWNhbCwgZHJhZ2dpbmcubW9kZSksXG4gICAgICBjb21iaW5lLFxuICAgICAgZGVzdGluYXRpb246IGxvY2F0aW9uXG4gICAgfTtcbiAgICBhc3luY01hcnNoYWwuYWRkKCgpID0+IHtcbiAgICAgIHdpdGhUaW1pbmdzKCdvbkRyYWdVcGRhdGUnLCAoKSA9PiBleGVjdXRlKGdldFJlc3BvbmRlcnMoKS5vbkRyYWdVcGRhdGUsIGRhdGEsIGFubm91bmNlLCBwcmVzZXQkMS5vbkRyYWdVcGRhdGUpKTtcbiAgICB9KTtcbiAgfTtcbiAgY29uc3QgZmx1c2ggPSAoKSA9PiB7XG4gICAgIWRyYWdnaW5nID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2FuIG9ubHkgZmx1c2ggcmVzcG9uZGVycyB3aGlsZSBkcmFnZ2luZycpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBhc3luY01hcnNoYWwuZmx1c2goKTtcbiAgfTtcbiAgY29uc3QgZHJvcCA9IHJlc3VsdCA9PiB7XG4gICAgIWRyYWdnaW5nID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IGZpcmUgb25EcmFnRW5kIHdoZW4gdGhlcmUgaXMgbm8gbWF0Y2hpbmcgb25EcmFnU3RhcnQnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgZHJhZ2dpbmcgPSBudWxsO1xuICAgIHdpdGhUaW1pbmdzKCdvbkRyYWdFbmQnLCAoKSA9PiBleGVjdXRlKGdldFJlc3BvbmRlcnMoKS5vbkRyYWdFbmQsIHJlc3VsdCwgYW5ub3VuY2UsIHByZXNldCQxLm9uRHJhZ0VuZCkpO1xuICB9O1xuICBjb25zdCBhYm9ydCA9ICgpID0+IHtcbiAgICBpZiAoIWRyYWdnaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgIC4uLmdldERyYWdTdGFydChkcmFnZ2luZy5sYXN0Q3JpdGljYWwsIGRyYWdnaW5nLm1vZGUpLFxuICAgICAgY29tYmluZTogbnVsbCxcbiAgICAgIGRlc3RpbmF0aW9uOiBudWxsLFxuICAgICAgcmVhc29uOiAnQ0FOQ0VMJ1xuICAgIH07XG4gICAgZHJvcChyZXN1bHQpO1xuICB9O1xuICByZXR1cm4ge1xuICAgIGJlZm9yZUNhcHR1cmUsXG4gICAgYmVmb3JlU3RhcnQsXG4gICAgc3RhcnQsXG4gICAgdXBkYXRlLFxuICAgIGZsdXNoLFxuICAgIGRyb3AsXG4gICAgYWJvcnRcbiAgfTtcbn0pO1xuXG52YXIgcmVzcG9uZGVycyA9ICgoZ2V0UmVzcG9uZGVycywgYW5ub3VuY2UpID0+IHtcbiAgY29uc3QgcHVibGlzaGVyID0gZ2V0UHVibGlzaGVyKGdldFJlc3BvbmRlcnMsIGFubm91bmNlKTtcbiAgcmV0dXJuIHN0b3JlID0+IG5leHQgPT4gYWN0aW9uID0+IHtcbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09ICdCRUZPUkVfSU5JVElBTF9DQVBUVVJFJykge1xuICAgICAgcHVibGlzaGVyLmJlZm9yZUNhcHR1cmUoYWN0aW9uLnBheWxvYWQuZHJhZ2dhYmxlSWQsIGFjdGlvbi5wYXlsb2FkLm1vdmVtZW50TW9kZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gJ0lOSVRJQUxfUFVCTElTSCcpIHtcbiAgICAgIGNvbnN0IGNyaXRpY2FsID0gYWN0aW9uLnBheWxvYWQuY3JpdGljYWw7XG4gICAgICBwdWJsaXNoZXIuYmVmb3JlU3RhcnQoY3JpdGljYWwsIGFjdGlvbi5wYXlsb2FkLm1vdmVtZW50TW9kZSk7XG4gICAgICBuZXh0KGFjdGlvbik7XG4gICAgICBwdWJsaXNoZXIuc3RhcnQoY3JpdGljYWwsIGFjdGlvbi5wYXlsb2FkLm1vdmVtZW50TW9kZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gJ0RST1BfQ09NUExFVEUnKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhY3Rpb24ucGF5bG9hZC5jb21wbGV0ZWQucmVzdWx0O1xuICAgICAgcHVibGlzaGVyLmZsdXNoKCk7XG4gICAgICBuZXh0KGFjdGlvbik7XG4gICAgICBwdWJsaXNoZXIuZHJvcChyZXN1bHQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBuZXh0KGFjdGlvbik7XG4gICAgaWYgKGFjdGlvbi50eXBlID09PSAnRkxVU0gnKSB7XG4gICAgICBwdWJsaXNoZXIuYWJvcnQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0RSQUdHSU5HJykge1xuICAgICAgcHVibGlzaGVyLnVwZGF0ZShzdGF0ZS5jcml0aWNhbCwgc3RhdGUuaW1wYWN0KTtcbiAgICB9XG4gIH07XG59KTtcblxuY29uc3QgZHJvcEFuaW1hdGlvbkZpbmlzaE1pZGRsZXdhcmUgPSBzdG9yZSA9PiBuZXh0ID0+IGFjdGlvbiA9PiB7XG4gIGlmIChhY3Rpb24udHlwZSAhPT0gJ0RST1BfQU5JTUFUSU9OX0ZJTklTSEVEJykge1xuICAgIG5leHQoYWN0aW9uKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgc3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAhKHN0YXRlLnBoYXNlID09PSAnRFJPUF9BTklNQVRJTkcnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBmaW5pc2ggYSBkcm9wIGFuaW1hdGluZyB3aGVuIG5vIGRyb3AgaXMgb2NjdXJyaW5nJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICBzdG9yZS5kaXNwYXRjaChjb21wbGV0ZURyb3Aoe1xuICAgIGNvbXBsZXRlZDogc3RhdGUuY29tcGxldGVkXG4gIH0pKTtcbn07XG52YXIgZHJvcEFuaW1hdGlvbkZpbmlzaCA9IGRyb3BBbmltYXRpb25GaW5pc2hNaWRkbGV3YXJlO1xuXG5jb25zdCBkcm9wQW5pbWF0aW9uRmx1c2hPblNjcm9sbE1pZGRsZXdhcmUgPSBzdG9yZSA9PiB7XG4gIGxldCB1bmJpbmQgPSBudWxsO1xuICBsZXQgZnJhbWVJZCA9IG51bGw7XG4gIGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIGlmIChmcmFtZUlkKSB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShmcmFtZUlkKTtcbiAgICAgIGZyYW1lSWQgPSBudWxsO1xuICAgIH1cbiAgICBpZiAodW5iaW5kKSB7XG4gICAgICB1bmJpbmQoKTtcbiAgICAgIHVuYmluZCA9IG51bGw7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXh0ID0+IGFjdGlvbiA9PiB7XG4gICAgaWYgKGFjdGlvbi50eXBlID09PSAnRkxVU0gnIHx8IGFjdGlvbi50eXBlID09PSAnRFJPUF9DT01QTEVURScgfHwgYWN0aW9uLnR5cGUgPT09ICdEUk9QX0FOSU1BVElPTl9GSU5JU0hFRCcpIHtcbiAgICAgIGNsZWFyKCk7XG4gICAgfVxuICAgIG5leHQoYWN0aW9uKTtcbiAgICBpZiAoYWN0aW9uLnR5cGUgIT09ICdEUk9QX0FOSU1BVEUnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGJpbmRpbmcgPSB7XG4gICAgICBldmVudE5hbWU6ICdzY3JvbGwnLFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgfSxcbiAgICAgIGZuOiBmdW5jdGlvbiBmbHVzaERyb3BBbmltYXRpb24oKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgaWYgKHN0YXRlLnBoYXNlID09PSAnRFJPUF9BTklNQVRJTkcnKSB7XG4gICAgICAgICAgc3RvcmUuZGlzcGF0Y2goZHJvcEFuaW1hdGlvbkZpbmlzaGVkKCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBmcmFtZUlkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIGZyYW1lSWQgPSBudWxsO1xuICAgICAgdW5iaW5kID0gYmluZEV2ZW50cyh3aW5kb3csIFtiaW5kaW5nXSk7XG4gICAgfSk7XG4gIH07XG59O1xudmFyIGRyb3BBbmltYXRpb25GbHVzaE9uU2Nyb2xsID0gZHJvcEFuaW1hdGlvbkZsdXNoT25TY3JvbGxNaWRkbGV3YXJlO1xuXG52YXIgZGltZW5zaW9uTWFyc2hhbFN0b3BwZXIgPSAobWFyc2hhbCA9PiAoKSA9PiBuZXh0ID0+IGFjdGlvbiA9PiB7XG4gIGlmIChhY3Rpb24udHlwZSA9PT0gJ0RST1BfQ09NUExFVEUnIHx8IGFjdGlvbi50eXBlID09PSAnRkxVU0gnIHx8IGFjdGlvbi50eXBlID09PSAnRFJPUF9BTklNQVRFJykge1xuICAgIG1hcnNoYWwuc3RvcFB1Ymxpc2hpbmcoKTtcbiAgfVxuICBuZXh0KGFjdGlvbik7XG59KTtcblxudmFyIGZvY3VzID0gKG1hcnNoYWwgPT4ge1xuICBsZXQgaXNXYXRjaGluZyA9IGZhbHNlO1xuICByZXR1cm4gKCkgPT4gbmV4dCA9PiBhY3Rpb24gPT4ge1xuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gJ0lOSVRJQUxfUFVCTElTSCcpIHtcbiAgICAgIGlzV2F0Y2hpbmcgPSB0cnVlO1xuICAgICAgbWFyc2hhbC50cnlSZWNvcmRGb2N1cyhhY3Rpb24ucGF5bG9hZC5jcml0aWNhbC5kcmFnZ2FibGUuaWQpO1xuICAgICAgbmV4dChhY3Rpb24pO1xuICAgICAgbWFyc2hhbC50cnlSZXN0b3JlRm9jdXNSZWNvcmRlZCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBuZXh0KGFjdGlvbik7XG4gICAgaWYgKCFpc1dhdGNoaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gJ0ZMVVNIJykge1xuICAgICAgaXNXYXRjaGluZyA9IGZhbHNlO1xuICAgICAgbWFyc2hhbC50cnlSZXN0b3JlRm9jdXNSZWNvcmRlZCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09ICdEUk9QX0NPTVBMRVRFJykge1xuICAgICAgaXNXYXRjaGluZyA9IGZhbHNlO1xuICAgICAgY29uc3QgcmVzdWx0ID0gYWN0aW9uLnBheWxvYWQuY29tcGxldGVkLnJlc3VsdDtcbiAgICAgIGlmIChyZXN1bHQuY29tYmluZSkge1xuICAgICAgICBtYXJzaGFsLnRyeVNoaWZ0UmVjb3JkKHJlc3VsdC5kcmFnZ2FibGVJZCwgcmVzdWx0LmNvbWJpbmUuZHJhZ2dhYmxlSWQpO1xuICAgICAgfVxuICAgICAgbWFyc2hhbC50cnlSZXN0b3JlRm9jdXNSZWNvcmRlZCgpO1xuICAgIH1cbiAgfTtcbn0pO1xuXG5jb25zdCBzaG91bGRTdG9wID0gYWN0aW9uID0+IGFjdGlvbi50eXBlID09PSAnRFJPUF9DT01QTEVURScgfHwgYWN0aW9uLnR5cGUgPT09ICdEUk9QX0FOSU1BVEUnIHx8IGFjdGlvbi50eXBlID09PSAnRkxVU0gnO1xudmFyIGF1dG9TY3JvbGwgPSAoYXV0b1Njcm9sbGVyID0+IHN0b3JlID0+IG5leHQgPT4gYWN0aW9uID0+IHtcbiAgaWYgKHNob3VsZFN0b3AoYWN0aW9uKSkge1xuICAgIGF1dG9TY3JvbGxlci5zdG9wKCk7XG4gICAgbmV4dChhY3Rpb24pO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoYWN0aW9uLnR5cGUgPT09ICdJTklUSUFMX1BVQkxJU0gnKSB7XG4gICAgbmV4dChhY3Rpb24pO1xuICAgIGNvbnN0IHN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAhKHN0YXRlLnBoYXNlID09PSAnRFJBR0dJTkcnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHBoYXNlIHRvIGJlIERSQUdHSU5HIGFmdGVyIElOSVRJQUxfUFVCTElTSCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBhdXRvU2Nyb2xsZXIuc3RhcnQoc3RhdGUpO1xuICAgIHJldHVybjtcbiAgfVxuICBuZXh0KGFjdGlvbik7XG4gIGF1dG9TY3JvbGxlci5zY3JvbGwoc3RvcmUuZ2V0U3RhdGUoKSk7XG59KTtcblxuY29uc3QgcGVuZGluZ0Ryb3AgPSBzdG9yZSA9PiBuZXh0ID0+IGFjdGlvbiA9PiB7XG4gIG5leHQoYWN0aW9uKTtcbiAgaWYgKGFjdGlvbi50eXBlICE9PSAnUFVCTElTSF9XSElMRV9EUkFHR0lORycpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcG9zdEFjdGlvblN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgaWYgKHBvc3RBY3Rpb25TdGF0ZS5waGFzZSAhPT0gJ0RST1BfUEVORElORycpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHBvc3RBY3Rpb25TdGF0ZS5pc1dhaXRpbmcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgc3RvcmUuZGlzcGF0Y2goZHJvcCQxKHtcbiAgICByZWFzb246IHBvc3RBY3Rpb25TdGF0ZS5yZWFzb25cbiAgfSkpO1xufTtcbnZhciBwZW5kaW5nRHJvcCQxID0gcGVuZGluZ0Ryb3A7XG5cbmNvbnN0IGNvbXBvc2VFbmhhbmNlcnMgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5fX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9DT01QT1NFX18gPyB3aW5kb3cuX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fQ09NUE9TRV9fKHtcbiAgbmFtZTogJ0BoZWxsby1wYW5nZWEvZG5kJ1xufSkgOiBjb21wb3NlO1xudmFyIGNyZWF0ZVN0b3JlID0gKCh7XG4gIGRpbWVuc2lvbk1hcnNoYWwsXG4gIGZvY3VzTWFyc2hhbCxcbiAgc3R5bGVNYXJzaGFsLFxuICBnZXRSZXNwb25kZXJzLFxuICBhbm5vdW5jZSxcbiAgYXV0b1Njcm9sbGVyXG59KSA9PiBjcmVhdGVTdG9yZSQxKHJlZHVjZXIsIGNvbXBvc2VFbmhhbmNlcnMoYXBwbHlNaWRkbGV3YXJlKHN0eWxlKHN0eWxlTWFyc2hhbCksIGRpbWVuc2lvbk1hcnNoYWxTdG9wcGVyKGRpbWVuc2lvbk1hcnNoYWwpLCBsaWZ0KGRpbWVuc2lvbk1hcnNoYWwpLCBkcm9wLCBkcm9wQW5pbWF0aW9uRmluaXNoLCBkcm9wQW5pbWF0aW9uRmx1c2hPblNjcm9sbCwgcGVuZGluZ0Ryb3AkMSwgYXV0b1Njcm9sbChhdXRvU2Nyb2xsZXIpLCBzY3JvbGxMaXN0ZW5lciQxLCBmb2N1cyhmb2N1c01hcnNoYWwpLCByZXNwb25kZXJzKGdldFJlc3BvbmRlcnMsIGFubm91bmNlKSkpKSk7XG5cbmNvbnN0IGNsZWFuJDEgPSAoKSA9PiAoe1xuICBhZGRpdGlvbnM6IHt9LFxuICByZW1vdmFsczoge30sXG4gIG1vZGlmaWVkOiB7fVxufSk7XG5mdW5jdGlvbiBjcmVhdGVQdWJsaXNoZXIoe1xuICByZWdpc3RyeSxcbiAgY2FsbGJhY2tzXG59KSB7XG4gIGxldCBzdGFnaW5nID0gY2xlYW4kMSgpO1xuICBsZXQgZnJhbWVJZCA9IG51bGw7XG4gIGNvbnN0IGNvbGxlY3QgPSAoKSA9PiB7XG4gICAgaWYgKGZyYW1lSWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbGJhY2tzLmNvbGxlY3Rpb25TdGFydGluZygpO1xuICAgIGZyYW1lSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgZnJhbWVJZCA9IG51bGw7XG4gICAgICBzdGFydCgpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBhZGRpdGlvbnMsXG4gICAgICAgIHJlbW92YWxzLFxuICAgICAgICBtb2RpZmllZFxuICAgICAgfSA9IHN0YWdpbmc7XG4gICAgICBjb25zdCBhZGRlZCA9IE9iamVjdC5rZXlzKGFkZGl0aW9ucykubWFwKGlkID0+IHJlZ2lzdHJ5LmRyYWdnYWJsZS5nZXRCeUlkKGlkKS5nZXREaW1lbnNpb24ob3JpZ2luKSkuc29ydCgoYSwgYikgPT4gYS5kZXNjcmlwdG9yLmluZGV4IC0gYi5kZXNjcmlwdG9yLmluZGV4KTtcbiAgICAgIGNvbnN0IHVwZGF0ZWQgPSBPYmplY3Qua2V5cyhtb2RpZmllZCkubWFwKGlkID0+IHtcbiAgICAgICAgY29uc3QgZW50cnkgPSByZWdpc3RyeS5kcm9wcGFibGUuZ2V0QnlJZChpZCk7XG4gICAgICAgIGNvbnN0IHNjcm9sbCA9IGVudHJ5LmNhbGxiYWNrcy5nZXRTY3JvbGxXaGlsZURyYWdnaW5nKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZHJvcHBhYmxlSWQ6IGlkLFxuICAgICAgICAgIHNjcm9sbFxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIGFkZGl0aW9uczogYWRkZWQsXG4gICAgICAgIHJlbW92YWxzOiBPYmplY3Qua2V5cyhyZW1vdmFscyksXG4gICAgICAgIG1vZGlmaWVkOiB1cGRhdGVkXG4gICAgICB9O1xuICAgICAgc3RhZ2luZyA9IGNsZWFuJDEoKTtcbiAgICAgIGZpbmlzaCgpO1xuICAgICAgY2FsbGJhY2tzLnB1Ymxpc2gocmVzdWx0KTtcbiAgICB9KTtcbiAgfTtcbiAgY29uc3QgYWRkID0gZW50cnkgPT4ge1xuICAgIGNvbnN0IGlkID0gZW50cnkuZGVzY3JpcHRvci5pZDtcbiAgICBzdGFnaW5nLmFkZGl0aW9uc1tpZF0gPSBlbnRyeTtcbiAgICBzdGFnaW5nLm1vZGlmaWVkW2VudHJ5LmRlc2NyaXB0b3IuZHJvcHBhYmxlSWRdID0gdHJ1ZTtcbiAgICBpZiAoc3RhZ2luZy5yZW1vdmFsc1tpZF0pIHtcbiAgICAgIGRlbGV0ZSBzdGFnaW5nLnJlbW92YWxzW2lkXTtcbiAgICB9XG4gICAgY29sbGVjdCgpO1xuICB9O1xuICBjb25zdCByZW1vdmUgPSBlbnRyeSA9PiB7XG4gICAgY29uc3QgZGVzY3JpcHRvciA9IGVudHJ5LmRlc2NyaXB0b3I7XG4gICAgc3RhZ2luZy5yZW1vdmFsc1tkZXNjcmlwdG9yLmlkXSA9IHRydWU7XG4gICAgc3RhZ2luZy5tb2RpZmllZFtkZXNjcmlwdG9yLmRyb3BwYWJsZUlkXSA9IHRydWU7XG4gICAgaWYgKHN0YWdpbmcuYWRkaXRpb25zW2Rlc2NyaXB0b3IuaWRdKSB7XG4gICAgICBkZWxldGUgc3RhZ2luZy5hZGRpdGlvbnNbZGVzY3JpcHRvci5pZF07XG4gICAgfVxuICAgIGNvbGxlY3QoKTtcbiAgfTtcbiAgY29uc3Qgc3RvcCA9ICgpID0+IHtcbiAgICBpZiAoIWZyYW1lSWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoZnJhbWVJZCk7XG4gICAgZnJhbWVJZCA9IG51bGw7XG4gICAgc3RhZ2luZyA9IGNsZWFuJDEoKTtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBhZGQsXG4gICAgcmVtb3ZlLFxuICAgIHN0b3BcbiAgfTtcbn1cblxudmFyIGdldE1heFNjcm9sbCA9ICgoe1xuICBzY3JvbGxIZWlnaHQsXG4gIHNjcm9sbFdpZHRoLFxuICBoZWlnaHQsXG4gIHdpZHRoXG59KSA9PiB7XG4gIGNvbnN0IG1heFNjcm9sbCA9IHN1YnRyYWN0KHtcbiAgICB4OiBzY3JvbGxXaWR0aCxcbiAgICB5OiBzY3JvbGxIZWlnaHRcbiAgfSwge1xuICAgIHg6IHdpZHRoLFxuICAgIHk6IGhlaWdodFxuICB9KTtcbiAgY29uc3QgYWRqdXN0ZWRNYXhTY3JvbGwgPSB7XG4gICAgeDogTWF0aC5tYXgoMCwgbWF4U2Nyb2xsLngpLFxuICAgIHk6IE1hdGgubWF4KDAsIG1heFNjcm9sbC55KVxuICB9O1xuICByZXR1cm4gYWRqdXN0ZWRNYXhTY3JvbGw7XG59KTtcblxudmFyIGdldERvY3VtZW50RWxlbWVudCA9ICgoKSA9PiB7XG4gIGNvbnN0IGRvYyA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgIWRvYyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBmaW5kIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgcmV0dXJuIGRvYztcbn0pO1xuXG52YXIgZ2V0TWF4V2luZG93U2Nyb2xsID0gKCgpID0+IHtcbiAgY29uc3QgZG9jID0gZ2V0RG9jdW1lbnRFbGVtZW50KCk7XG4gIGNvbnN0IG1heFNjcm9sbCA9IGdldE1heFNjcm9sbCh7XG4gICAgc2Nyb2xsSGVpZ2h0OiBkb2Muc2Nyb2xsSGVpZ2h0LFxuICAgIHNjcm9sbFdpZHRoOiBkb2Muc2Nyb2xsV2lkdGgsXG4gICAgd2lkdGg6IGRvYy5jbGllbnRXaWR0aCxcbiAgICBoZWlnaHQ6IGRvYy5jbGllbnRIZWlnaHRcbiAgfSk7XG4gIHJldHVybiBtYXhTY3JvbGw7XG59KTtcblxudmFyIGdldFZpZXdwb3J0ID0gKCgpID0+IHtcbiAgY29uc3Qgc2Nyb2xsID0gZ2V0V2luZG93U2Nyb2xsKCk7XG4gIGNvbnN0IG1heFNjcm9sbCA9IGdldE1heFdpbmRvd1Njcm9sbCgpO1xuICBjb25zdCB0b3AgPSBzY3JvbGwueTtcbiAgY29uc3QgbGVmdCA9IHNjcm9sbC54O1xuICBjb25zdCBkb2MgPSBnZXREb2N1bWVudEVsZW1lbnQoKTtcbiAgY29uc3Qgd2lkdGggPSBkb2MuY2xpZW50V2lkdGg7XG4gIGNvbnN0IGhlaWdodCA9IGRvYy5jbGllbnRIZWlnaHQ7XG4gIGNvbnN0IHJpZ2h0ID0gbGVmdCArIHdpZHRoO1xuICBjb25zdCBib3R0b20gPSB0b3AgKyBoZWlnaHQ7XG4gIGNvbnN0IGZyYW1lID0gZ2V0UmVjdCh7XG4gICAgdG9wLFxuICAgIGxlZnQsXG4gICAgcmlnaHQsXG4gICAgYm90dG9tXG4gIH0pO1xuICBjb25zdCB2aWV3cG9ydCA9IHtcbiAgICBmcmFtZSxcbiAgICBzY3JvbGw6IHtcbiAgICAgIGluaXRpYWw6IHNjcm9sbCxcbiAgICAgIGN1cnJlbnQ6IHNjcm9sbCxcbiAgICAgIG1heDogbWF4U2Nyb2xsLFxuICAgICAgZGlmZjoge1xuICAgICAgICB2YWx1ZTogb3JpZ2luLFxuICAgICAgICBkaXNwbGFjZW1lbnQ6IG9yaWdpblxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHZpZXdwb3J0O1xufSk7XG5cbnZhciBnZXRJbml0aWFsUHVibGlzaCA9ICgoe1xuICBjcml0aWNhbCxcbiAgc2Nyb2xsT3B0aW9ucyxcbiAgcmVnaXN0cnlcbn0pID0+IHtcbiAgc3RhcnQoKTtcbiAgY29uc3Qgdmlld3BvcnQgPSBnZXRWaWV3cG9ydCgpO1xuICBjb25zdCB3aW5kb3dTY3JvbGwgPSB2aWV3cG9ydC5zY3JvbGwuY3VycmVudDtcbiAgY29uc3QgaG9tZSA9IGNyaXRpY2FsLmRyb3BwYWJsZTtcbiAgY29uc3QgZHJvcHBhYmxlcyA9IHJlZ2lzdHJ5LmRyb3BwYWJsZS5nZXRBbGxCeVR5cGUoaG9tZS50eXBlKS5tYXAoZW50cnkgPT4gZW50cnkuY2FsbGJhY2tzLmdldERpbWVuc2lvbkFuZFdhdGNoU2Nyb2xsKHdpbmRvd1Njcm9sbCwgc2Nyb2xsT3B0aW9ucykpO1xuICBjb25zdCBkcmFnZ2FibGVzID0gcmVnaXN0cnkuZHJhZ2dhYmxlLmdldEFsbEJ5VHlwZShjcml0aWNhbC5kcmFnZ2FibGUudHlwZSkubWFwKGVudHJ5ID0+IGVudHJ5LmdldERpbWVuc2lvbih3aW5kb3dTY3JvbGwpKTtcbiAgY29uc3QgZGltZW5zaW9ucyA9IHtcbiAgICBkcmFnZ2FibGVzOiB0b0RyYWdnYWJsZU1hcChkcmFnZ2FibGVzKSxcbiAgICBkcm9wcGFibGVzOiB0b0Ryb3BwYWJsZU1hcChkcm9wcGFibGVzKVxuICB9O1xuICBmaW5pc2goKTtcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIGRpbWVuc2lvbnMsXG4gICAgY3JpdGljYWwsXG4gICAgdmlld3BvcnRcbiAgfTtcbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuXG5mdW5jdGlvbiBzaG91bGRQdWJsaXNoVXBkYXRlKHJlZ2lzdHJ5LCBkcmFnZ2luZywgZW50cnkpIHtcbiAgaWYgKGVudHJ5LmRlc2NyaXB0b3IuaWQgPT09IGRyYWdnaW5nLmlkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChlbnRyeS5kZXNjcmlwdG9yLnR5cGUgIT09IGRyYWdnaW5nLnR5cGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgaG9tZSA9IHJlZ2lzdHJ5LmRyb3BwYWJsZS5nZXRCeUlkKGVudHJ5LmRlc2NyaXB0b3IuZHJvcHBhYmxlSWQpO1xuICBpZiAoaG9tZS5kZXNjcmlwdG9yLm1vZGUgIT09ICd2aXJ0dWFsJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoYFxuICAgICAgWW91IGFyZSBhdHRlbXB0aW5nIHRvIGFkZCBvciByZW1vdmUgYSBEcmFnZ2FibGUgW2lkOiAke2VudHJ5LmRlc2NyaXB0b3IuaWR9XVxuICAgICAgd2hpbGUgYSBkcmFnIGlzIG9jY3VycmluZy4gVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgdmlydHVhbCBsaXN0cy5cblxuICAgICAgU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9oZWxsby1wYW5nZWEvZG5kL2Jsb2IvbWFpbi9kb2NzL3BhdHRlcm5zL3ZpcnR1YWwtbGlzdHMubWRcbiAgICBgKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG52YXIgY3JlYXRlRGltZW5zaW9uTWFyc2hhbCA9ICgocmVnaXN0cnksIGNhbGxiYWNrcykgPT4ge1xuICBsZXQgY29sbGVjdGlvbiA9IG51bGw7XG4gIGNvbnN0IHB1Ymxpc2hlciA9IGNyZWF0ZVB1Ymxpc2hlcih7XG4gICAgY2FsbGJhY2tzOiB7XG4gICAgICBwdWJsaXNoOiBjYWxsYmFja3MucHVibGlzaFdoaWxlRHJhZ2dpbmcsXG4gICAgICBjb2xsZWN0aW9uU3RhcnRpbmc6IGNhbGxiYWNrcy5jb2xsZWN0aW9uU3RhcnRpbmdcbiAgICB9LFxuICAgIHJlZ2lzdHJ5XG4gIH0pO1xuICBjb25zdCB1cGRhdGVEcm9wcGFibGVJc0VuYWJsZWQgPSAoaWQsIGlzRW5hYmxlZCkgPT4ge1xuICAgICFyZWdpc3RyeS5kcm9wcGFibGUuZXhpc3RzKGlkKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYENhbm5vdCB1cGRhdGUgaXMgZW5hYmxlZCBmbGFnIG9mIERyb3BwYWJsZSAke2lkfSBhcyBpdCBpcyBub3QgcmVnaXN0ZXJlZGApIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBpZiAoIWNvbGxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbGJhY2tzLnVwZGF0ZURyb3BwYWJsZUlzRW5hYmxlZCh7XG4gICAgICBpZCxcbiAgICAgIGlzRW5hYmxlZFxuICAgIH0pO1xuICB9O1xuICBjb25zdCB1cGRhdGVEcm9wcGFibGVJc0NvbWJpbmVFbmFibGVkID0gKGlkLCBpc0NvbWJpbmVFbmFibGVkKSA9PiB7XG4gICAgaWYgKCFjb2xsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgICFyZWdpc3RyeS5kcm9wcGFibGUuZXhpc3RzKGlkKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYENhbm5vdCB1cGRhdGUgaXNDb21iaW5lRW5hYmxlZCBmbGFnIG9mIERyb3BwYWJsZSAke2lkfSBhcyBpdCBpcyBub3QgcmVnaXN0ZXJlZGApIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBjYWxsYmFja3MudXBkYXRlRHJvcHBhYmxlSXNDb21iaW5lRW5hYmxlZCh7XG4gICAgICBpZCxcbiAgICAgIGlzQ29tYmluZUVuYWJsZWRcbiAgICB9KTtcbiAgfTtcbiAgY29uc3QgdXBkYXRlRHJvcHBhYmxlU2Nyb2xsID0gKGlkLCBuZXdTY3JvbGwpID0+IHtcbiAgICBpZiAoIWNvbGxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgIXJlZ2lzdHJ5LmRyb3BwYWJsZS5leGlzdHMoaWQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBgQ2Fubm90IHVwZGF0ZSB0aGUgc2Nyb2xsIG9uIERyb3BwYWJsZSAke2lkfSBhcyBpdCBpcyBub3QgcmVnaXN0ZXJlZGApIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBjYWxsYmFja3MudXBkYXRlRHJvcHBhYmxlU2Nyb2xsKHtcbiAgICAgIGlkLFxuICAgICAgbmV3U2Nyb2xsXG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IHNjcm9sbERyb3BwYWJsZSA9IChpZCwgY2hhbmdlKSA9PiB7XG4gICAgaWYgKCFjb2xsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJlZ2lzdHJ5LmRyb3BwYWJsZS5nZXRCeUlkKGlkKS5jYWxsYmFja3Muc2Nyb2xsKGNoYW5nZSk7XG4gIH07XG4gIGNvbnN0IHN0b3BQdWJsaXNoaW5nID0gKCkgPT4ge1xuICAgIGlmICghY29sbGVjdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBwdWJsaXNoZXIuc3RvcCgpO1xuICAgIGNvbnN0IGhvbWUgPSBjb2xsZWN0aW9uLmNyaXRpY2FsLmRyb3BwYWJsZTtcbiAgICByZWdpc3RyeS5kcm9wcGFibGUuZ2V0QWxsQnlUeXBlKGhvbWUudHlwZSkuZm9yRWFjaChlbnRyeSA9PiBlbnRyeS5jYWxsYmFja3MuZHJhZ1N0b3BwZWQoKSk7XG4gICAgY29sbGVjdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIGNvbGxlY3Rpb24gPSBudWxsO1xuICB9O1xuICBjb25zdCBzdWJzY3JpYmVyID0gZXZlbnQgPT4ge1xuICAgICFjb2xsZWN0aW9uID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnU2hvdWxkIG9ubHkgYmUgc3Vic2NyaWJlZCB3aGVuIGEgY29sbGVjdGlvbiBpcyBvY2N1cnJpbmcnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgY29uc3QgZHJhZ2dpbmcgPSBjb2xsZWN0aW9uLmNyaXRpY2FsLmRyYWdnYWJsZTtcbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ0FERElUSU9OJykge1xuICAgICAgaWYgKHNob3VsZFB1Ymxpc2hVcGRhdGUocmVnaXN0cnksIGRyYWdnaW5nLCBldmVudC52YWx1ZSkpIHtcbiAgICAgICAgcHVibGlzaGVyLmFkZChldmVudC52YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChldmVudC50eXBlID09PSAnUkVNT1ZBTCcpIHtcbiAgICAgIGlmIChzaG91bGRQdWJsaXNoVXBkYXRlKHJlZ2lzdHJ5LCBkcmFnZ2luZywgZXZlbnQudmFsdWUpKSB7XG4gICAgICAgIHB1Ymxpc2hlci5yZW1vdmUoZXZlbnQudmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3RhcnRQdWJsaXNoaW5nID0gcmVxdWVzdCA9PiB7XG4gICAgISFjb2xsZWN0aW9uID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHN0YXJ0IGNhcHR1cmluZyBjcml0aWNhbCBkaW1lbnNpb25zIGFzIHRoZXJlIGlzIGFscmVhZHkgYSBjb2xsZWN0aW9uJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIGNvbnN0IGVudHJ5ID0gcmVnaXN0cnkuZHJhZ2dhYmxlLmdldEJ5SWQocmVxdWVzdC5kcmFnZ2FibGVJZCk7XG4gICAgY29uc3QgaG9tZSA9IHJlZ2lzdHJ5LmRyb3BwYWJsZS5nZXRCeUlkKGVudHJ5LmRlc2NyaXB0b3IuZHJvcHBhYmxlSWQpO1xuICAgIGNvbnN0IGNyaXRpY2FsID0ge1xuICAgICAgZHJhZ2dhYmxlOiBlbnRyeS5kZXNjcmlwdG9yLFxuICAgICAgZHJvcHBhYmxlOiBob21lLmRlc2NyaXB0b3JcbiAgICB9O1xuICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gcmVnaXN0cnkuc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICAgIGNvbGxlY3Rpb24gPSB7XG4gICAgICBjcml0aWNhbCxcbiAgICAgIHVuc3Vic2NyaWJlXG4gICAgfTtcbiAgICByZXR1cm4gZ2V0SW5pdGlhbFB1Ymxpc2goe1xuICAgICAgY3JpdGljYWwsXG4gICAgICByZWdpc3RyeSxcbiAgICAgIHNjcm9sbE9wdGlvbnM6IHJlcXVlc3Quc2Nyb2xsT3B0aW9uc1xuICAgIH0pO1xuICB9O1xuICBjb25zdCBtYXJzaGFsID0ge1xuICAgIHVwZGF0ZURyb3BwYWJsZUlzRW5hYmxlZCxcbiAgICB1cGRhdGVEcm9wcGFibGVJc0NvbWJpbmVFbmFibGVkLFxuICAgIHNjcm9sbERyb3BwYWJsZSxcbiAgICB1cGRhdGVEcm9wcGFibGVTY3JvbGwsXG4gICAgc3RhcnRQdWJsaXNoaW5nLFxuICAgIHN0b3BQdWJsaXNoaW5nXG4gIH07XG4gIHJldHVybiBtYXJzaGFsO1xufSk7XG5cbnZhciBjYW5TdGFydERyYWcgPSAoKHN0YXRlLCBpZCkgPT4ge1xuICBpZiAoc3RhdGUucGhhc2UgPT09ICdJRExFJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChzdGF0ZS5waGFzZSAhPT0gJ0RST1BfQU5JTUFUSU5HJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoc3RhdGUuY29tcGxldGVkLnJlc3VsdC5kcmFnZ2FibGVJZCA9PT0gaWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHN0YXRlLmNvbXBsZXRlZC5yZXN1bHQucmVhc29uID09PSAnRFJPUCc7XG59KTtcblxudmFyIHNjcm9sbFdpbmRvdyA9IChjaGFuZ2UgPT4ge1xuICB3aW5kb3cuc2Nyb2xsQnkoY2hhbmdlLngsIGNoYW5nZS55KTtcbn0pO1xuXG5jb25zdCBnZXRTY3JvbGxhYmxlRHJvcHBhYmxlcyA9IG1lbW9pemVPbmUoZHJvcHBhYmxlcyA9PiB0b0Ryb3BwYWJsZUxpc3QoZHJvcHBhYmxlcykuZmlsdGVyKGRyb3BwYWJsZSA9PiB7XG4gIGlmICghZHJvcHBhYmxlLmlzRW5hYmxlZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoIWRyb3BwYWJsZS5mcmFtZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn0pKTtcbmNvbnN0IGdldFNjcm9sbGFibGVEcm9wcGFibGVPdmVyID0gKHRhcmdldCwgZHJvcHBhYmxlcykgPT4ge1xuICBjb25zdCBtYXliZSA9IGdldFNjcm9sbGFibGVEcm9wcGFibGVzKGRyb3BwYWJsZXMpLmZpbmQoZHJvcHBhYmxlID0+IHtcbiAgICAhZHJvcHBhYmxlLmZyYW1lID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnSW52YWxpZCByZXN1bHQnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgcmV0dXJuIGlzUG9zaXRpb25JbkZyYW1lKGRyb3BwYWJsZS5mcmFtZS5wYWdlTWFyZ2luQm94KSh0YXJnZXQpO1xuICB9KSB8fCBudWxsO1xuICByZXR1cm4gbWF5YmU7XG59O1xudmFyIGdldEJlc3RTY3JvbGxhYmxlRHJvcHBhYmxlID0gKCh7XG4gIGNlbnRlcixcbiAgZGVzdGluYXRpb24sXG4gIGRyb3BwYWJsZXNcbn0pID0+IHtcbiAgaWYgKGRlc3RpbmF0aW9uKSB7XG4gICAgY29uc3QgZGltZW5zaW9uID0gZHJvcHBhYmxlc1tkZXN0aW5hdGlvbl07XG4gICAgaWYgKCFkaW1lbnNpb24uZnJhbWUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gZGltZW5zaW9uO1xuICB9XG4gIGNvbnN0IGRpbWVuc2lvbiA9IGdldFNjcm9sbGFibGVEcm9wcGFibGVPdmVyKGNlbnRlciwgZHJvcHBhYmxlcyk7XG4gIHJldHVybiBkaW1lbnNpb247XG59KTtcblxuY29uc3QgZGVmYXVsdEF1dG9TY3JvbGxlck9wdGlvbnMgPSB7XG4gIHN0YXJ0RnJvbVBlcmNlbnRhZ2U6IDAuMjUsXG4gIG1heFNjcm9sbEF0UGVyY2VudGFnZTogMC4wNSxcbiAgbWF4UGl4ZWxTY3JvbGw6IDI4LFxuICBlYXNlOiBwZXJjZW50YWdlID0+IHBlcmNlbnRhZ2UgKiogMixcbiAgZHVyYXRpb25EYW1wZW5pbmc6IHtcbiAgICBzdG9wRGFtcGVuaW5nQXQ6IDEyMDAsXG4gICAgYWNjZWxlcmF0ZUF0OiAzNjBcbiAgfSxcbiAgZGlzYWJsZWQ6IGZhbHNlXG59O1xuXG52YXIgZ2V0RGlzdGFuY2VUaHJlc2hvbGRzID0gKChjb250YWluZXIsIGF4aXMsIGdldEF1dG9TY3JvbGxlck9wdGlvbnMgPSAoKSA9PiBkZWZhdWx0QXV0b1Njcm9sbGVyT3B0aW9ucykgPT4ge1xuICBjb25zdCBhdXRvU2Nyb2xsZXJPcHRpb25zID0gZ2V0QXV0b1Njcm9sbGVyT3B0aW9ucygpO1xuICBjb25zdCBzdGFydFNjcm9sbGluZ0Zyb20gPSBjb250YWluZXJbYXhpcy5zaXplXSAqIGF1dG9TY3JvbGxlck9wdGlvbnMuc3RhcnRGcm9tUGVyY2VudGFnZTtcbiAgY29uc3QgbWF4U2Nyb2xsVmFsdWVBdCA9IGNvbnRhaW5lcltheGlzLnNpemVdICogYXV0b1Njcm9sbGVyT3B0aW9ucy5tYXhTY3JvbGxBdFBlcmNlbnRhZ2U7XG4gIGNvbnN0IHRocmVzaG9sZHMgPSB7XG4gICAgc3RhcnRTY3JvbGxpbmdGcm9tLFxuICAgIG1heFNjcm9sbFZhbHVlQXRcbiAgfTtcbiAgcmV0dXJuIHRocmVzaG9sZHM7XG59KTtcblxudmFyIGdldFBlcmNlbnRhZ2UgPSAoKHtcbiAgc3RhcnRPZlJhbmdlLFxuICBlbmRPZlJhbmdlLFxuICBjdXJyZW50XG59KSA9PiB7XG4gIGNvbnN0IHJhbmdlID0gZW5kT2ZSYW5nZSAtIHN0YXJ0T2ZSYW5nZTtcbiAgaWYgKHJhbmdlID09PSAwKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhgXG4gICAgICBEZXRlY3RlZCBkaXN0YW5jZSByYW5nZSBvZiAwIGluIHRoZSBmbHVpZCBhdXRvIHNjcm9sbGVyXG4gICAgICBUaGlzIGlzIHVuZXhwZWN0ZWQgYW5kIHdvdWxkIGNhdXNlIGEgZGl2aWRlIGJ5IDAgaXNzdWUuXG4gICAgICBOb3QgYWxsb3dpbmcgYW4gYXV0byBzY3JvbGxcbiAgICBgKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBjb25zdCBjdXJyZW50SW5SYW5nZSA9IGN1cnJlbnQgLSBzdGFydE9mUmFuZ2U7XG4gIGNvbnN0IHBlcmNlbnRhZ2UgPSBjdXJyZW50SW5SYW5nZSAvIHJhbmdlO1xuICByZXR1cm4gcGVyY2VudGFnZTtcbn0pO1xuXG52YXIgbWluU2Nyb2xsID0gMTtcblxudmFyIGdldFZhbHVlRnJvbURpc3RhbmNlID0gKChkaXN0YW5jZVRvRWRnZSwgdGhyZXNob2xkcywgZ2V0QXV0b1Njcm9sbGVyT3B0aW9ucyA9ICgpID0+IGRlZmF1bHRBdXRvU2Nyb2xsZXJPcHRpb25zKSA9PiB7XG4gIGNvbnN0IGF1dG9TY3JvbGxlck9wdGlvbnMgPSBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zKCk7XG4gIGlmIChkaXN0YW5jZVRvRWRnZSA+IHRocmVzaG9sZHMuc3RhcnRTY3JvbGxpbmdGcm9tKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgaWYgKGRpc3RhbmNlVG9FZGdlIDw9IHRocmVzaG9sZHMubWF4U2Nyb2xsVmFsdWVBdCkge1xuICAgIHJldHVybiBhdXRvU2Nyb2xsZXJPcHRpb25zLm1heFBpeGVsU2Nyb2xsO1xuICB9XG4gIGlmIChkaXN0YW5jZVRvRWRnZSA9PT0gdGhyZXNob2xkcy5zdGFydFNjcm9sbGluZ0Zyb20pIHtcbiAgICByZXR1cm4gbWluU2Nyb2xsO1xuICB9XG4gIGNvbnN0IHBlcmNlbnRhZ2VGcm9tTWF4U2Nyb2xsVmFsdWVBdCA9IGdldFBlcmNlbnRhZ2Uoe1xuICAgIHN0YXJ0T2ZSYW5nZTogdGhyZXNob2xkcy5tYXhTY3JvbGxWYWx1ZUF0LFxuICAgIGVuZE9mUmFuZ2U6IHRocmVzaG9sZHMuc3RhcnRTY3JvbGxpbmdGcm9tLFxuICAgIGN1cnJlbnQ6IGRpc3RhbmNlVG9FZGdlXG4gIH0pO1xuICBjb25zdCBwZXJjZW50YWdlRnJvbVN0YXJ0U2Nyb2xsaW5nRnJvbSA9IDEgLSBwZXJjZW50YWdlRnJvbU1heFNjcm9sbFZhbHVlQXQ7XG4gIGNvbnN0IHNjcm9sbCA9IGF1dG9TY3JvbGxlck9wdGlvbnMubWF4UGl4ZWxTY3JvbGwgKiBhdXRvU2Nyb2xsZXJPcHRpb25zLmVhc2UocGVyY2VudGFnZUZyb21TdGFydFNjcm9sbGluZ0Zyb20pO1xuICByZXR1cm4gTWF0aC5jZWlsKHNjcm9sbCk7XG59KTtcblxudmFyIGRhbXBlblZhbHVlQnlUaW1lID0gKChwcm9wb3NlZFNjcm9sbCwgZHJhZ1N0YXJ0VGltZSwgZ2V0QXV0b1Njcm9sbGVyT3B0aW9ucykgPT4ge1xuICBjb25zdCBhdXRvU2Nyb2xsZXJPcHRpb25zID0gZ2V0QXV0b1Njcm9sbGVyT3B0aW9ucygpO1xuICBjb25zdCBhY2NlbGVyYXRlQXQgPSBhdXRvU2Nyb2xsZXJPcHRpb25zLmR1cmF0aW9uRGFtcGVuaW5nLmFjY2VsZXJhdGVBdDtcbiAgY29uc3Qgc3RvcEF0ID0gYXV0b1Njcm9sbGVyT3B0aW9ucy5kdXJhdGlvbkRhbXBlbmluZy5zdG9wRGFtcGVuaW5nQXQ7XG4gIGNvbnN0IHN0YXJ0T2ZSYW5nZSA9IGRyYWdTdGFydFRpbWU7XG4gIGNvbnN0IGVuZE9mUmFuZ2UgPSBzdG9wQXQ7XG4gIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gIGNvbnN0IHJ1blRpbWUgPSBub3cgLSBzdGFydE9mUmFuZ2U7XG4gIGlmIChydW5UaW1lID49IHN0b3BBdCkge1xuICAgIHJldHVybiBwcm9wb3NlZFNjcm9sbDtcbiAgfVxuICBpZiAocnVuVGltZSA8IGFjY2VsZXJhdGVBdCkge1xuICAgIHJldHVybiBtaW5TY3JvbGw7XG4gIH1cbiAgY29uc3QgYmV0d2VlbkFjY2VsZXJhdGVBdEFuZFN0b3BBdFBlcmNlbnRhZ2UgPSBnZXRQZXJjZW50YWdlKHtcbiAgICBzdGFydE9mUmFuZ2U6IGFjY2VsZXJhdGVBdCxcbiAgICBlbmRPZlJhbmdlLFxuICAgIGN1cnJlbnQ6IHJ1blRpbWVcbiAgfSk7XG4gIGNvbnN0IHNjcm9sbCA9IHByb3Bvc2VkU2Nyb2xsICogYXV0b1Njcm9sbGVyT3B0aW9ucy5lYXNlKGJldHdlZW5BY2NlbGVyYXRlQXRBbmRTdG9wQXRQZXJjZW50YWdlKTtcbiAgcmV0dXJuIE1hdGguY2VpbChzY3JvbGwpO1xufSk7XG5cbnZhciBnZXRWYWx1ZSA9ICgoe1xuICBkaXN0YW5jZVRvRWRnZSxcbiAgdGhyZXNob2xkcyxcbiAgZHJhZ1N0YXJ0VGltZSxcbiAgc2hvdWxkVXNlVGltZURhbXBlbmluZyxcbiAgZ2V0QXV0b1Njcm9sbGVyT3B0aW9uc1xufSkgPT4ge1xuICBjb25zdCBzY3JvbGwgPSBnZXRWYWx1ZUZyb21EaXN0YW5jZShkaXN0YW5jZVRvRWRnZSwgdGhyZXNob2xkcywgZ2V0QXV0b1Njcm9sbGVyT3B0aW9ucyk7XG4gIGlmIChzY3JvbGwgPT09IDApIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBpZiAoIXNob3VsZFVzZVRpbWVEYW1wZW5pbmcpIHtcbiAgICByZXR1cm4gc2Nyb2xsO1xuICB9XG4gIHJldHVybiBNYXRoLm1heChkYW1wZW5WYWx1ZUJ5VGltZShzY3JvbGwsIGRyYWdTdGFydFRpbWUsIGdldEF1dG9TY3JvbGxlck9wdGlvbnMpLCBtaW5TY3JvbGwpO1xufSk7XG5cbnZhciBnZXRTY3JvbGxPbkF4aXMgPSAoKHtcbiAgY29udGFpbmVyLFxuICBkaXN0YW5jZVRvRWRnZXMsXG4gIGRyYWdTdGFydFRpbWUsXG4gIGF4aXMsXG4gIHNob3VsZFVzZVRpbWVEYW1wZW5pbmcsXG4gIGdldEF1dG9TY3JvbGxlck9wdGlvbnNcbn0pID0+IHtcbiAgY29uc3QgdGhyZXNob2xkcyA9IGdldERpc3RhbmNlVGhyZXNob2xkcyhjb250YWluZXIsIGF4aXMsIGdldEF1dG9TY3JvbGxlck9wdGlvbnMpO1xuICBjb25zdCBpc0Nsb3NlclRvRW5kID0gZGlzdGFuY2VUb0VkZ2VzW2F4aXMuZW5kXSA8IGRpc3RhbmNlVG9FZGdlc1theGlzLnN0YXJ0XTtcbiAgaWYgKGlzQ2xvc2VyVG9FbmQpIHtcbiAgICByZXR1cm4gZ2V0VmFsdWUoe1xuICAgICAgZGlzdGFuY2VUb0VkZ2U6IGRpc3RhbmNlVG9FZGdlc1theGlzLmVuZF0sXG4gICAgICB0aHJlc2hvbGRzLFxuICAgICAgZHJhZ1N0YXJ0VGltZSxcbiAgICAgIHNob3VsZFVzZVRpbWVEYW1wZW5pbmcsXG4gICAgICBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIC0xICogZ2V0VmFsdWUoe1xuICAgIGRpc3RhbmNlVG9FZGdlOiBkaXN0YW5jZVRvRWRnZXNbYXhpcy5zdGFydF0sXG4gICAgdGhyZXNob2xkcyxcbiAgICBkcmFnU3RhcnRUaW1lLFxuICAgIHNob3VsZFVzZVRpbWVEYW1wZW5pbmcsXG4gICAgZ2V0QXV0b1Njcm9sbGVyT3B0aW9uc1xuICB9KTtcbn0pO1xuXG52YXIgYWRqdXN0Rm9yU2l6ZUxpbWl0cyA9ICgoe1xuICBjb250YWluZXIsXG4gIHN1YmplY3QsXG4gIHByb3Bvc2VkU2Nyb2xsXG59KSA9PiB7XG4gIGNvbnN0IGlzVG9vQmlnVmVydGljYWxseSA9IHN1YmplY3QuaGVpZ2h0ID4gY29udGFpbmVyLmhlaWdodDtcbiAgY29uc3QgaXNUb29CaWdIb3Jpem9udGFsbHkgPSBzdWJqZWN0LndpZHRoID4gY29udGFpbmVyLndpZHRoO1xuICBpZiAoIWlzVG9vQmlnSG9yaXpvbnRhbGx5ICYmICFpc1Rvb0JpZ1ZlcnRpY2FsbHkpIHtcbiAgICByZXR1cm4gcHJvcG9zZWRTY3JvbGw7XG4gIH1cbiAgaWYgKGlzVG9vQmlnSG9yaXpvbnRhbGx5ICYmIGlzVG9vQmlnVmVydGljYWxseSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiB7XG4gICAgeDogaXNUb29CaWdIb3Jpem9udGFsbHkgPyAwIDogcHJvcG9zZWRTY3JvbGwueCxcbiAgICB5OiBpc1Rvb0JpZ1ZlcnRpY2FsbHkgPyAwIDogcHJvcG9zZWRTY3JvbGwueVxuICB9O1xufSk7XG5cbmNvbnN0IGNsZWFuID0gYXBwbHkodmFsdWUgPT4gdmFsdWUgPT09IDAgPyAwIDogdmFsdWUpO1xudmFyIGdldFNjcm9sbCQxID0gKCh7XG4gIGRyYWdTdGFydFRpbWUsXG4gIGNvbnRhaW5lcixcbiAgc3ViamVjdCxcbiAgY2VudGVyLFxuICBzaG91bGRVc2VUaW1lRGFtcGVuaW5nLFxuICBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zXG59KSA9PiB7XG4gIGNvbnN0IGRpc3RhbmNlVG9FZGdlcyA9IHtcbiAgICB0b3A6IGNlbnRlci55IC0gY29udGFpbmVyLnRvcCxcbiAgICByaWdodDogY29udGFpbmVyLnJpZ2h0IC0gY2VudGVyLngsXG4gICAgYm90dG9tOiBjb250YWluZXIuYm90dG9tIC0gY2VudGVyLnksXG4gICAgbGVmdDogY2VudGVyLnggLSBjb250YWluZXIubGVmdFxuICB9O1xuICBjb25zdCB5ID0gZ2V0U2Nyb2xsT25BeGlzKHtcbiAgICBjb250YWluZXIsXG4gICAgZGlzdGFuY2VUb0VkZ2VzLFxuICAgIGRyYWdTdGFydFRpbWUsXG4gICAgYXhpczogdmVydGljYWwsXG4gICAgc2hvdWxkVXNlVGltZURhbXBlbmluZyxcbiAgICBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zXG4gIH0pO1xuICBjb25zdCB4ID0gZ2V0U2Nyb2xsT25BeGlzKHtcbiAgICBjb250YWluZXIsXG4gICAgZGlzdGFuY2VUb0VkZ2VzLFxuICAgIGRyYWdTdGFydFRpbWUsXG4gICAgYXhpczogaG9yaXpvbnRhbCxcbiAgICBzaG91bGRVc2VUaW1lRGFtcGVuaW5nLFxuICAgIGdldEF1dG9TY3JvbGxlck9wdGlvbnNcbiAgfSk7XG4gIGNvbnN0IHJlcXVpcmVkID0gY2xlYW4oe1xuICAgIHgsXG4gICAgeVxuICB9KTtcbiAgaWYgKGlzRXF1YWwkMShyZXF1aXJlZCwgb3JpZ2luKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGxpbWl0ZWQgPSBhZGp1c3RGb3JTaXplTGltaXRzKHtcbiAgICBjb250YWluZXIsXG4gICAgc3ViamVjdCxcbiAgICBwcm9wb3NlZFNjcm9sbDogcmVxdWlyZWRcbiAgfSk7XG4gIGlmICghbGltaXRlZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBpc0VxdWFsJDEobGltaXRlZCwgb3JpZ2luKSA/IG51bGwgOiBsaW1pdGVkO1xufSk7XG5cbmNvbnN0IHNtYWxsZXN0U2lnbmVkID0gYXBwbHkodmFsdWUgPT4ge1xuICBpZiAodmFsdWUgPT09IDApIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICByZXR1cm4gdmFsdWUgPiAwID8gMSA6IC0xO1xufSk7XG5jb25zdCBnZXRPdmVybGFwID0gKCgpID0+IHtcbiAgY29uc3QgZ2V0UmVtYWluZGVyID0gKHRhcmdldCwgbWF4KSA9PiB7XG4gICAgaWYgKHRhcmdldCA8IDApIHtcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICAgIGlmICh0YXJnZXQgPiBtYXgpIHtcbiAgICAgIHJldHVybiB0YXJnZXQgLSBtYXg7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9O1xuICByZXR1cm4gKHtcbiAgICBjdXJyZW50LFxuICAgIG1heCxcbiAgICBjaGFuZ2VcbiAgfSkgPT4ge1xuICAgIGNvbnN0IHRhcmdldFNjcm9sbCA9IGFkZChjdXJyZW50LCBjaGFuZ2UpO1xuICAgIGNvbnN0IG92ZXJsYXAgPSB7XG4gICAgICB4OiBnZXRSZW1haW5kZXIodGFyZ2V0U2Nyb2xsLngsIG1heC54KSxcbiAgICAgIHk6IGdldFJlbWFpbmRlcih0YXJnZXRTY3JvbGwueSwgbWF4LnkpXG4gICAgfTtcbiAgICBpZiAoaXNFcXVhbCQxKG92ZXJsYXAsIG9yaWdpbikpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gb3ZlcmxhcDtcbiAgfTtcbn0pKCk7XG5jb25zdCBjYW5QYXJ0aWFsbHlTY3JvbGwgPSAoe1xuICBtYXg6IHJhd01heCxcbiAgY3VycmVudCxcbiAgY2hhbmdlXG59KSA9PiB7XG4gIGNvbnN0IG1heCA9IHtcbiAgICB4OiBNYXRoLm1heChjdXJyZW50LngsIHJhd01heC54KSxcbiAgICB5OiBNYXRoLm1heChjdXJyZW50LnksIHJhd01heC55KVxuICB9O1xuICBjb25zdCBzbWFsbGVzdENoYW5nZSA9IHNtYWxsZXN0U2lnbmVkKGNoYW5nZSk7XG4gIGNvbnN0IG92ZXJsYXAgPSBnZXRPdmVybGFwKHtcbiAgICBtYXgsXG4gICAgY3VycmVudCxcbiAgICBjaGFuZ2U6IHNtYWxsZXN0Q2hhbmdlXG4gIH0pO1xuICBpZiAoIW92ZXJsYXApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoc21hbGxlc3RDaGFuZ2UueCAhPT0gMCAmJiBvdmVybGFwLnggPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoc21hbGxlc3RDaGFuZ2UueSAhPT0gMCAmJiBvdmVybGFwLnkgPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuY29uc3QgY2FuU2Nyb2xsV2luZG93ID0gKHZpZXdwb3J0LCBjaGFuZ2UpID0+IGNhblBhcnRpYWxseVNjcm9sbCh7XG4gIGN1cnJlbnQ6IHZpZXdwb3J0LnNjcm9sbC5jdXJyZW50LFxuICBtYXg6IHZpZXdwb3J0LnNjcm9sbC5tYXgsXG4gIGNoYW5nZVxufSk7XG5jb25zdCBnZXRXaW5kb3dPdmVybGFwID0gKHZpZXdwb3J0LCBjaGFuZ2UpID0+IHtcbiAgaWYgKCFjYW5TY3JvbGxXaW5kb3codmlld3BvcnQsIGNoYW5nZSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBtYXggPSB2aWV3cG9ydC5zY3JvbGwubWF4O1xuICBjb25zdCBjdXJyZW50ID0gdmlld3BvcnQuc2Nyb2xsLmN1cnJlbnQ7XG4gIHJldHVybiBnZXRPdmVybGFwKHtcbiAgICBjdXJyZW50LFxuICAgIG1heCxcbiAgICBjaGFuZ2VcbiAgfSk7XG59O1xuY29uc3QgY2FuU2Nyb2xsRHJvcHBhYmxlID0gKGRyb3BwYWJsZSwgY2hhbmdlKSA9PiB7XG4gIGNvbnN0IGZyYW1lID0gZHJvcHBhYmxlLmZyYW1lO1xuICBpZiAoIWZyYW1lKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBjYW5QYXJ0aWFsbHlTY3JvbGwoe1xuICAgIGN1cnJlbnQ6IGZyYW1lLnNjcm9sbC5jdXJyZW50LFxuICAgIG1heDogZnJhbWUuc2Nyb2xsLm1heCxcbiAgICBjaGFuZ2VcbiAgfSk7XG59O1xuY29uc3QgZ2V0RHJvcHBhYmxlT3ZlcmxhcCA9IChkcm9wcGFibGUsIGNoYW5nZSkgPT4ge1xuICBjb25zdCBmcmFtZSA9IGRyb3BwYWJsZS5mcmFtZTtcbiAgaWYgKCFmcmFtZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmICghY2FuU2Nyb2xsRHJvcHBhYmxlKGRyb3BwYWJsZSwgY2hhbmdlKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBnZXRPdmVybGFwKHtcbiAgICBjdXJyZW50OiBmcmFtZS5zY3JvbGwuY3VycmVudCxcbiAgICBtYXg6IGZyYW1lLnNjcm9sbC5tYXgsXG4gICAgY2hhbmdlXG4gIH0pO1xufTtcblxudmFyIGdldFdpbmRvd1Njcm9sbENoYW5nZSA9ICgoe1xuICB2aWV3cG9ydCxcbiAgc3ViamVjdCxcbiAgY2VudGVyLFxuICBkcmFnU3RhcnRUaW1lLFxuICBzaG91bGRVc2VUaW1lRGFtcGVuaW5nLFxuICBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zXG59KSA9PiB7XG4gIGNvbnN0IHNjcm9sbCA9IGdldFNjcm9sbCQxKHtcbiAgICBkcmFnU3RhcnRUaW1lLFxuICAgIGNvbnRhaW5lcjogdmlld3BvcnQuZnJhbWUsXG4gICAgc3ViamVjdCxcbiAgICBjZW50ZXIsXG4gICAgc2hvdWxkVXNlVGltZURhbXBlbmluZyxcbiAgICBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zXG4gIH0pO1xuICByZXR1cm4gc2Nyb2xsICYmIGNhblNjcm9sbFdpbmRvdyh2aWV3cG9ydCwgc2Nyb2xsKSA/IHNjcm9sbCA6IG51bGw7XG59KTtcblxudmFyIGdldERyb3BwYWJsZVNjcm9sbENoYW5nZSA9ICgoe1xuICBkcm9wcGFibGUsXG4gIHN1YmplY3QsXG4gIGNlbnRlcixcbiAgZHJhZ1N0YXJ0VGltZSxcbiAgc2hvdWxkVXNlVGltZURhbXBlbmluZyxcbiAgZ2V0QXV0b1Njcm9sbGVyT3B0aW9uc1xufSkgPT4ge1xuICBjb25zdCBmcmFtZSA9IGRyb3BwYWJsZS5mcmFtZTtcbiAgaWYgKCFmcmFtZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHNjcm9sbCA9IGdldFNjcm9sbCQxKHtcbiAgICBkcmFnU3RhcnRUaW1lLFxuICAgIGNvbnRhaW5lcjogZnJhbWUucGFnZU1hcmdpbkJveCxcbiAgICBzdWJqZWN0LFxuICAgIGNlbnRlcixcbiAgICBzaG91bGRVc2VUaW1lRGFtcGVuaW5nLFxuICAgIGdldEF1dG9TY3JvbGxlck9wdGlvbnNcbiAgfSk7XG4gIHJldHVybiBzY3JvbGwgJiYgY2FuU2Nyb2xsRHJvcHBhYmxlKGRyb3BwYWJsZSwgc2Nyb2xsKSA/IHNjcm9sbCA6IG51bGw7XG59KTtcblxudmFyIHNjcm9sbCA9ICgoe1xuICBzdGF0ZSxcbiAgZHJhZ1N0YXJ0VGltZSxcbiAgc2hvdWxkVXNlVGltZURhbXBlbmluZyxcbiAgc2Nyb2xsV2luZG93LFxuICBzY3JvbGxEcm9wcGFibGUsXG4gIGdldEF1dG9TY3JvbGxlck9wdGlvbnNcbn0pID0+IHtcbiAgY29uc3QgY2VudGVyID0gc3RhdGUuY3VycmVudC5wYWdlLmJvcmRlckJveENlbnRlcjtcbiAgY29uc3QgZHJhZ2dhYmxlID0gc3RhdGUuZGltZW5zaW9ucy5kcmFnZ2FibGVzW3N0YXRlLmNyaXRpY2FsLmRyYWdnYWJsZS5pZF07XG4gIGNvbnN0IHN1YmplY3QgPSBkcmFnZ2FibGUucGFnZS5tYXJnaW5Cb3g7XG4gIGlmIChzdGF0ZS5pc1dpbmRvd1Njcm9sbEFsbG93ZWQpIHtcbiAgICBjb25zdCB2aWV3cG9ydCA9IHN0YXRlLnZpZXdwb3J0O1xuICAgIGNvbnN0IGNoYW5nZSA9IGdldFdpbmRvd1Njcm9sbENoYW5nZSh7XG4gICAgICBkcmFnU3RhcnRUaW1lLFxuICAgICAgdmlld3BvcnQsXG4gICAgICBzdWJqZWN0LFxuICAgICAgY2VudGVyLFxuICAgICAgc2hvdWxkVXNlVGltZURhbXBlbmluZyxcbiAgICAgIGdldEF1dG9TY3JvbGxlck9wdGlvbnNcbiAgICB9KTtcbiAgICBpZiAoY2hhbmdlKSB7XG4gICAgICBzY3JvbGxXaW5kb3coY2hhbmdlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgY29uc3QgZHJvcHBhYmxlID0gZ2V0QmVzdFNjcm9sbGFibGVEcm9wcGFibGUoe1xuICAgIGNlbnRlcixcbiAgICBkZXN0aW5hdGlvbjogd2hhdElzRHJhZ2dlZE92ZXIoc3RhdGUuaW1wYWN0KSxcbiAgICBkcm9wcGFibGVzOiBzdGF0ZS5kaW1lbnNpb25zLmRyb3BwYWJsZXNcbiAgfSk7XG4gIGlmICghZHJvcHBhYmxlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGNoYW5nZSA9IGdldERyb3BwYWJsZVNjcm9sbENoYW5nZSh7XG4gICAgZHJhZ1N0YXJ0VGltZSxcbiAgICBkcm9wcGFibGUsXG4gICAgc3ViamVjdCxcbiAgICBjZW50ZXIsXG4gICAgc2hvdWxkVXNlVGltZURhbXBlbmluZyxcbiAgICBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zXG4gIH0pO1xuICBpZiAoY2hhbmdlKSB7XG4gICAgc2Nyb2xsRHJvcHBhYmxlKGRyb3BwYWJsZS5kZXNjcmlwdG9yLmlkLCBjaGFuZ2UpO1xuICB9XG59KTtcblxudmFyIGNyZWF0ZUZsdWlkU2Nyb2xsZXIgPSAoKHtcbiAgc2Nyb2xsV2luZG93LFxuICBzY3JvbGxEcm9wcGFibGUsXG4gIGdldEF1dG9TY3JvbGxlck9wdGlvbnMgPSAoKSA9PiBkZWZhdWx0QXV0b1Njcm9sbGVyT3B0aW9uc1xufSkgPT4ge1xuICBjb25zdCBzY2hlZHVsZVdpbmRvd1Njcm9sbCA9IHJhZlNjaGQoc2Nyb2xsV2luZG93KTtcbiAgY29uc3Qgc2NoZWR1bGVEcm9wcGFibGVTY3JvbGwgPSByYWZTY2hkKHNjcm9sbERyb3BwYWJsZSk7XG4gIGxldCBkcmFnZ2luZyA9IG51bGw7XG4gIGNvbnN0IHRyeVNjcm9sbCA9IHN0YXRlID0+IHtcbiAgICAhZHJhZ2dpbmcgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgZmx1aWQgc2Nyb2xsIGlmIG5vdCBkcmFnZ2luZycpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBjb25zdCB7XG4gICAgICBzaG91bGRVc2VUaW1lRGFtcGVuaW5nLFxuICAgICAgZHJhZ1N0YXJ0VGltZVxuICAgIH0gPSBkcmFnZ2luZztcbiAgICBzY3JvbGwoe1xuICAgICAgc3RhdGUsXG4gICAgICBzY3JvbGxXaW5kb3c6IHNjaGVkdWxlV2luZG93U2Nyb2xsLFxuICAgICAgc2Nyb2xsRHJvcHBhYmxlOiBzY2hlZHVsZURyb3BwYWJsZVNjcm9sbCxcbiAgICAgIGRyYWdTdGFydFRpbWUsXG4gICAgICBzaG91bGRVc2VUaW1lRGFtcGVuaW5nLFxuICAgICAgZ2V0QXV0b1Njcm9sbGVyT3B0aW9uc1xuICAgIH0pO1xuICB9O1xuICBjb25zdCBzdGFydCQxID0gc3RhdGUgPT4ge1xuICAgIHN0YXJ0KCk7XG4gICAgISFkcmFnZ2luZyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBzdGFydCBhdXRvIHNjcm9sbGluZyB3aGVuIGFscmVhZHkgc3RhcnRlZCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBjb25zdCBkcmFnU3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBsZXQgd2FzU2Nyb2xsTmVlZGVkID0gZmFsc2U7XG4gICAgY29uc3QgZmFrZVNjcm9sbENhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgd2FzU2Nyb2xsTmVlZGVkID0gdHJ1ZTtcbiAgICB9O1xuICAgIHNjcm9sbCh7XG4gICAgICBzdGF0ZSxcbiAgICAgIGRyYWdTdGFydFRpbWU6IDAsXG4gICAgICBzaG91bGRVc2VUaW1lRGFtcGVuaW5nOiBmYWxzZSxcbiAgICAgIHNjcm9sbFdpbmRvdzogZmFrZVNjcm9sbENhbGxiYWNrLFxuICAgICAgc2Nyb2xsRHJvcHBhYmxlOiBmYWtlU2Nyb2xsQ2FsbGJhY2ssXG4gICAgICBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zXG4gICAgfSk7XG4gICAgZHJhZ2dpbmcgPSB7XG4gICAgICBkcmFnU3RhcnRUaW1lLFxuICAgICAgc2hvdWxkVXNlVGltZURhbXBlbmluZzogd2FzU2Nyb2xsTmVlZGVkXG4gICAgfTtcbiAgICBmaW5pc2goKTtcbiAgICBpZiAod2FzU2Nyb2xsTmVlZGVkKSB7XG4gICAgICB0cnlTY3JvbGwoc3RhdGUpO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3RvcCA9ICgpID0+IHtcbiAgICBpZiAoIWRyYWdnaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNjaGVkdWxlV2luZG93U2Nyb2xsLmNhbmNlbCgpO1xuICAgIHNjaGVkdWxlRHJvcHBhYmxlU2Nyb2xsLmNhbmNlbCgpO1xuICAgIGRyYWdnaW5nID0gbnVsbDtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBzdGFydDogc3RhcnQkMSxcbiAgICBzdG9wLFxuICAgIHNjcm9sbDogdHJ5U2Nyb2xsXG4gIH07XG59KTtcblxudmFyIGNyZWF0ZUp1bXBTY3JvbGxlciA9ICgoe1xuICBtb3ZlLFxuICBzY3JvbGxEcm9wcGFibGUsXG4gIHNjcm9sbFdpbmRvd1xufSkgPT4ge1xuICBjb25zdCBtb3ZlQnlPZmZzZXQgPSAoc3RhdGUsIG9mZnNldCkgPT4ge1xuICAgIGNvbnN0IGNsaWVudCA9IGFkZChzdGF0ZS5jdXJyZW50LmNsaWVudC5zZWxlY3Rpb24sIG9mZnNldCk7XG4gICAgbW92ZSh7XG4gICAgICBjbGllbnRcbiAgICB9KTtcbiAgfTtcbiAgY29uc3Qgc2Nyb2xsRHJvcHBhYmxlQXNNdWNoQXNJdENhbiA9IChkcm9wcGFibGUsIGNoYW5nZSkgPT4ge1xuICAgIGlmICghY2FuU2Nyb2xsRHJvcHBhYmxlKGRyb3BwYWJsZSwgY2hhbmdlKSkge1xuICAgICAgcmV0dXJuIGNoYW5nZTtcbiAgICB9XG4gICAgY29uc3Qgb3ZlcmxhcCA9IGdldERyb3BwYWJsZU92ZXJsYXAoZHJvcHBhYmxlLCBjaGFuZ2UpO1xuICAgIGlmICghb3ZlcmxhcCkge1xuICAgICAgc2Nyb2xsRHJvcHBhYmxlKGRyb3BwYWJsZS5kZXNjcmlwdG9yLmlkLCBjaGFuZ2UpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHdoYXRUaGVEcm9wcGFibGVDYW5TY3JvbGwgPSBzdWJ0cmFjdChjaGFuZ2UsIG92ZXJsYXApO1xuICAgIHNjcm9sbERyb3BwYWJsZShkcm9wcGFibGUuZGVzY3JpcHRvci5pZCwgd2hhdFRoZURyb3BwYWJsZUNhblNjcm9sbCk7XG4gICAgY29uc3QgcmVtYWluZGVyID0gc3VidHJhY3QoY2hhbmdlLCB3aGF0VGhlRHJvcHBhYmxlQ2FuU2Nyb2xsKTtcbiAgICByZXR1cm4gcmVtYWluZGVyO1xuICB9O1xuICBjb25zdCBzY3JvbGxXaW5kb3dBc011Y2hBc0l0Q2FuID0gKGlzV2luZG93U2Nyb2xsQWxsb3dlZCwgdmlld3BvcnQsIGNoYW5nZSkgPT4ge1xuICAgIGlmICghaXNXaW5kb3dTY3JvbGxBbGxvd2VkKSB7XG4gICAgICByZXR1cm4gY2hhbmdlO1xuICAgIH1cbiAgICBpZiAoIWNhblNjcm9sbFdpbmRvdyh2aWV3cG9ydCwgY2hhbmdlKSkge1xuICAgICAgcmV0dXJuIGNoYW5nZTtcbiAgICB9XG4gICAgY29uc3Qgb3ZlcmxhcCA9IGdldFdpbmRvd092ZXJsYXAodmlld3BvcnQsIGNoYW5nZSk7XG4gICAgaWYgKCFvdmVybGFwKSB7XG4gICAgICBzY3JvbGxXaW5kb3coY2hhbmdlKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB3aGF0VGhlV2luZG93Q2FuU2Nyb2xsID0gc3VidHJhY3QoY2hhbmdlLCBvdmVybGFwKTtcbiAgICBzY3JvbGxXaW5kb3cod2hhdFRoZVdpbmRvd0NhblNjcm9sbCk7XG4gICAgY29uc3QgcmVtYWluZGVyID0gc3VidHJhY3QoY2hhbmdlLCB3aGF0VGhlV2luZG93Q2FuU2Nyb2xsKTtcbiAgICByZXR1cm4gcmVtYWluZGVyO1xuICB9O1xuICBjb25zdCBqdW1wU2Nyb2xsZXIgPSBzdGF0ZSA9PiB7XG4gICAgY29uc3QgcmVxdWVzdCA9IHN0YXRlLnNjcm9sbEp1bXBSZXF1ZXN0O1xuICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkZXN0aW5hdGlvbiA9IHdoYXRJc0RyYWdnZWRPdmVyKHN0YXRlLmltcGFjdCk7XG4gICAgIWRlc3RpbmF0aW9uID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHBlcmZvcm0gYSBqdW1wIHNjcm9sbCB3aGVuIHRoZXJlIGlzIG5vIGRlc3RpbmF0aW9uJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIGNvbnN0IGRyb3BwYWJsZVJlbWFpbmRlciA9IHNjcm9sbERyb3BwYWJsZUFzTXVjaEFzSXRDYW4oc3RhdGUuZGltZW5zaW9ucy5kcm9wcGFibGVzW2Rlc3RpbmF0aW9uXSwgcmVxdWVzdCk7XG4gICAgaWYgKCFkcm9wcGFibGVSZW1haW5kZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgdmlld3BvcnQgPSBzdGF0ZS52aWV3cG9ydDtcbiAgICBjb25zdCB3aW5kb3dSZW1haW5kZXIgPSBzY3JvbGxXaW5kb3dBc011Y2hBc0l0Q2FuKHN0YXRlLmlzV2luZG93U2Nyb2xsQWxsb3dlZCwgdmlld3BvcnQsIGRyb3BwYWJsZVJlbWFpbmRlcik7XG4gICAgaWYgKCF3aW5kb3dSZW1haW5kZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbW92ZUJ5T2Zmc2V0KHN0YXRlLCB3aW5kb3dSZW1haW5kZXIpO1xuICB9O1xuICByZXR1cm4ganVtcFNjcm9sbGVyO1xufSk7XG5cbnZhciBjcmVhdGVBdXRvU2Nyb2xsZXIgPSAoKHtcbiAgc2Nyb2xsRHJvcHBhYmxlLFxuICBzY3JvbGxXaW5kb3csXG4gIG1vdmUsXG4gIGdldEF1dG9TY3JvbGxlck9wdGlvbnNcbn0pID0+IHtcbiAgY29uc3QgZmx1aWRTY3JvbGxlciA9IGNyZWF0ZUZsdWlkU2Nyb2xsZXIoe1xuICAgIHNjcm9sbFdpbmRvdyxcbiAgICBzY3JvbGxEcm9wcGFibGUsXG4gICAgZ2V0QXV0b1Njcm9sbGVyT3B0aW9uc1xuICB9KTtcbiAgY29uc3QganVtcFNjcm9sbCA9IGNyZWF0ZUp1bXBTY3JvbGxlcih7XG4gICAgbW92ZSxcbiAgICBzY3JvbGxXaW5kb3csXG4gICAgc2Nyb2xsRHJvcHBhYmxlXG4gIH0pO1xuICBjb25zdCBzY3JvbGwgPSBzdGF0ZSA9PiB7XG4gICAgY29uc3QgYXV0b1Njcm9sbGVyT3B0aW9ucyA9IGdldEF1dG9TY3JvbGxlck9wdGlvbnMoKTtcbiAgICBpZiAoYXV0b1Njcm9sbGVyT3B0aW9ucy5kaXNhYmxlZCB8fCBzdGF0ZS5waGFzZSAhPT0gJ0RSQUdHSU5HJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoc3RhdGUubW92ZW1lbnRNb2RlID09PSAnRkxVSUQnKSB7XG4gICAgICBmbHVpZFNjcm9sbGVyLnNjcm9sbChzdGF0ZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghc3RhdGUuc2Nyb2xsSnVtcFJlcXVlc3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAganVtcFNjcm9sbChzdGF0ZSk7XG4gIH07XG4gIGNvbnN0IHNjcm9sbGVyID0ge1xuICAgIHNjcm9sbCxcbiAgICBzdGFydDogZmx1aWRTY3JvbGxlci5zdGFydCxcbiAgICBzdG9wOiBmbHVpZFNjcm9sbGVyLnN0b3BcbiAgfTtcbiAgcmV0dXJuIHNjcm9sbGVyO1xufSk7XG5cbmNvbnN0IHByZWZpeCA9ICdkYXRhLXJmZCc7XG5jb25zdCBkcmFnSGFuZGxlID0gKCgpID0+IHtcbiAgY29uc3QgYmFzZSA9IGAke3ByZWZpeH0tZHJhZy1oYW5kbGVgO1xuICByZXR1cm4ge1xuICAgIGJhc2UsXG4gICAgZHJhZ2dhYmxlSWQ6IGAke2Jhc2V9LWRyYWdnYWJsZS1pZGAsXG4gICAgY29udGV4dElkOiBgJHtiYXNlfS1jb250ZXh0LWlkYFxuICB9O1xufSkoKTtcbmNvbnN0IGRyYWdnYWJsZSA9ICgoKSA9PiB7XG4gIGNvbnN0IGJhc2UgPSBgJHtwcmVmaXh9LWRyYWdnYWJsZWA7XG4gIHJldHVybiB7XG4gICAgYmFzZSxcbiAgICBjb250ZXh0SWQ6IGAke2Jhc2V9LWNvbnRleHQtaWRgLFxuICAgIGlkOiBgJHtiYXNlfS1pZGBcbiAgfTtcbn0pKCk7XG5jb25zdCBkcm9wcGFibGUgPSAoKCkgPT4ge1xuICBjb25zdCBiYXNlID0gYCR7cHJlZml4fS1kcm9wcGFibGVgO1xuICByZXR1cm4ge1xuICAgIGJhc2UsXG4gICAgY29udGV4dElkOiBgJHtiYXNlfS1jb250ZXh0LWlkYCxcbiAgICBpZDogYCR7YmFzZX0taWRgXG4gIH07XG59KSgpO1xuY29uc3Qgc2Nyb2xsQ29udGFpbmVyID0ge1xuICBjb250ZXh0SWQ6IGAke3ByZWZpeH0tc2Nyb2xsLWNvbnRhaW5lci1jb250ZXh0LWlkYFxufTtcblxuY29uc3QgbWFrZUdldFNlbGVjdG9yID0gY29udGV4dCA9PiBhdHRyaWJ1dGUgPT4gYFske2F0dHJpYnV0ZX09XCIke2NvbnRleHR9XCJdYDtcbmNvbnN0IGdldFN0eWxlcyA9IChydWxlcywgcHJvcGVydHkpID0+IHJ1bGVzLm1hcChydWxlID0+IHtcbiAgY29uc3QgdmFsdWUgPSBydWxlLnN0eWxlc1twcm9wZXJ0eV07XG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgcmV0dXJuIGAke3J1bGUuc2VsZWN0b3J9IHsgJHt2YWx1ZX0gfWA7XG59KS5qb2luKCcgJyk7XG5jb25zdCBub1BvaW50ZXJFdmVudHMgPSAncG9pbnRlci1ldmVudHM6IG5vbmU7JztcbnZhciBnZXRTdHlsZXMkMSA9IChjb250ZXh0SWQgPT4ge1xuICBjb25zdCBnZXRTZWxlY3RvciA9IG1ha2VHZXRTZWxlY3Rvcihjb250ZXh0SWQpO1xuICBjb25zdCBkcmFnSGFuZGxlJDEgPSAoKCkgPT4ge1xuICAgIGNvbnN0IGdyYWJDdXJzb3IgPSBgXG4gICAgICBjdXJzb3I6IC13ZWJraXQtZ3JhYjtcbiAgICAgIGN1cnNvcjogZ3JhYjtcbiAgICBgO1xuICAgIHJldHVybiB7XG4gICAgICBzZWxlY3RvcjogZ2V0U2VsZWN0b3IoZHJhZ0hhbmRsZS5jb250ZXh0SWQpLFxuICAgICAgc3R5bGVzOiB7XG4gICAgICAgIGFsd2F5czogYFxuICAgICAgICAgIC13ZWJraXQtdG91Y2gtY2FsbG91dDogbm9uZTtcbiAgICAgICAgICAtd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3I6IHJnYmEoMCwwLDAsMCk7XG4gICAgICAgICAgdG91Y2gtYWN0aW9uOiBtYW5pcHVsYXRpb247XG4gICAgICAgIGAsXG4gICAgICAgIHJlc3Rpbmc6IGdyYWJDdXJzb3IsXG4gICAgICAgIGRyYWdnaW5nOiBub1BvaW50ZXJFdmVudHMsXG4gICAgICAgIGRyb3BBbmltYXRpbmc6IGdyYWJDdXJzb3JcbiAgICAgIH1cbiAgICB9O1xuICB9KSgpO1xuICBjb25zdCBkcmFnZ2FibGUkMSA9ICgoKSA9PiB7XG4gICAgY29uc3QgdHJhbnNpdGlvbiA9IGBcbiAgICAgIHRyYW5zaXRpb246ICR7dHJhbnNpdGlvbnMub3V0T2ZUaGVXYXl9O1xuICAgIGA7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNlbGVjdG9yOiBnZXRTZWxlY3RvcihkcmFnZ2FibGUuY29udGV4dElkKSxcbiAgICAgIHN0eWxlczoge1xuICAgICAgICBkcmFnZ2luZzogdHJhbnNpdGlvbixcbiAgICAgICAgZHJvcEFuaW1hdGluZzogdHJhbnNpdGlvbixcbiAgICAgICAgdXNlckNhbmNlbDogdHJhbnNpdGlvblxuICAgICAgfVxuICAgIH07XG4gIH0pKCk7XG4gIGNvbnN0IGRyb3BwYWJsZSQxID0ge1xuICAgIHNlbGVjdG9yOiBnZXRTZWxlY3Rvcihkcm9wcGFibGUuY29udGV4dElkKSxcbiAgICBzdHlsZXM6IHtcbiAgICAgIGFsd2F5czogYG92ZXJmbG93LWFuY2hvcjogbm9uZTtgXG4gICAgfVxuICB9O1xuICBjb25zdCBib2R5ID0ge1xuICAgIHNlbGVjdG9yOiAnYm9keScsXG4gICAgc3R5bGVzOiB7XG4gICAgICBkcmFnZ2luZzogYFxuICAgICAgICBjdXJzb3I6IGdyYWJiaW5nO1xuICAgICAgICBjdXJzb3I6IC13ZWJraXQtZ3JhYmJpbmc7XG4gICAgICAgIHVzZXItc2VsZWN0OiBub25lO1xuICAgICAgICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xuICAgICAgICAtbW96LXVzZXItc2VsZWN0OiBub25lO1xuICAgICAgICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgICAgIG92ZXJmbG93LWFuY2hvcjogbm9uZTtcbiAgICAgIGBcbiAgICB9XG4gIH07XG4gIGNvbnN0IHJ1bGVzID0gW2RyYWdnYWJsZSQxLCBkcmFnSGFuZGxlJDEsIGRyb3BwYWJsZSQxLCBib2R5XTtcbiAgcmV0dXJuIHtcbiAgICBhbHdheXM6IGdldFN0eWxlcyhydWxlcywgJ2Fsd2F5cycpLFxuICAgIHJlc3Rpbmc6IGdldFN0eWxlcyhydWxlcywgJ3Jlc3RpbmcnKSxcbiAgICBkcmFnZ2luZzogZ2V0U3R5bGVzKHJ1bGVzLCAnZHJhZ2dpbmcnKSxcbiAgICBkcm9wQW5pbWF0aW5nOiBnZXRTdHlsZXMocnVsZXMsICdkcm9wQW5pbWF0aW5nJyksXG4gICAgdXNlckNhbmNlbDogZ2V0U3R5bGVzKHJ1bGVzLCAndXNlckNhbmNlbCcpXG4gIH07XG59KTtcblxuY29uc3QgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgPyB1c2VMYXlvdXRFZmZlY3QkMSA6IHVzZUVmZmVjdDtcbnZhciB1c2VMYXlvdXRFZmZlY3QgPSB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0O1xuXG5jb25zdCBnZXRIZWFkID0gKCkgPT4ge1xuICBjb25zdCBoZWFkID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaGVhZCcpO1xuICAhaGVhZCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBmaW5kIHRoZSBoZWFkIHRvIGFwcGVuZCBhIHN0eWxlIHRvJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICByZXR1cm4gaGVhZDtcbn07XG5jb25zdCBjcmVhdGVTdHlsZUVsID0gbm9uY2UgPT4ge1xuICBjb25zdCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gIGlmIChub25jZSkge1xuICAgIGVsLnNldEF0dHJpYnV0ZSgnbm9uY2UnLCBub25jZSk7XG4gIH1cbiAgZWwudHlwZSA9ICd0ZXh0L2Nzcyc7XG4gIHJldHVybiBlbDtcbn07XG5mdW5jdGlvbiB1c2VTdHlsZU1hcnNoYWwoY29udGV4dElkLCBub25jZSkge1xuICBjb25zdCBzdHlsZXMgPSB1c2VNZW1vKCgpID0+IGdldFN0eWxlcyQxKGNvbnRleHRJZCksIFtjb250ZXh0SWRdKTtcbiAgY29uc3QgYWx3YXlzUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBkeW5hbWljUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBzZXREeW5hbWljU3R5bGUgPSB1c2VDYWxsYmFjayhtZW1vaXplT25lKHByb3Bvc2VkID0+IHtcbiAgICBjb25zdCBlbCA9IGR5bmFtaWNSZWYuY3VycmVudDtcbiAgICAhZWwgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3Qgc2V0IGR5bmFtaWMgc3R5bGUgZWxlbWVudCBpZiBpdCBpcyBub3Qgc2V0JykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIGVsLnRleHRDb250ZW50ID0gcHJvcG9zZWQ7XG4gIH0pLCBbXSk7XG4gIGNvbnN0IHNldEFsd2F5c1N0eWxlID0gdXNlQ2FsbGJhY2socHJvcG9zZWQgPT4ge1xuICAgIGNvbnN0IGVsID0gYWx3YXlzUmVmLmN1cnJlbnQ7XG4gICAgIWVsID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHNldCBkeW5hbWljIHN0eWxlIGVsZW1lbnQgaWYgaXQgaXMgbm90IHNldCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBlbC50ZXh0Q29udGVudCA9IHByb3Bvc2VkO1xuICB9LCBbXSk7XG4gIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgISghYWx3YXlzUmVmLmN1cnJlbnQgJiYgIWR5bmFtaWNSZWYuY3VycmVudCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdzdHlsZSBlbGVtZW50cyBhbHJlYWR5IG1vdW50ZWQnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgY29uc3QgYWx3YXlzID0gY3JlYXRlU3R5bGVFbChub25jZSk7XG4gICAgY29uc3QgZHluYW1pYyA9IGNyZWF0ZVN0eWxlRWwobm9uY2UpO1xuICAgIGFsd2F5c1JlZi5jdXJyZW50ID0gYWx3YXlzO1xuICAgIGR5bmFtaWNSZWYuY3VycmVudCA9IGR5bmFtaWM7XG4gICAgYWx3YXlzLnNldEF0dHJpYnV0ZShgJHtwcmVmaXh9LWFsd2F5c2AsIGNvbnRleHRJZCk7XG4gICAgZHluYW1pYy5zZXRBdHRyaWJ1dGUoYCR7cHJlZml4fS1keW5hbWljYCwgY29udGV4dElkKTtcbiAgICBnZXRIZWFkKCkuYXBwZW5kQ2hpbGQoYWx3YXlzKTtcbiAgICBnZXRIZWFkKCkuYXBwZW5kQ2hpbGQoZHluYW1pYyk7XG4gICAgc2V0QWx3YXlzU3R5bGUoc3R5bGVzLmFsd2F5cyk7XG4gICAgc2V0RHluYW1pY1N0eWxlKHN0eWxlcy5yZXN0aW5nKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY29uc3QgcmVtb3ZlID0gcmVmID0+IHtcbiAgICAgICAgY29uc3QgY3VycmVudCA9IHJlZi5jdXJyZW50O1xuICAgICAgICAhY3VycmVudCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCB1bm1vdW50IHJlZiBhcyBpdCBpcyBub3Qgc2V0JykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgICAgICBnZXRIZWFkKCkucmVtb3ZlQ2hpbGQoY3VycmVudCk7XG4gICAgICAgIHJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgIH07XG4gICAgICByZW1vdmUoYWx3YXlzUmVmKTtcbiAgICAgIHJlbW92ZShkeW5hbWljUmVmKTtcbiAgICB9O1xuICB9LCBbbm9uY2UsIHNldEFsd2F5c1N0eWxlLCBzZXREeW5hbWljU3R5bGUsIHN0eWxlcy5hbHdheXMsIHN0eWxlcy5yZXN0aW5nLCBjb250ZXh0SWRdKTtcbiAgY29uc3QgZHJhZ2dpbmcgPSB1c2VDYWxsYmFjaygoKSA9PiBzZXREeW5hbWljU3R5bGUoc3R5bGVzLmRyYWdnaW5nKSwgW3NldER5bmFtaWNTdHlsZSwgc3R5bGVzLmRyYWdnaW5nXSk7XG4gIGNvbnN0IGRyb3BwaW5nID0gdXNlQ2FsbGJhY2socmVhc29uID0+IHtcbiAgICBpZiAocmVhc29uID09PSAnRFJPUCcpIHtcbiAgICAgIHNldER5bmFtaWNTdHlsZShzdHlsZXMuZHJvcEFuaW1hdGluZyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNldER5bmFtaWNTdHlsZShzdHlsZXMudXNlckNhbmNlbCk7XG4gIH0sIFtzZXREeW5hbWljU3R5bGUsIHN0eWxlcy5kcm9wQW5pbWF0aW5nLCBzdHlsZXMudXNlckNhbmNlbF0pO1xuICBjb25zdCByZXN0aW5nID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmICghZHluYW1pY1JlZi5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNldER5bmFtaWNTdHlsZShzdHlsZXMucmVzdGluZyk7XG4gIH0sIFtzZXREeW5hbWljU3R5bGUsIHN0eWxlcy5yZXN0aW5nXSk7XG4gIGNvbnN0IG1hcnNoYWwgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgZHJhZ2dpbmcsXG4gICAgZHJvcHBpbmcsXG4gICAgcmVzdGluZ1xuICB9KSwgW2RyYWdnaW5nLCBkcm9wcGluZywgcmVzdGluZ10pO1xuICByZXR1cm4gbWFyc2hhbDtcbn1cblxuZnVuY3Rpb24gcXVlcnlTZWxlY3RvckFsbChwYXJlbnROb2RlLCBzZWxlY3Rvcikge1xuICByZXR1cm4gQXJyYXkuZnJvbShwYXJlbnROb2RlLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKTtcbn1cblxudmFyIGdldFdpbmRvd0Zyb21FbCA9IChlbCA9PiB7XG4gIGlmIChlbCAmJiBlbC5vd25lckRvY3VtZW50ICYmIGVsLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcpIHtcbiAgICByZXR1cm4gZWwub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcbiAgfVxuICByZXR1cm4gd2luZG93O1xufSk7XG5cbmZ1bmN0aW9uIGlzSHRtbEVsZW1lbnQoZWwpIHtcbiAgcmV0dXJuIGVsIGluc3RhbmNlb2YgZ2V0V2luZG93RnJvbUVsKGVsKS5IVE1MRWxlbWVudDtcbn1cblxuZnVuY3Rpb24gZmluZERyYWdIYW5kbGUoY29udGV4dElkLCBkcmFnZ2FibGVJZCkge1xuICBjb25zdCBzZWxlY3RvciA9IGBbJHtkcmFnSGFuZGxlLmNvbnRleHRJZH09XCIke2NvbnRleHRJZH1cIl1gO1xuICBjb25zdCBwb3NzaWJsZSA9IHF1ZXJ5U2VsZWN0b3JBbGwoZG9jdW1lbnQsIHNlbGVjdG9yKTtcbiAgaWYgKCFwb3NzaWJsZS5sZW5ndGgpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGBVbmFibGUgdG8gZmluZCBhbnkgZHJhZyBoYW5kbGVzIGluIHRoZSBjb250ZXh0IFwiJHtjb250ZXh0SWR9XCJgKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBoYW5kbGUgPSBwb3NzaWJsZS5maW5kKGVsID0+IHtcbiAgICByZXR1cm4gZWwuZ2V0QXR0cmlidXRlKGRyYWdIYW5kbGUuZHJhZ2dhYmxlSWQpID09PSBkcmFnZ2FibGVJZDtcbiAgfSk7XG4gIGlmICghaGFuZGxlKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhgVW5hYmxlIHRvIGZpbmQgZHJhZyBoYW5kbGUgd2l0aCBpZCBcIiR7ZHJhZ2dhYmxlSWR9XCIgYXMgbm8gaGFuZGxlIHdpdGggYSBtYXRjaGluZyBpZCB3YXMgZm91bmRgKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoIWlzSHRtbEVsZW1lbnQoaGFuZGxlKSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoJ2RyYWcgaGFuZGxlIG5lZWRzIHRvIGJlIGEgSFRNTEVsZW1lbnQnKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gaGFuZGxlO1xufVxuXG5mdW5jdGlvbiB1c2VGb2N1c01hcnNoYWwoY29udGV4dElkKSB7XG4gIGNvbnN0IGVudHJpZXNSZWYgPSB1c2VSZWYoe30pO1xuICBjb25zdCByZWNvcmRSZWYgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IHJlc3RvcmVGb2N1c0ZyYW1lUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBpc01vdW50ZWRSZWYgPSB1c2VSZWYoZmFsc2UpO1xuICBjb25zdCByZWdpc3RlciA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHJlZ2lzdGVyKGlkLCBmb2N1cykge1xuICAgIGNvbnN0IGVudHJ5ID0ge1xuICAgICAgaWQsXG4gICAgICBmb2N1c1xuICAgIH07XG4gICAgZW50cmllc1JlZi5jdXJyZW50W2lkXSA9IGVudHJ5O1xuICAgIHJldHVybiBmdW5jdGlvbiB1bnJlZ2lzdGVyKCkge1xuICAgICAgY29uc3QgZW50cmllcyA9IGVudHJpZXNSZWYuY3VycmVudDtcbiAgICAgIGNvbnN0IGN1cnJlbnQgPSBlbnRyaWVzW2lkXTtcbiAgICAgIGlmIChjdXJyZW50ICE9PSBlbnRyeSkge1xuICAgICAgICBkZWxldGUgZW50cmllc1tpZF07XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW10pO1xuICBjb25zdCB0cnlHaXZlRm9jdXMgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiB0cnlHaXZlRm9jdXModHJ5R2l2ZUZvY3VzVG8pIHtcbiAgICBjb25zdCBoYW5kbGUgPSBmaW5kRHJhZ0hhbmRsZShjb250ZXh0SWQsIHRyeUdpdmVGb2N1c1RvKTtcbiAgICBpZiAoaGFuZGxlICYmIGhhbmRsZSAhPT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkge1xuICAgICAgaGFuZGxlLmZvY3VzKCk7XG4gICAgfVxuICB9LCBbY29udGV4dElkXSk7XG4gIGNvbnN0IHRyeVNoaWZ0UmVjb3JkID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdHJ5U2hpZnRSZWNvcmQocHJldmlvdXMsIHJlZGlyZWN0VG8pIHtcbiAgICBpZiAocmVjb3JkUmVmLmN1cnJlbnQgPT09IHByZXZpb3VzKSB7XG4gICAgICByZWNvcmRSZWYuY3VycmVudCA9IHJlZGlyZWN0VG87XG4gICAgfVxuICB9LCBbXSk7XG4gIGNvbnN0IHRyeVJlc3RvcmVGb2N1c1JlY29yZGVkID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdHJ5UmVzdG9yZUZvY3VzUmVjb3JkZWQoKSB7XG4gICAgaWYgKHJlc3RvcmVGb2N1c0ZyYW1lUmVmLmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFpc01vdW50ZWRSZWYuY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXN0b3JlRm9jdXNGcmFtZVJlZi5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIHJlc3RvcmVGb2N1c0ZyYW1lUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgY29uc3QgcmVjb3JkID0gcmVjb3JkUmVmLmN1cnJlbnQ7XG4gICAgICBpZiAocmVjb3JkKSB7XG4gICAgICAgIHRyeUdpdmVGb2N1cyhyZWNvcmQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LCBbdHJ5R2l2ZUZvY3VzXSk7XG4gIGNvbnN0IHRyeVJlY29yZEZvY3VzID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdHJ5UmVjb3JkRm9jdXMoaWQpIHtcbiAgICByZWNvcmRSZWYuY3VycmVudCA9IG51bGw7XG4gICAgY29uc3QgZm9jdXNlZCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgaWYgKCFmb2N1c2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChmb2N1c2VkLmdldEF0dHJpYnV0ZShkcmFnSGFuZGxlLmRyYWdnYWJsZUlkKSAhPT0gaWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmVjb3JkUmVmLmN1cnJlbnQgPSBpZDtcbiAgfSwgW10pO1xuICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlzTW91bnRlZFJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICByZXR1cm4gZnVuY3Rpb24gY2xlYXJGcmFtZU9uVW5tb3VudCgpIHtcbiAgICAgIGlzTW91bnRlZFJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICBjb25zdCBmcmFtZUlkID0gcmVzdG9yZUZvY3VzRnJhbWVSZWYuY3VycmVudDtcbiAgICAgIGlmIChmcmFtZUlkKSB7XG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGZyYW1lSWQpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtdKTtcbiAgY29uc3QgbWFyc2hhbCA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICByZWdpc3RlcixcbiAgICB0cnlSZWNvcmRGb2N1cyxcbiAgICB0cnlSZXN0b3JlRm9jdXNSZWNvcmRlZCxcbiAgICB0cnlTaGlmdFJlY29yZFxuICB9KSwgW3JlZ2lzdGVyLCB0cnlSZWNvcmRGb2N1cywgdHJ5UmVzdG9yZUZvY3VzUmVjb3JkZWQsIHRyeVNoaWZ0UmVjb3JkXSk7XG4gIHJldHVybiBtYXJzaGFsO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVSZWdpc3RyeSgpIHtcbiAgY29uc3QgZW50cmllcyA9IHtcbiAgICBkcmFnZ2FibGVzOiB7fSxcbiAgICBkcm9wcGFibGVzOiB7fVxuICB9O1xuICBjb25zdCBzdWJzY3JpYmVycyA9IFtdO1xuICBmdW5jdGlvbiBzdWJzY3JpYmUoY2IpIHtcbiAgICBzdWJzY3JpYmVycy5wdXNoKGNiKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gdW5zdWJzY3JpYmUoKSB7XG4gICAgICBjb25zdCBpbmRleCA9IHN1YnNjcmliZXJzLmluZGV4T2YoY2IpO1xuICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzdWJzY3JpYmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gbm90aWZ5KGV2ZW50KSB7XG4gICAgaWYgKHN1YnNjcmliZXJzLmxlbmd0aCkge1xuICAgICAgc3Vic2NyaWJlcnMuZm9yRWFjaChjYiA9PiBjYihldmVudCkpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBmaW5kRHJhZ2dhYmxlQnlJZChpZCkge1xuICAgIHJldHVybiBlbnRyaWVzLmRyYWdnYWJsZXNbaWRdIHx8IG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0RHJhZ2dhYmxlQnlJZChpZCkge1xuICAgIGNvbnN0IGVudHJ5ID0gZmluZERyYWdnYWJsZUJ5SWQoaWQpO1xuICAgICFlbnRyeSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYENhbm5vdCBmaW5kIGRyYWdnYWJsZSBlbnRyeSB3aXRoIGlkIFske2lkfV1gKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgcmV0dXJuIGVudHJ5O1xuICB9XG4gIGNvbnN0IGRyYWdnYWJsZUFQSSA9IHtcbiAgICByZWdpc3RlcjogZW50cnkgPT4ge1xuICAgICAgZW50cmllcy5kcmFnZ2FibGVzW2VudHJ5LmRlc2NyaXB0b3IuaWRdID0gZW50cnk7XG4gICAgICBub3RpZnkoe1xuICAgICAgICB0eXBlOiAnQURESVRJT04nLFxuICAgICAgICB2YWx1ZTogZW50cnlcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgdXBkYXRlOiAoZW50cnksIGxhc3QpID0+IHtcbiAgICAgIGNvbnN0IGN1cnJlbnQgPSBlbnRyaWVzLmRyYWdnYWJsZXNbbGFzdC5kZXNjcmlwdG9yLmlkXTtcbiAgICAgIGlmICghY3VycmVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudC51bmlxdWVJZCAhPT0gZW50cnkudW5pcXVlSWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZGVsZXRlIGVudHJpZXMuZHJhZ2dhYmxlc1tsYXN0LmRlc2NyaXB0b3IuaWRdO1xuICAgICAgZW50cmllcy5kcmFnZ2FibGVzW2VudHJ5LmRlc2NyaXB0b3IuaWRdID0gZW50cnk7XG4gICAgfSxcbiAgICB1bnJlZ2lzdGVyOiBlbnRyeSA9PiB7XG4gICAgICBjb25zdCBkcmFnZ2FibGVJZCA9IGVudHJ5LmRlc2NyaXB0b3IuaWQ7XG4gICAgICBjb25zdCBjdXJyZW50ID0gZmluZERyYWdnYWJsZUJ5SWQoZHJhZ2dhYmxlSWQpO1xuICAgICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChlbnRyeS51bmlxdWVJZCAhPT0gY3VycmVudC51bmlxdWVJZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBkZWxldGUgZW50cmllcy5kcmFnZ2FibGVzW2RyYWdnYWJsZUlkXTtcbiAgICAgIGlmIChlbnRyaWVzLmRyb3BwYWJsZXNbZW50cnkuZGVzY3JpcHRvci5kcm9wcGFibGVJZF0pIHtcbiAgICAgICAgbm90aWZ5KHtcbiAgICAgICAgICB0eXBlOiAnUkVNT1ZBTCcsXG4gICAgICAgICAgdmFsdWU6IGVudHJ5XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0QnlJZDogZ2V0RHJhZ2dhYmxlQnlJZCxcbiAgICBmaW5kQnlJZDogZmluZERyYWdnYWJsZUJ5SWQsXG4gICAgZXhpc3RzOiBpZCA9PiBCb29sZWFuKGZpbmREcmFnZ2FibGVCeUlkKGlkKSksXG4gICAgZ2V0QWxsQnlUeXBlOiB0eXBlID0+IE9iamVjdC52YWx1ZXMoZW50cmllcy5kcmFnZ2FibGVzKS5maWx0ZXIoZW50cnkgPT4gZW50cnkuZGVzY3JpcHRvci50eXBlID09PSB0eXBlKVxuICB9O1xuICBmdW5jdGlvbiBmaW5kRHJvcHBhYmxlQnlJZChpZCkge1xuICAgIHJldHVybiBlbnRyaWVzLmRyb3BwYWJsZXNbaWRdIHx8IG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0RHJvcHBhYmxlQnlJZChpZCkge1xuICAgIGNvbnN0IGVudHJ5ID0gZmluZERyb3BwYWJsZUJ5SWQoaWQpO1xuICAgICFlbnRyeSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYENhbm5vdCBmaW5kIGRyb3BwYWJsZSBlbnRyeSB3aXRoIGlkIFske2lkfV1gKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgcmV0dXJuIGVudHJ5O1xuICB9XG4gIGNvbnN0IGRyb3BwYWJsZUFQSSA9IHtcbiAgICByZWdpc3RlcjogZW50cnkgPT4ge1xuICAgICAgZW50cmllcy5kcm9wcGFibGVzW2VudHJ5LmRlc2NyaXB0b3IuaWRdID0gZW50cnk7XG4gICAgfSxcbiAgICB1bnJlZ2lzdGVyOiBlbnRyeSA9PiB7XG4gICAgICBjb25zdCBjdXJyZW50ID0gZmluZERyb3BwYWJsZUJ5SWQoZW50cnkuZGVzY3JpcHRvci5pZCk7XG4gICAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGVudHJ5LnVuaXF1ZUlkICE9PSBjdXJyZW50LnVuaXF1ZUlkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSBlbnRyaWVzLmRyb3BwYWJsZXNbZW50cnkuZGVzY3JpcHRvci5pZF07XG4gICAgfSxcbiAgICBnZXRCeUlkOiBnZXREcm9wcGFibGVCeUlkLFxuICAgIGZpbmRCeUlkOiBmaW5kRHJvcHBhYmxlQnlJZCxcbiAgICBleGlzdHM6IGlkID0+IEJvb2xlYW4oZmluZERyb3BwYWJsZUJ5SWQoaWQpKSxcbiAgICBnZXRBbGxCeVR5cGU6IHR5cGUgPT4gT2JqZWN0LnZhbHVlcyhlbnRyaWVzLmRyb3BwYWJsZXMpLmZpbHRlcihlbnRyeSA9PiBlbnRyeS5kZXNjcmlwdG9yLnR5cGUgPT09IHR5cGUpXG4gIH07XG4gIGZ1bmN0aW9uIGNsZWFuKCkge1xuICAgIGVudHJpZXMuZHJhZ2dhYmxlcyA9IHt9O1xuICAgIGVudHJpZXMuZHJvcHBhYmxlcyA9IHt9O1xuICAgIHN1YnNjcmliZXJzLmxlbmd0aCA9IDA7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBkcmFnZ2FibGU6IGRyYWdnYWJsZUFQSSxcbiAgICBkcm9wcGFibGU6IGRyb3BwYWJsZUFQSSxcbiAgICBzdWJzY3JpYmUsXG4gICAgY2xlYW5cbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlUmVnaXN0cnkoKSB7XG4gIGNvbnN0IHJlZ2lzdHJ5ID0gdXNlTWVtbyhjcmVhdGVSZWdpc3RyeSwgW10pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiBmdW5jdGlvbiB1bm1vdW50KCkge1xuICAgICAgaWYgKFJlYWN0LnZlcnNpb24uc3RhcnRzV2l0aCgnMTYnKSB8fCBSZWFjdC52ZXJzaW9uLnN0YXJ0c1dpdGgoJzE3JykpIHtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJlZ2lzdHJ5LmNsZWFuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlZ2lzdHJ5LmNsZWFuKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW3JlZ2lzdHJ5XSk7XG4gIHJldHVybiByZWdpc3RyeTtcbn1cblxudmFyIFN0b3JlQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5cbnZhciBnZXRCb2R5RWxlbWVudCA9ICgoKSA9PiB7XG4gIGNvbnN0IGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuICAhYm9keSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBmaW5kIGRvY3VtZW50LmJvZHknKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIHJldHVybiBib2R5O1xufSk7XG5cbmNvbnN0IHZpc3VhbGx5SGlkZGVuID0ge1xuICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgd2lkdGg6ICcxcHgnLFxuICBoZWlnaHQ6ICcxcHgnLFxuICBtYXJnaW46ICctMXB4JyxcbiAgYm9yZGVyOiAnMCcsXG4gIHBhZGRpbmc6ICcwJyxcbiAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICBjbGlwOiAncmVjdCgwIDAgMCAwKScsXG4gICdjbGlwLXBhdGgnOiAnaW5zZXQoMTAwJSknXG59O1xudmFyIHZpc3VhbGx5SGlkZGVuJDEgPSB2aXN1YWxseUhpZGRlbjtcblxuY29uc3QgZ2V0SWQgPSBjb250ZXh0SWQgPT4gYHJmZC1hbm5vdW5jZW1lbnQtJHtjb250ZXh0SWR9YDtcbmZ1bmN0aW9uIHVzZUFubm91bmNlcihjb250ZXh0SWQpIHtcbiAgY29uc3QgaWQgPSB1c2VNZW1vKCgpID0+IGdldElkKGNvbnRleHRJZCksIFtjb250ZXh0SWRdKTtcbiAgY29uc3QgcmVmID0gdXNlUmVmKG51bGwpO1xuICB1c2VFZmZlY3QoZnVuY3Rpb24gc2V0dXAoKSB7XG4gICAgY29uc3QgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICByZWYuY3VycmVudCA9IGVsO1xuICAgIGVsLmlkID0gaWQ7XG4gICAgZWwuc2V0QXR0cmlidXRlKCdhcmlhLWxpdmUnLCAnYXNzZXJ0aXZlJyk7XG4gICAgZWwuc2V0QXR0cmlidXRlKCdhcmlhLWF0b21pYycsICd0cnVlJyk7XG4gICAgX2V4dGVuZHMoZWwuc3R5bGUsIHZpc3VhbGx5SGlkZGVuJDEpO1xuICAgIGdldEJvZHlFbGVtZW50KCkuYXBwZW5kQ2hpbGQoZWwpO1xuICAgIHJldHVybiBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICAgIGNvbnN0IGJvZHkgPSBnZXRCb2R5RWxlbWVudCgpO1xuICAgICAgICBpZiAoYm9keS5jb250YWlucyhlbCkpIHtcbiAgICAgICAgICBib2R5LnJlbW92ZUNoaWxkKGVsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWwgPT09IHJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgcmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICB9LCBbaWRdKTtcbiAgY29uc3QgYW5ub3VuY2UgPSB1c2VDYWxsYmFjayhtZXNzYWdlID0+IHtcbiAgICBjb25zdCBlbCA9IHJlZi5jdXJyZW50O1xuICAgIGlmIChlbCkge1xuICAgICAgZWwudGV4dENvbnRlbnQgPSBtZXNzYWdlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGBcbiAgICAgIEEgc2NyZWVuIHJlYWRlciBtZXNzYWdlIHdhcyB0cnlpbmcgdG8gYmUgYW5ub3VuY2VkIGJ1dCBpdCB3YXMgdW5hYmxlIHRvIGRvIHNvLlxuICAgICAgVGhpcyBjYW4gb2NjdXIgaWYgeW91IHVubW91bnQgeW91ciA8RHJhZ0Ryb3BDb250ZXh0IC8+IGluIHlvdXIgb25EcmFnRW5kLlxuICAgICAgQ29uc2lkZXIgY2FsbGluZyBwcm92aWRlZC5hbm5vdW5jZSgpIGJlZm9yZSB0aGUgdW5tb3VudCBzbyB0aGF0IHRoZSBpbnN0cnVjdGlvbiB3aWxsXG4gICAgICBub3QgYmUgbG9zdCBmb3IgdXNlcnMgcmVseWluZyBvbiBhIHNjcmVlbiByZWFkZXIuXG5cbiAgICAgIE1lc3NhZ2Ugbm90IHBhc3NlZCB0byBzY3JlZW4gcmVhZGVyOlxuXG4gICAgICBcIiR7bWVzc2FnZX1cIlxuICAgIGApIDogdm9pZCAwO1xuICB9LCBbXSk7XG4gIHJldHVybiBhbm5vdW5jZTtcbn1cblxubGV0IGNvdW50JDEgPSAwO1xuY29uc3QgZGVmYXVsdHMgPSB7XG4gIHNlcGFyYXRvcjogJzo6J1xufTtcbmZ1bmN0aW9uIHJlc2V0RGVwcmVjYXRlZFVuaXF1ZUlkKCkge1xuICBjb3VudCQxID0gMDtcbn1cbmZ1bmN0aW9uIHVzZURlcHJlY2F0ZWRVbmlxdWVJZChwcmVmaXgsIG9wdGlvbnMgPSBkZWZhdWx0cykge1xuICByZXR1cm4gdXNlTWVtbygoKSA9PiBgJHtwcmVmaXh9JHtvcHRpb25zLnNlcGFyYXRvcn0ke2NvdW50JDErK31gLCBbb3B0aW9ucy5zZXBhcmF0b3IsIHByZWZpeF0pO1xufVxuZnVuY3Rpb24gdXNlVW5pcXVlSWQocHJlZml4LCBvcHRpb25zID0gZGVmYXVsdHMpIHtcbiAgY29uc3QgaWQgPSBSZWFjdC51c2VJZCgpO1xuICByZXR1cm4gdXNlTWVtbygoKSA9PiBgJHtwcmVmaXh9JHtvcHRpb25zLnNlcGFyYXRvcn0ke2lkfWAsIFtvcHRpb25zLnNlcGFyYXRvciwgcHJlZml4LCBpZF0pO1xufVxudmFyIHVzZVVuaXF1ZUlkJDEgPSAndXNlSWQnIGluIFJlYWN0ID8gdXNlVW5pcXVlSWQgOiB1c2VEZXByZWNhdGVkVW5pcXVlSWQ7XG5cbmZ1bmN0aW9uIGdldEVsZW1lbnRJZCh7XG4gIGNvbnRleHRJZCxcbiAgdW5pcXVlSWRcbn0pIHtcbiAgcmV0dXJuIGByZmQtaGlkZGVuLXRleHQtJHtjb250ZXh0SWR9LSR7dW5pcXVlSWR9YDtcbn1cbmZ1bmN0aW9uIHVzZUhpZGRlblRleHRFbGVtZW50KHtcbiAgY29udGV4dElkLFxuICB0ZXh0XG59KSB7XG4gIGNvbnN0IHVuaXF1ZUlkID0gdXNlVW5pcXVlSWQkMSgnaGlkZGVuLXRleHQnLCB7XG4gICAgc2VwYXJhdG9yOiAnLSdcbiAgfSk7XG4gIGNvbnN0IGlkID0gdXNlTWVtbygoKSA9PiBnZXRFbGVtZW50SWQoe1xuICAgIGNvbnRleHRJZCxcbiAgICB1bmlxdWVJZFxuICB9KSwgW3VuaXF1ZUlkLCBjb250ZXh0SWRdKTtcbiAgdXNlRWZmZWN0KGZ1bmN0aW9uIG1vdW50KCkge1xuICAgIGNvbnN0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZWwuaWQgPSBpZDtcbiAgICBlbC50ZXh0Q29udGVudCA9IHRleHQ7XG4gICAgZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICBnZXRCb2R5RWxlbWVudCgpLmFwcGVuZENoaWxkKGVsKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gdW5tb3VudCgpIHtcbiAgICAgIGNvbnN0IGJvZHkgPSBnZXRCb2R5RWxlbWVudCgpO1xuICAgICAgaWYgKGJvZHkuY29udGFpbnMoZWwpKSB7XG4gICAgICAgIGJvZHkucmVtb3ZlQ2hpbGQoZWwpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtpZCwgdGV4dF0pO1xuICByZXR1cm4gaWQ7XG59XG5cbnZhciBBcHBDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcblxudmFyIHBlZXJEZXBlbmRlbmNpZXMgPSB7XG5cdHJlYWN0OiBcIl4xNi44LjUgfHwgXjE3LjAuMCB8fCBeMTguMC4wXCIsXG5cdFwicmVhY3QtZG9tXCI6IFwiXjE2LjguNSB8fCBeMTcuMC4wIHx8IF4xOC4wLjBcIlxufTtcblxuY29uc3Qgc2VtdmVyID0gLyhcXGQrKVxcLihcXGQrKVxcLihcXGQrKS87XG5jb25zdCBnZXRWZXJzaW9uID0gdmFsdWUgPT4ge1xuICBjb25zdCByZXN1bHQgPSBzZW12ZXIuZXhlYyh2YWx1ZSk7XG4gICEocmVzdWx0ICE9IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBgVW5hYmxlIHRvIHBhcnNlIFJlYWN0IHZlcnNpb24gJHt2YWx1ZX1gKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIGNvbnN0IG1ham9yID0gTnVtYmVyKHJlc3VsdFsxXSk7XG4gIGNvbnN0IG1pbm9yID0gTnVtYmVyKHJlc3VsdFsyXSk7XG4gIGNvbnN0IHBhdGNoID0gTnVtYmVyKHJlc3VsdFszXSk7XG4gIHJldHVybiB7XG4gICAgbWFqb3IsXG4gICAgbWlub3IsXG4gICAgcGF0Y2gsXG4gICAgcmF3OiB2YWx1ZVxuICB9O1xufTtcbmNvbnN0IGlzU2F0aXNmaWVkID0gKGV4cGVjdGVkLCBhY3R1YWwpID0+IHtcbiAgaWYgKGFjdHVhbC5tYWpvciA+IGV4cGVjdGVkLm1ham9yKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGFjdHVhbC5tYWpvciA8IGV4cGVjdGVkLm1ham9yKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChhY3R1YWwubWlub3IgPiBleHBlY3RlZC5taW5vcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChhY3R1YWwubWlub3IgPCBleHBlY3RlZC5taW5vcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gYWN0dWFsLnBhdGNoID49IGV4cGVjdGVkLnBhdGNoO1xufTtcbnZhciBjaGVja1JlYWN0VmVyc2lvbiA9ICgocGVlckRlcFZhbHVlLCBhY3R1YWxWYWx1ZSkgPT4ge1xuICBjb25zdCBwZWVyRGVwID0gZ2V0VmVyc2lvbihwZWVyRGVwVmFsdWUpO1xuICBjb25zdCBhY3R1YWwgPSBnZXRWZXJzaW9uKGFjdHVhbFZhbHVlKTtcbiAgaWYgKGlzU2F0aXNmaWVkKHBlZXJEZXAsIGFjdHVhbCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhgXG4gICAgUmVhY3QgdmVyc2lvbjogWyR7YWN0dWFsLnJhd31dXG4gICAgZG9lcyBub3Qgc2F0aXNmeSBleHBlY3RlZCBwZWVyIGRlcGVuZGVuY3kgdmVyc2lvbjogWyR7cGVlckRlcC5yYXd9XVxuXG4gICAgVGhpcyBjYW4gcmVzdWx0IGluIHJ1biB0aW1lIGJ1Z3MsIGFuZCBldmVuIGZhdGFsIGNyYXNoZXNcbiAgYCkgOiB2b2lkIDA7XG59KTtcblxuY29uc3Qgc3VmZml4ID0gYFxuICBXZSBleHBlY3QgYSBodG1sNSBkb2N0eXBlOiA8IWRvY3R5cGUgaHRtbD5cbiAgVGhpcyBpcyB0byBlbnN1cmUgY29uc2lzdGVudCBicm93c2VyIGxheW91dCBhbmQgbWVhc3VyZW1lbnRcblxuICBNb3JlIGluZm9ybWF0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vaGVsbG8tcGFuZ2VhL2RuZC9ibG9iL21haW4vZG9jcy9ndWlkZXMvZG9jdHlwZS5tZFxuYDtcbnZhciBjaGVja0RvY3R5cGUgPSAoZG9jID0+IHtcbiAgY29uc3QgZG9jdHlwZSA9IGRvYy5kb2N0eXBlO1xuICBpZiAoIWRvY3R5cGUpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGBcbiAgICAgIE5vIDwhZG9jdHlwZSBodG1sPiBmb3VuZC5cblxuICAgICAgJHtzdWZmaXh9XG4gICAgYCkgOiB2b2lkIDA7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChkb2N0eXBlLm5hbWUudG9Mb3dlckNhc2UoKSAhPT0gJ2h0bWwnKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhgXG4gICAgICBVbmV4cGVjdGVkIDwhZG9jdHlwZT4gZm91bmQ6ICgke2RvY3R5cGUubmFtZX0pXG5cbiAgICAgICR7c3VmZml4fVxuICAgIGApIDogdm9pZCAwO1xuICB9XG4gIGlmIChkb2N0eXBlLnB1YmxpY0lkICE9PSAnJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoYFxuICAgICAgVW5leHBlY3RlZCA8IWRvY3R5cGU+IHB1YmxpY0lkIGZvdW5kOiAoJHtkb2N0eXBlLnB1YmxpY0lkfSlcbiAgICAgIEEgaHRtbDUgZG9jdHlwZSBkb2VzIG5vdCBoYXZlIGEgcHVibGljSWRcblxuICAgICAgJHtzdWZmaXh9XG4gICAgYCkgOiB2b2lkIDA7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiB1c2VEZXYodXNlSG9vaykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHVzZUhvb2soKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1c2VEZXZTZXR1cFdhcm5pbmcoZm4sIGlucHV0cykge1xuICB1c2VEZXYoKCkgPT4ge1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBmbigpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBlcnJvcihgXG4gICAgICAgICAgQSBzZXR1cCBwcm9ibGVtIHdhcyBlbmNvdW50ZXJlZC5cblxuICAgICAgICAgID4gJHtlLm1lc3NhZ2V9XG4gICAgICAgIGApO1xuICAgICAgfVxuICAgIH0sIGlucHV0cyk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB1c2VTdGFydHVwVmFsaWRhdGlvbigpIHtcbiAgdXNlRGV2U2V0dXBXYXJuaW5nKCgpID0+IHtcbiAgICBjaGVja1JlYWN0VmVyc2lvbihwZWVyRGVwZW5kZW5jaWVzLnJlYWN0LCBSZWFjdC52ZXJzaW9uKTtcbiAgICBjaGVja0RvY3R5cGUoZG9jdW1lbnQpO1xuICB9LCBbXSk7XG59XG5cbmZ1bmN0aW9uIHVzZVByZXZpb3VzKGN1cnJlbnQpIHtcbiAgY29uc3QgcmVmID0gdXNlUmVmKGN1cnJlbnQpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJlZi5jdXJyZW50ID0gY3VycmVudDtcbiAgfSk7XG4gIHJldHVybiByZWY7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgbGV0IGxvY2sgPSBudWxsO1xuICBmdW5jdGlvbiBpc0NsYWltZWQoKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4obG9jayk7XG4gIH1cbiAgZnVuY3Rpb24gaXNBY3RpdmUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IGxvY2s7XG4gIH1cbiAgZnVuY3Rpb24gY2xhaW0oYWJhbmRvbikge1xuICAgICEhbG9jayA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBjbGFpbSBsb2NrIGFzIGl0IGlzIGFscmVhZHkgY2xhaW1lZCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBjb25zdCBuZXdMb2NrID0ge1xuICAgICAgYWJhbmRvblxuICAgIH07XG4gICAgbG9jayA9IG5ld0xvY2s7XG4gICAgcmV0dXJuIG5ld0xvY2s7XG4gIH1cbiAgZnVuY3Rpb24gcmVsZWFzZSgpIHtcbiAgICAhbG9jayA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCByZWxlYXNlIGxvY2sgd2hlbiB0aGVyZSBpcyBubyBsb2NrJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIGxvY2sgPSBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIHRyeUFiYW5kb24oKSB7XG4gICAgaWYgKGxvY2spIHtcbiAgICAgIGxvY2suYWJhbmRvbigpO1xuICAgICAgcmVsZWFzZSgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIGlzQ2xhaW1lZCxcbiAgICBpc0FjdGl2ZSxcbiAgICBjbGFpbSxcbiAgICByZWxlYXNlLFxuICAgIHRyeUFiYW5kb25cbiAgfTtcbn1cblxuZnVuY3Rpb24gaXNEcmFnZ2luZyhzdGF0ZSkge1xuICBpZiAoc3RhdGUucGhhc2UgPT09ICdJRExFJyB8fCBzdGF0ZS5waGFzZSA9PT0gJ0RST1BfQU5JTUFUSU5HJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gc3RhdGUuaXNEcmFnZ2luZztcbn1cblxuY29uc3QgdGFiID0gOTtcbmNvbnN0IGVudGVyID0gMTM7XG5jb25zdCBlc2NhcGUgPSAyNztcbmNvbnN0IHNwYWNlID0gMzI7XG5jb25zdCBwYWdlVXAgPSAzMztcbmNvbnN0IHBhZ2VEb3duID0gMzQ7XG5jb25zdCBlbmQgPSAzNTtcbmNvbnN0IGhvbWUgPSAzNjtcbmNvbnN0IGFycm93TGVmdCA9IDM3O1xuY29uc3QgYXJyb3dVcCA9IDM4O1xuY29uc3QgYXJyb3dSaWdodCA9IDM5O1xuY29uc3QgYXJyb3dEb3duID0gNDA7XG5cbmNvbnN0IHByZXZlbnRlZEtleXMgPSB7XG4gIFtlbnRlcl06IHRydWUsXG4gIFt0YWJdOiB0cnVlXG59O1xudmFyIHByZXZlbnRTdGFuZGFyZEtleUV2ZW50cyA9IChldmVudCA9PiB7XG4gIGlmIChwcmV2ZW50ZWRLZXlzW2V2ZW50LmtleUNvZGVdKSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfVxufSk7XG5cbmNvbnN0IHN1cHBvcnRlZEV2ZW50TmFtZSA9ICgoKSA9PiB7XG4gIGNvbnN0IGJhc2UgPSAndmlzaWJpbGl0eWNoYW5nZSc7XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGJhc2U7XG4gIH1cbiAgY29uc3QgY2FuZGlkYXRlcyA9IFtiYXNlLCBgbXMke2Jhc2V9YCwgYHdlYmtpdCR7YmFzZX1gLCBgbW96JHtiYXNlfWAsIGBvJHtiYXNlfWBdO1xuICBjb25zdCBzdXBwb3J0ZWQgPSBjYW5kaWRhdGVzLmZpbmQoZXZlbnROYW1lID0+IGBvbiR7ZXZlbnROYW1lfWAgaW4gZG9jdW1lbnQpO1xuICByZXR1cm4gc3VwcG9ydGVkIHx8IGJhc2U7XG59KSgpO1xudmFyIHN1cHBvcnRlZFBhZ2VWaXNpYmlsaXR5RXZlbnROYW1lID0gc3VwcG9ydGVkRXZlbnROYW1lO1xuXG5jb25zdCBwcmltYXJ5QnV0dG9uID0gMDtcbmNvbnN0IHNsb3BweUNsaWNrVGhyZXNob2xkID0gNTtcbmZ1bmN0aW9uIGlzU2xvcHB5Q2xpY2tUaHJlc2hvbGRFeGNlZWRlZChvcmlnaW5hbCwgY3VycmVudCkge1xuICByZXR1cm4gTWF0aC5hYnMoY3VycmVudC54IC0gb3JpZ2luYWwueCkgPj0gc2xvcHB5Q2xpY2tUaHJlc2hvbGQgfHwgTWF0aC5hYnMoY3VycmVudC55IC0gb3JpZ2luYWwueSkgPj0gc2xvcHB5Q2xpY2tUaHJlc2hvbGQ7XG59XG5jb25zdCBpZGxlJDEgPSB7XG4gIHR5cGU6ICdJRExFJ1xufTtcbmZ1bmN0aW9uIGdldENhcHR1cmVCaW5kaW5ncyh7XG4gIGNhbmNlbCxcbiAgY29tcGxldGVkLFxuICBnZXRQaGFzZSxcbiAgc2V0UGhhc2Vcbn0pIHtcbiAgcmV0dXJuIFt7XG4gICAgZXZlbnROYW1lOiAnbW91c2Vtb3ZlJyxcbiAgICBmbjogZXZlbnQgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBidXR0b24sXG4gICAgICAgIGNsaWVudFgsXG4gICAgICAgIGNsaWVudFlcbiAgICAgIH0gPSBldmVudDtcbiAgICAgIGlmIChidXR0b24gIT09IHByaW1hcnlCdXR0b24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcG9pbnQgPSB7XG4gICAgICAgIHg6IGNsaWVudFgsXG4gICAgICAgIHk6IGNsaWVudFlcbiAgICAgIH07XG4gICAgICBjb25zdCBwaGFzZSA9IGdldFBoYXNlKCk7XG4gICAgICBpZiAocGhhc2UudHlwZSA9PT0gJ0RSQUdHSU5HJykge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBwaGFzZS5hY3Rpb25zLm1vdmUocG9pbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAhKHBoYXNlLnR5cGUgPT09ICdQRU5ESU5HJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgYmUgSURMRScpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAgIGNvbnN0IHBlbmRpbmcgPSBwaGFzZS5wb2ludDtcbiAgICAgIGlmICghaXNTbG9wcHlDbGlja1RocmVzaG9sZEV4Y2VlZGVkKHBlbmRpbmcsIHBvaW50KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgY29uc3QgYWN0aW9ucyA9IHBoYXNlLmFjdGlvbnMuZmx1aWRMaWZ0KHBvaW50KTtcbiAgICAgIHNldFBoYXNlKHtcbiAgICAgICAgdHlwZTogJ0RSQUdHSU5HJyxcbiAgICAgICAgYWN0aW9uc1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAgZXZlbnROYW1lOiAnbW91c2V1cCcsXG4gICAgZm46IGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IHBoYXNlID0gZ2V0UGhhc2UoKTtcbiAgICAgIGlmIChwaGFzZS50eXBlICE9PSAnRFJBR0dJTkcnKSB7XG4gICAgICAgIGNhbmNlbCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgcGhhc2UuYWN0aW9ucy5kcm9wKHtcbiAgICAgICAgc2hvdWxkQmxvY2tOZXh0Q2xpY2s6IHRydWVcbiAgICAgIH0pO1xuICAgICAgY29tcGxldGVkKCk7XG4gICAgfVxuICB9LCB7XG4gICAgZXZlbnROYW1lOiAnbW91c2Vkb3duJyxcbiAgICBmbjogZXZlbnQgPT4ge1xuICAgICAgaWYgKGdldFBoYXNlKCkudHlwZSA9PT0gJ0RSQUdHSU5HJykge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgICAgY2FuY2VsKCk7XG4gICAgfVxuICB9LCB7XG4gICAgZXZlbnROYW1lOiAna2V5ZG93bicsXG4gICAgZm46IGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IHBoYXNlID0gZ2V0UGhhc2UoKTtcbiAgICAgIGlmIChwaGFzZS50eXBlID09PSAnUEVORElORycpIHtcbiAgICAgICAgY2FuY2VsKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSBlc2NhcGUpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgY2FuY2VsKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHByZXZlbnRTdGFuZGFyZEtleUV2ZW50cyhldmVudCk7XG4gICAgfVxuICB9LCB7XG4gICAgZXZlbnROYW1lOiAncmVzaXplJyxcbiAgICBmbjogY2FuY2VsXG4gIH0sIHtcbiAgICBldmVudE5hbWU6ICdzY3JvbGwnLFxuICAgIG9wdGlvbnM6IHtcbiAgICAgIHBhc3NpdmU6IHRydWUsXG4gICAgICBjYXB0dXJlOiBmYWxzZVxuICAgIH0sXG4gICAgZm46ICgpID0+IHtcbiAgICAgIGlmIChnZXRQaGFzZSgpLnR5cGUgPT09ICdQRU5ESU5HJykge1xuICAgICAgICBjYW5jZWwoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBldmVudE5hbWU6ICd3ZWJraXRtb3VzZWZvcmNlZG93bicsXG4gICAgZm46IGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IHBoYXNlID0gZ2V0UGhhc2UoKTtcbiAgICAgICEocGhhc2UudHlwZSAhPT0gJ0lETEUnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ1VuZXhwZWN0ZWQgcGhhc2UnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgICBpZiAocGhhc2UuYWN0aW9ucy5zaG91bGRSZXNwZWN0Rm9yY2VQcmVzcygpKSB7XG4gICAgICAgIGNhbmNlbCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGV2ZW50TmFtZTogc3VwcG9ydGVkUGFnZVZpc2liaWxpdHlFdmVudE5hbWUsXG4gICAgZm46IGNhbmNlbFxuICB9XTtcbn1cbmZ1bmN0aW9uIHVzZU1vdXNlU2Vuc29yKGFwaSkge1xuICBjb25zdCBwaGFzZVJlZiA9IHVzZVJlZihpZGxlJDEpO1xuICBjb25zdCB1bmJpbmRFdmVudHNSZWYgPSB1c2VSZWYobm9vcCQyKTtcbiAgY29uc3Qgc3RhcnRDYXB0dXJlQmluZGluZyA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICBldmVudE5hbWU6ICdtb3VzZWRvd24nLFxuICAgIGZuOiBmdW5jdGlvbiBvbk1vdXNlRG93bihldmVudCkge1xuICAgICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gcHJpbWFyeUJ1dHRvbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5IHx8IGV2ZW50LnNoaWZ0S2V5IHx8IGV2ZW50LmFsdEtleSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBkcmFnZ2FibGVJZCA9IGFwaS5maW5kQ2xvc2VzdERyYWdnYWJsZUlkKGV2ZW50KTtcbiAgICAgIGlmICghZHJhZ2dhYmxlSWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgYWN0aW9ucyA9IGFwaS50cnlHZXRMb2NrKGRyYWdnYWJsZUlkLCBzdG9wLCB7XG4gICAgICAgIHNvdXJjZUV2ZW50OiBldmVudFxuICAgICAgfSk7XG4gICAgICBpZiAoIWFjdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGNvbnN0IHBvaW50ID0ge1xuICAgICAgICB4OiBldmVudC5jbGllbnRYLFxuICAgICAgICB5OiBldmVudC5jbGllbnRZXG4gICAgICB9O1xuICAgICAgdW5iaW5kRXZlbnRzUmVmLmN1cnJlbnQoKTtcbiAgICAgIHN0YXJ0UGVuZGluZ0RyYWcoYWN0aW9ucywgcG9pbnQpO1xuICAgIH1cbiAgfSksIFthcGldKTtcbiAgY29uc3QgcHJldmVudEZvcmNlUHJlc3NCaW5kaW5nID0gdXNlTWVtbygoKSA9PiAoe1xuICAgIGV2ZW50TmFtZTogJ3dlYmtpdG1vdXNlZm9yY2V3aWxsYmVnaW4nLFxuICAgIGZuOiBldmVudCA9PiB7XG4gICAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBpZCA9IGFwaS5maW5kQ2xvc2VzdERyYWdnYWJsZUlkKGV2ZW50KTtcbiAgICAgIGlmICghaWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3B0aW9ucyA9IGFwaS5maW5kT3B0aW9uc0ZvckRyYWdnYWJsZShpZCk7XG4gICAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuc2hvdWxkUmVzcGVjdEZvcmNlUHJlc3MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFhcGkuY2FuR2V0TG9jayhpZCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH0pLCBbYXBpXSk7XG4gIGNvbnN0IGxpc3RlbkZvckNhcHR1cmUgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiBsaXN0ZW5Gb3JDYXB0dXJlKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICAgIGNhcHR1cmU6IHRydWVcbiAgICB9O1xuICAgIHVuYmluZEV2ZW50c1JlZi5jdXJyZW50ID0gYmluZEV2ZW50cyh3aW5kb3csIFtwcmV2ZW50Rm9yY2VQcmVzc0JpbmRpbmcsIHN0YXJ0Q2FwdHVyZUJpbmRpbmddLCBvcHRpb25zKTtcbiAgfSwgW3ByZXZlbnRGb3JjZVByZXNzQmluZGluZywgc3RhcnRDYXB0dXJlQmluZGluZ10pO1xuICBjb25zdCBzdG9wID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGNvbnN0IGN1cnJlbnQgPSBwaGFzZVJlZi5jdXJyZW50O1xuICAgIGlmIChjdXJyZW50LnR5cGUgPT09ICdJRExFJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBwaGFzZVJlZi5jdXJyZW50ID0gaWRsZSQxO1xuICAgIHVuYmluZEV2ZW50c1JlZi5jdXJyZW50KCk7XG4gICAgbGlzdGVuRm9yQ2FwdHVyZSgpO1xuICB9LCBbbGlzdGVuRm9yQ2FwdHVyZV0pO1xuICBjb25zdCBjYW5jZWwgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgY29uc3QgcGhhc2UgPSBwaGFzZVJlZi5jdXJyZW50O1xuICAgIHN0b3AoKTtcbiAgICBpZiAocGhhc2UudHlwZSA9PT0gJ0RSQUdHSU5HJykge1xuICAgICAgcGhhc2UuYWN0aW9ucy5jYW5jZWwoe1xuICAgICAgICBzaG91bGRCbG9ja05leHRDbGljazogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChwaGFzZS50eXBlID09PSAnUEVORElORycpIHtcbiAgICAgIHBoYXNlLmFjdGlvbnMuYWJvcnQoKTtcbiAgICB9XG4gIH0sIFtzdG9wXSk7XG4gIGNvbnN0IGJpbmRDYXB0dXJpbmdFdmVudHMgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiBiaW5kQ2FwdHVyaW5nRXZlbnRzKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICB9O1xuICAgIGNvbnN0IGJpbmRpbmdzID0gZ2V0Q2FwdHVyZUJpbmRpbmdzKHtcbiAgICAgIGNhbmNlbCxcbiAgICAgIGNvbXBsZXRlZDogc3RvcCxcbiAgICAgIGdldFBoYXNlOiAoKSA9PiBwaGFzZVJlZi5jdXJyZW50LFxuICAgICAgc2V0UGhhc2U6IHBoYXNlID0+IHtcbiAgICAgICAgcGhhc2VSZWYuY3VycmVudCA9IHBoYXNlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHVuYmluZEV2ZW50c1JlZi5jdXJyZW50ID0gYmluZEV2ZW50cyh3aW5kb3csIGJpbmRpbmdzLCBvcHRpb25zKTtcbiAgfSwgW2NhbmNlbCwgc3RvcF0pO1xuICBjb25zdCBzdGFydFBlbmRpbmdEcmFnID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gc3RhcnRQZW5kaW5nRHJhZyhhY3Rpb25zLCBwb2ludCkge1xuICAgICEocGhhc2VSZWYuY3VycmVudC50eXBlID09PSAnSURMRScpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgdG8gbW92ZSBmcm9tIElETEUgdG8gUEVORElORyBkcmFnJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIHBoYXNlUmVmLmN1cnJlbnQgPSB7XG4gICAgICB0eXBlOiAnUEVORElORycsXG4gICAgICBwb2ludCxcbiAgICAgIGFjdGlvbnNcbiAgICB9O1xuICAgIGJpbmRDYXB0dXJpbmdFdmVudHMoKTtcbiAgfSwgW2JpbmRDYXB0dXJpbmdFdmVudHNdKTtcbiAgdXNlTGF5b3V0RWZmZWN0KGZ1bmN0aW9uIG1vdW50KCkge1xuICAgIGxpc3RlbkZvckNhcHR1cmUoKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gdW5tb3VudCgpIHtcbiAgICAgIHVuYmluZEV2ZW50c1JlZi5jdXJyZW50KCk7XG4gICAgfTtcbiAgfSwgW2xpc3RlbkZvckNhcHR1cmVdKTtcbn1cblxuZnVuY3Rpb24gbm9vcCQxKCkge31cbmNvbnN0IHNjcm9sbEp1bXBLZXlzID0ge1xuICBbcGFnZURvd25dOiB0cnVlLFxuICBbcGFnZVVwXTogdHJ1ZSxcbiAgW2hvbWVdOiB0cnVlLFxuICBbZW5kXTogdHJ1ZVxufTtcbmZ1bmN0aW9uIGdldERyYWdnaW5nQmluZGluZ3MoYWN0aW9ucywgc3RvcCkge1xuICBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgc3RvcCgpO1xuICAgIGFjdGlvbnMuY2FuY2VsKCk7XG4gIH1cbiAgZnVuY3Rpb24gZHJvcCgpIHtcbiAgICBzdG9wKCk7XG4gICAgYWN0aW9ucy5kcm9wKCk7XG4gIH1cbiAgcmV0dXJuIFt7XG4gICAgZXZlbnROYW1lOiAna2V5ZG93bicsXG4gICAgZm46IGV2ZW50ID0+IHtcbiAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSBlc2NhcGUpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgY2FuY2VsKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSBzcGFjZSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBkcm9wKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSBhcnJvd0Rvd24pIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgYWN0aW9ucy5tb3ZlRG93bigpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gYXJyb3dVcCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBhY3Rpb25zLm1vdmVVcCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gYXJyb3dSaWdodCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBhY3Rpb25zLm1vdmVSaWdodCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gYXJyb3dMZWZ0KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGFjdGlvbnMubW92ZUxlZnQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHNjcm9sbEp1bXBLZXlzW2V2ZW50LmtleUNvZGVdKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHByZXZlbnRTdGFuZGFyZEtleUV2ZW50cyhldmVudCk7XG4gICAgfVxuICB9LCB7XG4gICAgZXZlbnROYW1lOiAnbW91c2Vkb3duJyxcbiAgICBmbjogY2FuY2VsXG4gIH0sIHtcbiAgICBldmVudE5hbWU6ICdtb3VzZXVwJyxcbiAgICBmbjogY2FuY2VsXG4gIH0sIHtcbiAgICBldmVudE5hbWU6ICdjbGljaycsXG4gICAgZm46IGNhbmNlbFxuICB9LCB7XG4gICAgZXZlbnROYW1lOiAndG91Y2hzdGFydCcsXG4gICAgZm46IGNhbmNlbFxuICB9LCB7XG4gICAgZXZlbnROYW1lOiAncmVzaXplJyxcbiAgICBmbjogY2FuY2VsXG4gIH0sIHtcbiAgICBldmVudE5hbWU6ICd3aGVlbCcsXG4gICAgZm46IGNhbmNlbCxcbiAgICBvcHRpb25zOiB7XG4gICAgICBwYXNzaXZlOiB0cnVlXG4gICAgfVxuICB9LCB7XG4gICAgZXZlbnROYW1lOiBzdXBwb3J0ZWRQYWdlVmlzaWJpbGl0eUV2ZW50TmFtZSxcbiAgICBmbjogY2FuY2VsXG4gIH1dO1xufVxuZnVuY3Rpb24gdXNlS2V5Ym9hcmRTZW5zb3IoYXBpKSB7XG4gIGNvbnN0IHVuYmluZEV2ZW50c1JlZiA9IHVzZVJlZihub29wJDEpO1xuICBjb25zdCBzdGFydENhcHR1cmVCaW5kaW5nID0gdXNlTWVtbygoKSA9PiAoe1xuICAgIGV2ZW50TmFtZTogJ2tleWRvd24nLFxuICAgIGZuOiBmdW5jdGlvbiBvbktleURvd24oZXZlbnQpIHtcbiAgICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChldmVudC5rZXlDb2RlICE9PSBzcGFjZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBkcmFnZ2FibGVJZCA9IGFwaS5maW5kQ2xvc2VzdERyYWdnYWJsZUlkKGV2ZW50KTtcbiAgICAgIGlmICghZHJhZ2dhYmxlSWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcHJlRHJhZyA9IGFwaS50cnlHZXRMb2NrKGRyYWdnYWJsZUlkLCBzdG9wLCB7XG4gICAgICAgIHNvdXJjZUV2ZW50OiBldmVudFxuICAgICAgfSk7XG4gICAgICBpZiAoIXByZURyYWcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGxldCBpc0NhcHR1cmluZyA9IHRydWU7XG4gICAgICBjb25zdCBhY3Rpb25zID0gcHJlRHJhZy5zbmFwTGlmdCgpO1xuICAgICAgdW5iaW5kRXZlbnRzUmVmLmN1cnJlbnQoKTtcbiAgICAgIGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgICAgICFpc0NhcHR1cmluZyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBzdG9wIGNhcHR1cmluZyBhIGtleWJvYXJkIGRyYWcgd2hlbiBub3QgY2FwdHVyaW5nJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgICAgICBpc0NhcHR1cmluZyA9IGZhbHNlO1xuICAgICAgICB1bmJpbmRFdmVudHNSZWYuY3VycmVudCgpO1xuICAgICAgICBsaXN0ZW5Gb3JDYXB0dXJlKCk7XG4gICAgICB9XG4gICAgICB1bmJpbmRFdmVudHNSZWYuY3VycmVudCA9IGJpbmRFdmVudHMod2luZG93LCBnZXREcmFnZ2luZ0JpbmRpbmdzKGFjdGlvbnMsIHN0b3ApLCB7XG4gICAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG4gIH0pLCBbYXBpXSk7XG4gIGNvbnN0IGxpc3RlbkZvckNhcHR1cmUgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiB0cnlTdGFydENhcHR1cmUoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIHBhc3NpdmU6IGZhbHNlLFxuICAgICAgY2FwdHVyZTogdHJ1ZVxuICAgIH07XG4gICAgdW5iaW5kRXZlbnRzUmVmLmN1cnJlbnQgPSBiaW5kRXZlbnRzKHdpbmRvdywgW3N0YXJ0Q2FwdHVyZUJpbmRpbmddLCBvcHRpb25zKTtcbiAgfSwgW3N0YXJ0Q2FwdHVyZUJpbmRpbmddKTtcbiAgdXNlTGF5b3V0RWZmZWN0KGZ1bmN0aW9uIG1vdW50KCkge1xuICAgIGxpc3RlbkZvckNhcHR1cmUoKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gdW5tb3VudCgpIHtcbiAgICAgIHVuYmluZEV2ZW50c1JlZi5jdXJyZW50KCk7XG4gICAgfTtcbiAgfSwgW2xpc3RlbkZvckNhcHR1cmVdKTtcbn1cblxuY29uc3QgaWRsZSA9IHtcbiAgdHlwZTogJ0lETEUnXG59O1xuY29uc3QgdGltZUZvckxvbmdQcmVzcyA9IDEyMDtcbmNvbnN0IGZvcmNlUHJlc3NUaHJlc2hvbGQgPSAwLjE1O1xuZnVuY3Rpb24gZ2V0V2luZG93QmluZGluZ3Moe1xuICBjYW5jZWwsXG4gIGdldFBoYXNlXG59KSB7XG4gIHJldHVybiBbe1xuICAgIGV2ZW50TmFtZTogJ29yaWVudGF0aW9uY2hhbmdlJyxcbiAgICBmbjogY2FuY2VsXG4gIH0sIHtcbiAgICBldmVudE5hbWU6ICdyZXNpemUnLFxuICAgIGZuOiBjYW5jZWxcbiAgfSwge1xuICAgIGV2ZW50TmFtZTogJ2NvbnRleHRtZW51JyxcbiAgICBmbjogZXZlbnQgPT4ge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBldmVudE5hbWU6ICdrZXlkb3duJyxcbiAgICBmbjogZXZlbnQgPT4ge1xuICAgICAgaWYgKGdldFBoYXNlKCkudHlwZSAhPT0gJ0RSQUdHSU5HJykge1xuICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IGVzY2FwZSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgICAgY2FuY2VsKCk7XG4gICAgfVxuICB9LCB7XG4gICAgZXZlbnROYW1lOiBzdXBwb3J0ZWRQYWdlVmlzaWJpbGl0eUV2ZW50TmFtZSxcbiAgICBmbjogY2FuY2VsXG4gIH1dO1xufVxuZnVuY3Rpb24gZ2V0SGFuZGxlQmluZGluZ3Moe1xuICBjYW5jZWwsXG4gIGNvbXBsZXRlZCxcbiAgZ2V0UGhhc2Vcbn0pIHtcbiAgcmV0dXJuIFt7XG4gICAgZXZlbnROYW1lOiAndG91Y2htb3ZlJyxcbiAgICBvcHRpb25zOiB7XG4gICAgICBjYXB0dXJlOiBmYWxzZVxuICAgIH0sXG4gICAgZm46IGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IHBoYXNlID0gZ2V0UGhhc2UoKTtcbiAgICAgIGlmIChwaGFzZS50eXBlICE9PSAnRFJBR0dJTkcnKSB7XG4gICAgICAgIGNhbmNlbCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBwaGFzZS5oYXNNb3ZlZCA9IHRydWU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNsaWVudFgsXG4gICAgICAgIGNsaWVudFlcbiAgICAgIH0gPSBldmVudC50b3VjaGVzWzBdO1xuICAgICAgY29uc3QgcG9pbnQgPSB7XG4gICAgICAgIHg6IGNsaWVudFgsXG4gICAgICAgIHk6IGNsaWVudFlcbiAgICAgIH07XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgcGhhc2UuYWN0aW9ucy5tb3ZlKHBvaW50KTtcbiAgICB9XG4gIH0sIHtcbiAgICBldmVudE5hbWU6ICd0b3VjaGVuZCcsXG4gICAgZm46IGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IHBoYXNlID0gZ2V0UGhhc2UoKTtcbiAgICAgIGlmIChwaGFzZS50eXBlICE9PSAnRFJBR0dJTkcnKSB7XG4gICAgICAgIGNhbmNlbCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgcGhhc2UuYWN0aW9ucy5kcm9wKHtcbiAgICAgICAgc2hvdWxkQmxvY2tOZXh0Q2xpY2s6IHRydWVcbiAgICAgIH0pO1xuICAgICAgY29tcGxldGVkKCk7XG4gICAgfVxuICB9LCB7XG4gICAgZXZlbnROYW1lOiAndG91Y2hjYW5jZWwnLFxuICAgIGZuOiBldmVudCA9PiB7XG4gICAgICBpZiAoZ2V0UGhhc2UoKS50eXBlICE9PSAnRFJBR0dJTkcnKSB7XG4gICAgICAgIGNhbmNlbCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgY2FuY2VsKCk7XG4gICAgfVxuICB9LCB7XG4gICAgZXZlbnROYW1lOiAndG91Y2hmb3JjZWNoYW5nZScsXG4gICAgZm46IGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IHBoYXNlID0gZ2V0UGhhc2UoKTtcbiAgICAgICEocGhhc2UudHlwZSAhPT0gJ0lETEUnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgICAgY29uc3QgdG91Y2ggPSBldmVudC50b3VjaGVzWzBdO1xuICAgICAgaWYgKCF0b3VjaCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBpc0ZvcmNlUHJlc3MgPSB0b3VjaC5mb3JjZSA+PSBmb3JjZVByZXNzVGhyZXNob2xkO1xuICAgICAgaWYgKCFpc0ZvcmNlUHJlc3MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2hvdWxkUmVzcGVjdCA9IHBoYXNlLmFjdGlvbnMuc2hvdWxkUmVzcGVjdEZvcmNlUHJlc3MoKTtcbiAgICAgIGlmIChwaGFzZS50eXBlID09PSAnUEVORElORycpIHtcbiAgICAgICAgaWYgKHNob3VsZFJlc3BlY3QpIHtcbiAgICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkUmVzcGVjdCkge1xuICAgICAgICBpZiAocGhhc2UuaGFzTW92ZWQpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBldmVudE5hbWU6IHN1cHBvcnRlZFBhZ2VWaXNpYmlsaXR5RXZlbnROYW1lLFxuICAgIGZuOiBjYW5jZWxcbiAgfV07XG59XG5mdW5jdGlvbiB1c2VUb3VjaFNlbnNvcihhcGkpIHtcbiAgY29uc3QgcGhhc2VSZWYgPSB1c2VSZWYoaWRsZSk7XG4gIGNvbnN0IHVuYmluZEV2ZW50c1JlZiA9IHVzZVJlZihub29wJDIpO1xuICBjb25zdCBnZXRQaGFzZSA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIGdldFBoYXNlKCkge1xuICAgIHJldHVybiBwaGFzZVJlZi5jdXJyZW50O1xuICB9LCBbXSk7XG4gIGNvbnN0IHNldFBoYXNlID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gc2V0UGhhc2UocGhhc2UpIHtcbiAgICBwaGFzZVJlZi5jdXJyZW50ID0gcGhhc2U7XG4gIH0sIFtdKTtcbiAgY29uc3Qgc3RhcnRDYXB0dXJlQmluZGluZyA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICBldmVudE5hbWU6ICd0b3VjaHN0YXJ0JyxcbiAgICBmbjogZnVuY3Rpb24gb25Ub3VjaFN0YXJ0KGV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBkcmFnZ2FibGVJZCA9IGFwaS5maW5kQ2xvc2VzdERyYWdnYWJsZUlkKGV2ZW50KTtcbiAgICAgIGlmICghZHJhZ2dhYmxlSWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgYWN0aW9ucyA9IGFwaS50cnlHZXRMb2NrKGRyYWdnYWJsZUlkLCBzdG9wLCB7XG4gICAgICAgIHNvdXJjZUV2ZW50OiBldmVudFxuICAgICAgfSk7XG4gICAgICBpZiAoIWFjdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgdG91Y2ggPSBldmVudC50b3VjaGVzWzBdO1xuICAgICAgY29uc3Qge1xuICAgICAgICBjbGllbnRYLFxuICAgICAgICBjbGllbnRZXG4gICAgICB9ID0gdG91Y2g7XG4gICAgICBjb25zdCBwb2ludCA9IHtcbiAgICAgICAgeDogY2xpZW50WCxcbiAgICAgICAgeTogY2xpZW50WVxuICAgICAgfTtcbiAgICAgIHVuYmluZEV2ZW50c1JlZi5jdXJyZW50KCk7XG4gICAgICBzdGFydFBlbmRpbmdEcmFnKGFjdGlvbnMsIHBvaW50KTtcbiAgICB9XG4gIH0pLCBbYXBpXSk7XG4gIGNvbnN0IGxpc3RlbkZvckNhcHR1cmUgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiBsaXN0ZW5Gb3JDYXB0dXJlKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICB9O1xuICAgIHVuYmluZEV2ZW50c1JlZi5jdXJyZW50ID0gYmluZEV2ZW50cyh3aW5kb3csIFtzdGFydENhcHR1cmVCaW5kaW5nXSwgb3B0aW9ucyk7XG4gIH0sIFtzdGFydENhcHR1cmVCaW5kaW5nXSk7XG4gIGNvbnN0IHN0b3AgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgY29uc3QgY3VycmVudCA9IHBoYXNlUmVmLmN1cnJlbnQ7XG4gICAgaWYgKGN1cnJlbnQudHlwZSA9PT0gJ0lETEUnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjdXJyZW50LnR5cGUgPT09ICdQRU5ESU5HJykge1xuICAgICAgY2xlYXJUaW1lb3V0KGN1cnJlbnQubG9uZ1ByZXNzVGltZXJJZCk7XG4gICAgfVxuICAgIHNldFBoYXNlKGlkbGUpO1xuICAgIHVuYmluZEV2ZW50c1JlZi5jdXJyZW50KCk7XG4gICAgbGlzdGVuRm9yQ2FwdHVyZSgpO1xuICB9LCBbbGlzdGVuRm9yQ2FwdHVyZSwgc2V0UGhhc2VdKTtcbiAgY29uc3QgY2FuY2VsID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGNvbnN0IHBoYXNlID0gcGhhc2VSZWYuY3VycmVudDtcbiAgICBzdG9wKCk7XG4gICAgaWYgKHBoYXNlLnR5cGUgPT09ICdEUkFHR0lORycpIHtcbiAgICAgIHBoYXNlLmFjdGlvbnMuY2FuY2VsKHtcbiAgICAgICAgc2hvdWxkQmxvY2tOZXh0Q2xpY2s6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAocGhhc2UudHlwZSA9PT0gJ1BFTkRJTkcnKSB7XG4gICAgICBwaGFzZS5hY3Rpb25zLmFib3J0KCk7XG4gICAgfVxuICB9LCBbc3RvcF0pO1xuICBjb25zdCBiaW5kQ2FwdHVyaW5nRXZlbnRzID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gYmluZENhcHR1cmluZ0V2ZW50cygpIHtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgfTtcbiAgICBjb25zdCBhcmdzID0ge1xuICAgICAgY2FuY2VsLFxuICAgICAgY29tcGxldGVkOiBzdG9wLFxuICAgICAgZ2V0UGhhc2VcbiAgICB9O1xuICAgIGNvbnN0IHVuYmluZFRhcmdldCA9IGJpbmRFdmVudHMod2luZG93LCBnZXRIYW5kbGVCaW5kaW5ncyhhcmdzKSwgb3B0aW9ucyk7XG4gICAgY29uc3QgdW5iaW5kV2luZG93ID0gYmluZEV2ZW50cyh3aW5kb3csIGdldFdpbmRvd0JpbmRpbmdzKGFyZ3MpLCBvcHRpb25zKTtcbiAgICB1bmJpbmRFdmVudHNSZWYuY3VycmVudCA9IGZ1bmN0aW9uIHVuYmluZEFsbCgpIHtcbiAgICAgIHVuYmluZFRhcmdldCgpO1xuICAgICAgdW5iaW5kV2luZG93KCk7XG4gICAgfTtcbiAgfSwgW2NhbmNlbCwgZ2V0UGhhc2UsIHN0b3BdKTtcbiAgY29uc3Qgc3RhcnREcmFnZ2luZyA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHN0YXJ0RHJhZ2dpbmcoKSB7XG4gICAgY29uc3QgcGhhc2UgPSBnZXRQaGFzZSgpO1xuICAgICEocGhhc2UudHlwZSA9PT0gJ1BFTkRJTkcnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYENhbm5vdCBzdGFydCBkcmFnZ2luZyBmcm9tIHBoYXNlICR7cGhhc2UudHlwZX1gKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgY29uc3QgYWN0aW9ucyA9IHBoYXNlLmFjdGlvbnMuZmx1aWRMaWZ0KHBoYXNlLnBvaW50KTtcbiAgICBzZXRQaGFzZSh7XG4gICAgICB0eXBlOiAnRFJBR0dJTkcnLFxuICAgICAgYWN0aW9ucyxcbiAgICAgIGhhc01vdmVkOiBmYWxzZVxuICAgIH0pO1xuICB9LCBbZ2V0UGhhc2UsIHNldFBoYXNlXSk7XG4gIGNvbnN0IHN0YXJ0UGVuZGluZ0RyYWcgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiBzdGFydFBlbmRpbmdEcmFnKGFjdGlvbnMsIHBvaW50KSB7XG4gICAgIShnZXRQaGFzZSgpLnR5cGUgPT09ICdJRExFJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCB0byBtb3ZlIGZyb20gSURMRSB0byBQRU5ESU5HIGRyYWcnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgY29uc3QgbG9uZ1ByZXNzVGltZXJJZCA9IHNldFRpbWVvdXQoc3RhcnREcmFnZ2luZywgdGltZUZvckxvbmdQcmVzcyk7XG4gICAgc2V0UGhhc2Uoe1xuICAgICAgdHlwZTogJ1BFTkRJTkcnLFxuICAgICAgcG9pbnQsXG4gICAgICBhY3Rpb25zLFxuICAgICAgbG9uZ1ByZXNzVGltZXJJZFxuICAgIH0pO1xuICAgIGJpbmRDYXB0dXJpbmdFdmVudHMoKTtcbiAgfSwgW2JpbmRDYXB0dXJpbmdFdmVudHMsIGdldFBoYXNlLCBzZXRQaGFzZSwgc3RhcnREcmFnZ2luZ10pO1xuICB1c2VMYXlvdXRFZmZlY3QoZnVuY3Rpb24gbW91bnQoKSB7XG4gICAgbGlzdGVuRm9yQ2FwdHVyZSgpO1xuICAgIHJldHVybiBmdW5jdGlvbiB1bm1vdW50KCkge1xuICAgICAgdW5iaW5kRXZlbnRzUmVmLmN1cnJlbnQoKTtcbiAgICAgIGNvbnN0IHBoYXNlID0gZ2V0UGhhc2UoKTtcbiAgICAgIGlmIChwaGFzZS50eXBlID09PSAnUEVORElORycpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHBoYXNlLmxvbmdQcmVzc1RpbWVySWQpO1xuICAgICAgICBzZXRQaGFzZShpZGxlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbZ2V0UGhhc2UsIGxpc3RlbkZvckNhcHR1cmUsIHNldFBoYXNlXSk7XG4gIHVzZUxheW91dEVmZmVjdChmdW5jdGlvbiB3ZWJraXRIYWNrKCkge1xuICAgIGNvbnN0IHVuYmluZCA9IGJpbmRFdmVudHMod2luZG93LCBbe1xuICAgICAgZXZlbnROYW1lOiAndG91Y2htb3ZlJyxcbiAgICAgIGZuOiAoKSA9PiB7fSxcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgY2FwdHVyZTogZmFsc2UsXG4gICAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgICB9XG4gICAgfV0pO1xuICAgIHJldHVybiB1bmJpbmQ7XG4gIH0sIFtdKTtcbn1cblxuZnVuY3Rpb24gdXNlVmFsaWRhdGVTZW5zb3JIb29rcyhzZW5zb3JIb29rcykge1xuICB1c2VEZXYoKCkgPT4ge1xuICAgIGNvbnN0IHByZXZpb3VzUmVmID0gdXNlUHJldmlvdXMoc2Vuc29ySG9va3MpO1xuICAgIHVzZURldlNldHVwV2FybmluZygoKSA9PiB7XG4gICAgICAhKHByZXZpb3VzUmVmLmN1cnJlbnQubGVuZ3RoID09PSBzZW5zb3JIb29rcy5sZW5ndGgpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IGNoYW5nZSB0aGUgYW1vdW50IG9mIHNlbnNvciBob29rcyBhZnRlciBtb3VudGluZycpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICB9KTtcbiAgfSk7XG59XG5cbmNvbnN0IGludGVyYWN0aXZlVGFnTmFtZXMgPSBbJ2lucHV0JywgJ2J1dHRvbicsICd0ZXh0YXJlYScsICdzZWxlY3QnLCAnb3B0aW9uJywgJ29wdGdyb3VwJywgJ3ZpZGVvJywgJ2F1ZGlvJ107XG5mdW5jdGlvbiBpc0FuSW50ZXJhY3RpdmVFbGVtZW50KHBhcmVudCwgY3VycmVudCkge1xuICBpZiAoY3VycmVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGhhc0FuSW50ZXJhY3RpdmVUYWcgPSBpbnRlcmFjdGl2ZVRhZ05hbWVzLmluY2x1ZGVzKGN1cnJlbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgaWYgKGhhc0FuSW50ZXJhY3RpdmVUYWcpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBhdHRyaWJ1dGUgPSBjdXJyZW50LmdldEF0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJyk7XG4gIGlmIChhdHRyaWJ1dGUgPT09ICd0cnVlJyB8fCBhdHRyaWJ1dGUgPT09ICcnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGN1cnJlbnQgPT09IHBhcmVudCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gaXNBbkludGVyYWN0aXZlRWxlbWVudChwYXJlbnQsIGN1cnJlbnQucGFyZW50RWxlbWVudCk7XG59XG5mdW5jdGlvbiBpc0V2ZW50SW5JbnRlcmFjdGl2ZUVsZW1lbnQoZHJhZ2dhYmxlLCBldmVudCkge1xuICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gIGlmICghaXNIdG1sRWxlbWVudCh0YXJnZXQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBpc0FuSW50ZXJhY3RpdmVFbGVtZW50KGRyYWdnYWJsZSwgdGFyZ2V0KTtcbn1cblxudmFyIGdldEJvcmRlckJveENlbnRlclBvc2l0aW9uID0gKGVsID0+IGdldFJlY3QoZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpLmNlbnRlcik7XG5cbmZ1bmN0aW9uIGlzRWxlbWVudChlbCkge1xuICByZXR1cm4gZWwgaW5zdGFuY2VvZiBnZXRXaW5kb3dGcm9tRWwoZWwpLkVsZW1lbnQ7XG59XG5cbmNvbnN0IHN1cHBvcnRlZE1hdGNoZXNOYW1lID0gKCgpID0+IHtcbiAgY29uc3QgYmFzZSA9ICdtYXRjaGVzJztcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gYmFzZTtcbiAgfVxuICBjb25zdCBjYW5kaWRhdGVzID0gW2Jhc2UsICdtc01hdGNoZXNTZWxlY3RvcicsICd3ZWJraXRNYXRjaGVzU2VsZWN0b3InXTtcbiAgY29uc3QgdmFsdWUgPSBjYW5kaWRhdGVzLmZpbmQobmFtZSA9PiBuYW1lIGluIEVsZW1lbnQucHJvdG90eXBlKTtcbiAgcmV0dXJuIHZhbHVlIHx8IGJhc2U7XG59KSgpO1xuZnVuY3Rpb24gY2xvc2VzdFBvbnlmaWxsKGVsLCBzZWxlY3Rvcikge1xuICBpZiAoZWwgPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChlbFtzdXBwb3J0ZWRNYXRjaGVzTmFtZV0oc2VsZWN0b3IpKSB7XG4gICAgcmV0dXJuIGVsO1xuICB9XG4gIHJldHVybiBjbG9zZXN0UG9ueWZpbGwoZWwucGFyZW50RWxlbWVudCwgc2VsZWN0b3IpO1xufVxuZnVuY3Rpb24gY2xvc2VzdChlbCwgc2VsZWN0b3IpIHtcbiAgaWYgKGVsLmNsb3Nlc3QpIHtcbiAgICByZXR1cm4gZWwuY2xvc2VzdChzZWxlY3Rvcik7XG4gIH1cbiAgcmV0dXJuIGNsb3Nlc3RQb255ZmlsbChlbCwgc2VsZWN0b3IpO1xufVxuXG5mdW5jdGlvbiBnZXRTZWxlY3Rvcihjb250ZXh0SWQpIHtcbiAgcmV0dXJuIGBbJHtkcmFnSGFuZGxlLmNvbnRleHRJZH09XCIke2NvbnRleHRJZH1cIl1gO1xufVxuZnVuY3Rpb24gZmluZENsb3Nlc3REcmFnSGFuZGxlRnJvbUV2ZW50KGNvbnRleHRJZCwgZXZlbnQpIHtcbiAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICBpZiAoIWlzRWxlbWVudCh0YXJnZXQpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZygnZXZlbnQudGFyZ2V0IG11c3QgYmUgYSBFbGVtZW50JykgOiB2b2lkIDA7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3Qgc2VsZWN0b3IgPSBnZXRTZWxlY3Rvcihjb250ZXh0SWQpO1xuICBjb25zdCBoYW5kbGUgPSBjbG9zZXN0KHRhcmdldCwgc2VsZWN0b3IpO1xuICBpZiAoIWhhbmRsZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmICghaXNIdG1sRWxlbWVudChoYW5kbGUpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZygnZHJhZyBoYW5kbGUgbXVzdCBiZSBhIEhUTUxFbGVtZW50JykgOiB2b2lkIDA7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGhhbmRsZTtcbn1cbmZ1bmN0aW9uIHRyeUdldENsb3Nlc3REcmFnZ2FibGVJZEZyb21FdmVudChjb250ZXh0SWQsIGV2ZW50KSB7XG4gIGNvbnN0IGhhbmRsZSA9IGZpbmRDbG9zZXN0RHJhZ0hhbmRsZUZyb21FdmVudChjb250ZXh0SWQsIGV2ZW50KTtcbiAgaWYgKCFoYW5kbGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gaGFuZGxlLmdldEF0dHJpYnV0ZShkcmFnSGFuZGxlLmRyYWdnYWJsZUlkKTtcbn1cblxuZnVuY3Rpb24gZmluZERyYWdnYWJsZShjb250ZXh0SWQsIGRyYWdnYWJsZUlkKSB7XG4gIGNvbnN0IHNlbGVjdG9yID0gYFske2RyYWdnYWJsZS5jb250ZXh0SWR9PVwiJHtjb250ZXh0SWR9XCJdYDtcbiAgY29uc3QgcG9zc2libGUgPSBxdWVyeVNlbGVjdG9yQWxsKGRvY3VtZW50LCBzZWxlY3Rvcik7XG4gIGNvbnN0IGRyYWdnYWJsZSQxID0gcG9zc2libGUuZmluZChlbCA9PiB7XG4gICAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZShkcmFnZ2FibGUuaWQpID09PSBkcmFnZ2FibGVJZDtcbiAgfSk7XG4gIGlmICghZHJhZ2dhYmxlJDEpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoIWlzSHRtbEVsZW1lbnQoZHJhZ2dhYmxlJDEpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZygnRHJhZ2dhYmxlIGVsZW1lbnQgaXMgbm90IGEgSFRNTEVsZW1lbnQnKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gZHJhZ2dhYmxlJDE7XG59XG5cbmZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KGV2ZW50KSB7XG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG59XG5mdW5jdGlvbiBpc0FjdGl2ZSh7XG4gIGV4cGVjdGVkLFxuICBwaGFzZSxcbiAgaXNMb2NrQWN0aXZlLFxuICBzaG91bGRXYXJuXG59KSB7XG4gIGlmICghaXNMb2NrQWN0aXZlKCkpIHtcbiAgICBpZiAoc2hvdWxkV2Fybikge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhgXG4gICAgICAgIENhbm5vdCBwZXJmb3JtIGFjdGlvbi5cbiAgICAgICAgVGhlIHNlbnNvciBubyBsb25nZXIgaGFzIGFuIGFjdGlvbiBsb2NrLlxuXG4gICAgICAgIFRpcHM6XG5cbiAgICAgICAgLSBUaHJvdyBhd2F5IHlvdXIgYWN0aW9uIGhhbmRsZXJzIHdoZW4gZm9yY2VTdG9wKCkgaXMgY2FsbGVkXG4gICAgICAgIC0gQ2hlY2sgYWN0aW9ucy5pc0FjdGl2ZSgpIGlmIHlvdSByZWFsbHkgbmVlZCB0b1xuICAgICAgYCkgOiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZXhwZWN0ZWQgIT09IHBoYXNlKSB7XG4gICAgaWYgKHNob3VsZFdhcm4pIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoYFxuICAgICAgICBDYW5ub3QgcGVyZm9ybSBhY3Rpb24uXG4gICAgICAgIFRoZSBhY3Rpb25zIHlvdSB1c2VkIGJlbG9uZyB0byBhbiBvdXRkYXRlZCBwaGFzZVxuXG4gICAgICAgIEN1cnJlbnQgcGhhc2U6ICR7ZXhwZWN0ZWR9XG4gICAgICAgIFlvdSBjYWxsZWQgYW4gYWN0aW9uIGZyb20gb3V0ZGF0ZWQgcGhhc2U6ICR7cGhhc2V9XG5cbiAgICAgICAgVGlwczpcblxuICAgICAgICAtIERvIG5vdCB1c2UgcHJlRHJhZ0FjdGlvbnMgYWN0aW9ucyBhZnRlciBjYWxsaW5nIHByZURyYWdBY3Rpb25zLmxpZnQoKVxuICAgICAgYCkgOiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGNhblN0YXJ0KHtcbiAgbG9ja0FQSSxcbiAgc3RvcmUsXG4gIHJlZ2lzdHJ5LFxuICBkcmFnZ2FibGVJZFxufSkge1xuICBpZiAobG9ja0FQSS5pc0NsYWltZWQoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBlbnRyeSA9IHJlZ2lzdHJ5LmRyYWdnYWJsZS5maW5kQnlJZChkcmFnZ2FibGVJZCk7XG4gIGlmICghZW50cnkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGBVbmFibGUgdG8gZmluZCBkcmFnZ2FibGUgd2l0aCBpZDogJHtkcmFnZ2FibGVJZH1gKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCFlbnRyeS5vcHRpb25zLmlzRW5hYmxlZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoIWNhblN0YXJ0RHJhZyhzdG9yZS5nZXRTdGF0ZSgpLCBkcmFnZ2FibGVJZCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiB0cnlTdGFydCh7XG4gIGxvY2tBUEksXG4gIGNvbnRleHRJZCxcbiAgc3RvcmUsXG4gIHJlZ2lzdHJ5LFxuICBkcmFnZ2FibGVJZCxcbiAgZm9yY2VTZW5zb3JTdG9wLFxuICBzb3VyY2VFdmVudFxufSkge1xuICBjb25zdCBzaG91bGRTdGFydCA9IGNhblN0YXJ0KHtcbiAgICBsb2NrQVBJLFxuICAgIHN0b3JlLFxuICAgIHJlZ2lzdHJ5LFxuICAgIGRyYWdnYWJsZUlkXG4gIH0pO1xuICBpZiAoIXNob3VsZFN0YXJ0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgZW50cnkgPSByZWdpc3RyeS5kcmFnZ2FibGUuZ2V0QnlJZChkcmFnZ2FibGVJZCk7XG4gIGNvbnN0IGVsID0gZmluZERyYWdnYWJsZShjb250ZXh0SWQsIGVudHJ5LmRlc2NyaXB0b3IuaWQpO1xuICBpZiAoIWVsKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhgVW5hYmxlIHRvIGZpbmQgZHJhZ2dhYmxlIGVsZW1lbnQgd2l0aCBpZDogJHtkcmFnZ2FibGVJZH1gKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoc291cmNlRXZlbnQgJiYgIWVudHJ5Lm9wdGlvbnMuY2FuRHJhZ0ludGVyYWN0aXZlRWxlbWVudHMgJiYgaXNFdmVudEluSW50ZXJhY3RpdmVFbGVtZW50KGVsLCBzb3VyY2VFdmVudCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBsb2NrID0gbG9ja0FQSS5jbGFpbShmb3JjZVNlbnNvclN0b3AgfHwgbm9vcCQyKTtcbiAgbGV0IHBoYXNlID0gJ1BSRV9EUkFHJztcbiAgZnVuY3Rpb24gZ2V0U2hvdWxkUmVzcGVjdEZvcmNlUHJlc3MoKSB7XG4gICAgcmV0dXJuIGVudHJ5Lm9wdGlvbnMuc2hvdWxkUmVzcGVjdEZvcmNlUHJlc3M7XG4gIH1cbiAgZnVuY3Rpb24gaXNMb2NrQWN0aXZlKCkge1xuICAgIHJldHVybiBsb2NrQVBJLmlzQWN0aXZlKGxvY2spO1xuICB9XG4gIGZ1bmN0aW9uIHRyeURpc3BhdGNoKGV4cGVjdGVkLCBnZXRBY3Rpb24pIHtcbiAgICBpZiAoaXNBY3RpdmUoe1xuICAgICAgZXhwZWN0ZWQsXG4gICAgICBwaGFzZSxcbiAgICAgIGlzTG9ja0FjdGl2ZSxcbiAgICAgIHNob3VsZFdhcm46IHRydWVcbiAgICB9KSkge1xuICAgICAgc3RvcmUuZGlzcGF0Y2goZ2V0QWN0aW9uKCkpO1xuICAgIH1cbiAgfVxuICBjb25zdCB0cnlEaXNwYXRjaFdoZW5EcmFnZ2luZyA9IHRyeURpc3BhdGNoLmJpbmQobnVsbCwgJ0RSQUdHSU5HJyk7XG4gIGZ1bmN0aW9uIGxpZnQoYXJncykge1xuICAgIGZ1bmN0aW9uIGNvbXBsZXRlZCgpIHtcbiAgICAgIGxvY2tBUEkucmVsZWFzZSgpO1xuICAgICAgcGhhc2UgPSAnQ09NUExFVEVEJztcbiAgICB9XG4gICAgaWYgKHBoYXNlICE9PSAnUFJFX0RSQUcnKSB7XG4gICAgICBjb21wbGV0ZWQoKTtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYENhbm5vdCBsaWZ0IGluIHBoYXNlICR7cGhhc2V9YCkgOiBpbnZhcmlhbnQoZmFsc2UpIDtcbiAgICB9XG4gICAgc3RvcmUuZGlzcGF0Y2gobGlmdCQxKGFyZ3MubGlmdEFjdGlvbkFyZ3MpKTtcbiAgICBwaGFzZSA9ICdEUkFHR0lORyc7XG4gICAgZnVuY3Rpb24gZmluaXNoKHJlYXNvbiwgb3B0aW9ucyA9IHtcbiAgICAgIHNob3VsZEJsb2NrTmV4dENsaWNrOiBmYWxzZVxuICAgIH0pIHtcbiAgICAgIGFyZ3MuY2xlYW51cCgpO1xuICAgICAgaWYgKG9wdGlvbnMuc2hvdWxkQmxvY2tOZXh0Q2xpY2spIHtcbiAgICAgICAgY29uc3QgdW5iaW5kID0gYmluZEV2ZW50cyh3aW5kb3csIFt7XG4gICAgICAgICAgZXZlbnROYW1lOiAnY2xpY2snLFxuICAgICAgICAgIGZuOiBwcmV2ZW50RGVmYXVsdCxcbiAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBvbmNlOiB0cnVlLFxuICAgICAgICAgICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgICAgICAgICBjYXB0dXJlOiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XSk7XG4gICAgICAgIHNldFRpbWVvdXQodW5iaW5kKTtcbiAgICAgIH1cbiAgICAgIGNvbXBsZXRlZCgpO1xuICAgICAgc3RvcmUuZGlzcGF0Y2goZHJvcCQxKHtcbiAgICAgICAgcmVhc29uXG4gICAgICB9KSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBpc0FjdGl2ZTogKCkgPT4gaXNBY3RpdmUoe1xuICAgICAgICBleHBlY3RlZDogJ0RSQUdHSU5HJyxcbiAgICAgICAgcGhhc2UsXG4gICAgICAgIGlzTG9ja0FjdGl2ZSxcbiAgICAgICAgc2hvdWxkV2FybjogZmFsc2VcbiAgICAgIH0pLFxuICAgICAgc2hvdWxkUmVzcGVjdEZvcmNlUHJlc3M6IGdldFNob3VsZFJlc3BlY3RGb3JjZVByZXNzLFxuICAgICAgZHJvcDogb3B0aW9ucyA9PiBmaW5pc2goJ0RST1AnLCBvcHRpb25zKSxcbiAgICAgIGNhbmNlbDogb3B0aW9ucyA9PiBmaW5pc2goJ0NBTkNFTCcsIG9wdGlvbnMpLFxuICAgICAgLi4uYXJncy5hY3Rpb25zXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBmbHVpZExpZnQoY2xpZW50U2VsZWN0aW9uKSB7XG4gICAgY29uc3QgbW92ZSQxID0gcmFmU2NoZChjbGllbnQgPT4ge1xuICAgICAgdHJ5RGlzcGF0Y2hXaGVuRHJhZ2dpbmcoKCkgPT4gbW92ZSh7XG4gICAgICAgIGNsaWVudFxuICAgICAgfSkpO1xuICAgIH0pO1xuICAgIGNvbnN0IGFwaSA9IGxpZnQoe1xuICAgICAgbGlmdEFjdGlvbkFyZ3M6IHtcbiAgICAgICAgaWQ6IGRyYWdnYWJsZUlkLFxuICAgICAgICBjbGllbnRTZWxlY3Rpb24sXG4gICAgICAgIG1vdmVtZW50TW9kZTogJ0ZMVUlEJ1xuICAgICAgfSxcbiAgICAgIGNsZWFudXA6ICgpID0+IG1vdmUkMS5jYW5jZWwoKSxcbiAgICAgIGFjdGlvbnM6IHtcbiAgICAgICAgbW92ZTogbW92ZSQxXG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmFwaSxcbiAgICAgIG1vdmU6IG1vdmUkMVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gc25hcExpZnQoKSB7XG4gICAgY29uc3QgYWN0aW9ucyA9IHtcbiAgICAgIG1vdmVVcDogKCkgPT4gdHJ5RGlzcGF0Y2hXaGVuRHJhZ2dpbmcobW92ZVVwKSxcbiAgICAgIG1vdmVSaWdodDogKCkgPT4gdHJ5RGlzcGF0Y2hXaGVuRHJhZ2dpbmcobW92ZVJpZ2h0KSxcbiAgICAgIG1vdmVEb3duOiAoKSA9PiB0cnlEaXNwYXRjaFdoZW5EcmFnZ2luZyhtb3ZlRG93biksXG4gICAgICBtb3ZlTGVmdDogKCkgPT4gdHJ5RGlzcGF0Y2hXaGVuRHJhZ2dpbmcobW92ZUxlZnQpXG4gICAgfTtcbiAgICByZXR1cm4gbGlmdCh7XG4gICAgICBsaWZ0QWN0aW9uQXJnczoge1xuICAgICAgICBpZDogZHJhZ2dhYmxlSWQsXG4gICAgICAgIGNsaWVudFNlbGVjdGlvbjogZ2V0Qm9yZGVyQm94Q2VudGVyUG9zaXRpb24oZWwpLFxuICAgICAgICBtb3ZlbWVudE1vZGU6ICdTTkFQJ1xuICAgICAgfSxcbiAgICAgIGNsZWFudXA6IG5vb3AkMixcbiAgICAgIGFjdGlvbnNcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBhYm9ydFByZURyYWcoKSB7XG4gICAgY29uc3Qgc2hvdWxkUmVsZWFzZSA9IGlzQWN0aXZlKHtcbiAgICAgIGV4cGVjdGVkOiAnUFJFX0RSQUcnLFxuICAgICAgcGhhc2UsXG4gICAgICBpc0xvY2tBY3RpdmUsXG4gICAgICBzaG91bGRXYXJuOiB0cnVlXG4gICAgfSk7XG4gICAgaWYgKHNob3VsZFJlbGVhc2UpIHtcbiAgICAgIGxvY2tBUEkucmVsZWFzZSgpO1xuICAgIH1cbiAgfVxuICBjb25zdCBwcmVEcmFnID0ge1xuICAgIGlzQWN0aXZlOiAoKSA9PiBpc0FjdGl2ZSh7XG4gICAgICBleHBlY3RlZDogJ1BSRV9EUkFHJyxcbiAgICAgIHBoYXNlLFxuICAgICAgaXNMb2NrQWN0aXZlLFxuICAgICAgc2hvdWxkV2FybjogZmFsc2VcbiAgICB9KSxcbiAgICBzaG91bGRSZXNwZWN0Rm9yY2VQcmVzczogZ2V0U2hvdWxkUmVzcGVjdEZvcmNlUHJlc3MsXG4gICAgZmx1aWRMaWZ0LFxuICAgIHNuYXBMaWZ0LFxuICAgIGFib3J0OiBhYm9ydFByZURyYWdcbiAgfTtcbiAgcmV0dXJuIHByZURyYWc7XG59XG5jb25zdCBkZWZhdWx0U2Vuc29ycyA9IFt1c2VNb3VzZVNlbnNvciwgdXNlS2V5Ym9hcmRTZW5zb3IsIHVzZVRvdWNoU2Vuc29yXTtcbmZ1bmN0aW9uIHVzZVNlbnNvck1hcnNoYWwoe1xuICBjb250ZXh0SWQsXG4gIHN0b3JlLFxuICByZWdpc3RyeSxcbiAgY3VzdG9tU2Vuc29ycyxcbiAgZW5hYmxlRGVmYXVsdFNlbnNvcnNcbn0pIHtcbiAgY29uc3QgdXNlU2Vuc29ycyA9IFsuLi4oZW5hYmxlRGVmYXVsdFNlbnNvcnMgPyBkZWZhdWx0U2Vuc29ycyA6IFtdKSwgLi4uKGN1c3RvbVNlbnNvcnMgfHwgW10pXTtcbiAgY29uc3QgbG9ja0FQSSA9IHVzZVN0YXRlKCgpID0+IGNyZWF0ZSgpKVswXTtcbiAgY29uc3QgdHJ5QWJhbmRvbkxvY2sgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiB0cnlBYmFuZG9uTG9jayhwcmV2aW91cywgY3VycmVudCkge1xuICAgIGlmIChpc0RyYWdnaW5nKHByZXZpb3VzKSAmJiAhaXNEcmFnZ2luZyhjdXJyZW50KSkge1xuICAgICAgbG9ja0FQSS50cnlBYmFuZG9uKCk7XG4gICAgfVxuICB9LCBbbG9ja0FQSV0pO1xuICB1c2VMYXlvdXRFZmZlY3QoZnVuY3Rpb24gbGlzdGVuVG9TdG9yZSgpIHtcbiAgICBsZXQgcHJldmlvdXMgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gc3RvcmUuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgIGNvbnN0IGN1cnJlbnQgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgdHJ5QWJhbmRvbkxvY2socHJldmlvdXMsIGN1cnJlbnQpO1xuICAgICAgcHJldmlvdXMgPSBjdXJyZW50O1xuICAgIH0pO1xuICAgIHJldHVybiB1bnN1YnNjcmliZTtcbiAgfSwgW2xvY2tBUEksIHN0b3JlLCB0cnlBYmFuZG9uTG9ja10pO1xuICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiBsb2NrQVBJLnRyeUFiYW5kb247XG4gIH0sIFtsb2NrQVBJLnRyeUFiYW5kb25dKTtcbiAgY29uc3QgY2FuR2V0TG9jayA9IHVzZUNhbGxiYWNrKGRyYWdnYWJsZUlkID0+IHtcbiAgICByZXR1cm4gY2FuU3RhcnQoe1xuICAgICAgbG9ja0FQSSxcbiAgICAgIHJlZ2lzdHJ5LFxuICAgICAgc3RvcmUsXG4gICAgICBkcmFnZ2FibGVJZFxuICAgIH0pO1xuICB9LCBbbG9ja0FQSSwgcmVnaXN0cnksIHN0b3JlXSk7XG4gIGNvbnN0IHRyeUdldExvY2sgPSB1c2VDYWxsYmFjaygoZHJhZ2dhYmxlSWQsIGZvcmNlU3RvcCwgb3B0aW9ucykgPT4gdHJ5U3RhcnQoe1xuICAgIGxvY2tBUEksXG4gICAgcmVnaXN0cnksXG4gICAgY29udGV4dElkLFxuICAgIHN0b3JlLFxuICAgIGRyYWdnYWJsZUlkLFxuICAgIGZvcmNlU2Vuc29yU3RvcDogZm9yY2VTdG9wIHx8IG51bGwsXG4gICAgc291cmNlRXZlbnQ6IG9wdGlvbnMgJiYgb3B0aW9ucy5zb3VyY2VFdmVudCA/IG9wdGlvbnMuc291cmNlRXZlbnQgOiBudWxsXG4gIH0pLCBbY29udGV4dElkLCBsb2NrQVBJLCByZWdpc3RyeSwgc3RvcmVdKTtcbiAgY29uc3QgZmluZENsb3Nlc3REcmFnZ2FibGVJZCA9IHVzZUNhbGxiYWNrKGV2ZW50ID0+IHRyeUdldENsb3Nlc3REcmFnZ2FibGVJZEZyb21FdmVudChjb250ZXh0SWQsIGV2ZW50KSwgW2NvbnRleHRJZF0pO1xuICBjb25zdCBmaW5kT3B0aW9uc0ZvckRyYWdnYWJsZSA9IHVzZUNhbGxiYWNrKGlkID0+IHtcbiAgICBjb25zdCBlbnRyeSA9IHJlZ2lzdHJ5LmRyYWdnYWJsZS5maW5kQnlJZChpZCk7XG4gICAgcmV0dXJuIGVudHJ5ID8gZW50cnkub3B0aW9ucyA6IG51bGw7XG4gIH0sIFtyZWdpc3RyeS5kcmFnZ2FibGVdKTtcbiAgY29uc3QgdHJ5UmVsZWFzZUxvY2sgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiB0cnlSZWxlYXNlTG9jaygpIHtcbiAgICBpZiAoIWxvY2tBUEkuaXNDbGFpbWVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbG9ja0FQSS50cnlBYmFuZG9uKCk7XG4gICAgaWYgKHN0b3JlLmdldFN0YXRlKCkucGhhc2UgIT09ICdJRExFJykge1xuICAgICAgc3RvcmUuZGlzcGF0Y2goZmx1c2goKSk7XG4gICAgfVxuICB9LCBbbG9ja0FQSSwgc3RvcmVdKTtcbiAgY29uc3QgaXNMb2NrQ2xhaW1lZCA9IHVzZUNhbGxiYWNrKCgpID0+IGxvY2tBUEkuaXNDbGFpbWVkKCksIFtsb2NrQVBJXSk7XG4gIGNvbnN0IGFwaSA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICBjYW5HZXRMb2NrLFxuICAgIHRyeUdldExvY2ssXG4gICAgZmluZENsb3Nlc3REcmFnZ2FibGVJZCxcbiAgICBmaW5kT3B0aW9uc0ZvckRyYWdnYWJsZSxcbiAgICB0cnlSZWxlYXNlTG9jayxcbiAgICBpc0xvY2tDbGFpbWVkXG4gIH0pLCBbY2FuR2V0TG9jaywgdHJ5R2V0TG9jaywgZmluZENsb3Nlc3REcmFnZ2FibGVJZCwgZmluZE9wdGlvbnNGb3JEcmFnZ2FibGUsIHRyeVJlbGVhc2VMb2NrLCBpc0xvY2tDbGFpbWVkXSk7XG4gIHVzZVZhbGlkYXRlU2Vuc29ySG9va3ModXNlU2Vuc29ycyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdXNlU2Vuc29ycy5sZW5ndGg7IGkrKykge1xuICAgIHVzZVNlbnNvcnNbaV0oYXBpKTtcbiAgfVxufVxuXG5jb25zdCBjcmVhdGVSZXNwb25kZXJzID0gcHJvcHMgPT4gKHtcbiAgb25CZWZvcmVDYXB0dXJlOiB0ID0+IHtcbiAgICBjb25zdCBvbkJlZm9yZUNhcHVyZUNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgaWYgKHByb3BzLm9uQmVmb3JlQ2FwdHVyZSkge1xuICAgICAgICBwcm9wcy5vbkJlZm9yZUNhcHR1cmUodCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoUmVhY3QudmVyc2lvbi5zdGFydHNXaXRoKCcxNicpIHx8IFJlYWN0LnZlcnNpb24uc3RhcnRzV2l0aCgnMTcnKSkge1xuICAgICAgb25CZWZvcmVDYXB1cmVDYWxsYmFjaygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmbHVzaFN5bmMob25CZWZvcmVDYXB1cmVDYWxsYmFjayk7XG4gICAgfVxuICB9LFxuICBvbkJlZm9yZURyYWdTdGFydDogcHJvcHMub25CZWZvcmVEcmFnU3RhcnQsXG4gIG9uRHJhZ1N0YXJ0OiBwcm9wcy5vbkRyYWdTdGFydCxcbiAgb25EcmFnRW5kOiBwcm9wcy5vbkRyYWdFbmQsXG4gIG9uRHJhZ1VwZGF0ZTogcHJvcHMub25EcmFnVXBkYXRlXG59KTtcbmNvbnN0IGNyZWF0ZUF1dG9TY3JvbGxlck9wdGlvbnMgPSBwcm9wcyA9PiAoe1xuICAuLi5kZWZhdWx0QXV0b1Njcm9sbGVyT3B0aW9ucyxcbiAgLi4ucHJvcHMuYXV0b1Njcm9sbGVyT3B0aW9ucyxcbiAgZHVyYXRpb25EYW1wZW5pbmc6IHtcbiAgICAuLi5kZWZhdWx0QXV0b1Njcm9sbGVyT3B0aW9ucy5kdXJhdGlvbkRhbXBlbmluZyxcbiAgICAuLi5wcm9wcy5hdXRvU2Nyb2xsZXJPcHRpb25zXG4gIH1cbn0pO1xuZnVuY3Rpb24gZ2V0U3RvcmUobGF6eVJlZikge1xuICAhbGF6eVJlZi5jdXJyZW50ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ291bGQgbm90IGZpbmQgc3RvcmUgZnJvbSBsYXp5IHJlZicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgcmV0dXJuIGxhenlSZWYuY3VycmVudDtcbn1cbmZ1bmN0aW9uIEFwcChwcm9wcykge1xuICBjb25zdCB7XG4gICAgY29udGV4dElkLFxuICAgIHNldENhbGxiYWNrcyxcbiAgICBzZW5zb3JzLFxuICAgIG5vbmNlLFxuICAgIGRyYWdIYW5kbGVVc2FnZUluc3RydWN0aW9uc1xuICB9ID0gcHJvcHM7XG4gIGNvbnN0IGxhenlTdG9yZVJlZiA9IHVzZVJlZihudWxsKTtcbiAgdXNlU3RhcnR1cFZhbGlkYXRpb24oKTtcbiAgY29uc3QgbGFzdFByb3BzUmVmID0gdXNlUHJldmlvdXMocHJvcHMpO1xuICBjb25zdCBnZXRSZXNwb25kZXJzID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHJldHVybiBjcmVhdGVSZXNwb25kZXJzKGxhc3RQcm9wc1JlZi5jdXJyZW50KTtcbiAgfSwgW2xhc3RQcm9wc1JlZl0pO1xuICBjb25zdCBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHJldHVybiBjcmVhdGVBdXRvU2Nyb2xsZXJPcHRpb25zKGxhc3RQcm9wc1JlZi5jdXJyZW50KTtcbiAgfSwgW2xhc3RQcm9wc1JlZl0pO1xuICBjb25zdCBhbm5vdW5jZSA9IHVzZUFubm91bmNlcihjb250ZXh0SWQpO1xuICBjb25zdCBkcmFnSGFuZGxlVXNhZ2VJbnN0cnVjdGlvbnNJZCA9IHVzZUhpZGRlblRleHRFbGVtZW50KHtcbiAgICBjb250ZXh0SWQsXG4gICAgdGV4dDogZHJhZ0hhbmRsZVVzYWdlSW5zdHJ1Y3Rpb25zXG4gIH0pO1xuICBjb25zdCBzdHlsZU1hcnNoYWwgPSB1c2VTdHlsZU1hcnNoYWwoY29udGV4dElkLCBub25jZSk7XG4gIGNvbnN0IGxhenlEaXNwYXRjaCA9IHVzZUNhbGxiYWNrKGFjdGlvbiA9PiB7XG4gICAgZ2V0U3RvcmUobGF6eVN0b3JlUmVmKS5kaXNwYXRjaChhY3Rpb24pO1xuICB9LCBbXSk7XG4gIGNvbnN0IG1hcnNoYWxDYWxsYmFja3MgPSB1c2VNZW1vKCgpID0+IGJpbmRBY3Rpb25DcmVhdG9ycyh7XG4gICAgcHVibGlzaFdoaWxlRHJhZ2dpbmcsXG4gICAgdXBkYXRlRHJvcHBhYmxlU2Nyb2xsLFxuICAgIHVwZGF0ZURyb3BwYWJsZUlzRW5hYmxlZCxcbiAgICB1cGRhdGVEcm9wcGFibGVJc0NvbWJpbmVFbmFibGVkLFxuICAgIGNvbGxlY3Rpb25TdGFydGluZ1xuICB9LCBsYXp5RGlzcGF0Y2gpLCBbbGF6eURpc3BhdGNoXSk7XG4gIGNvbnN0IHJlZ2lzdHJ5ID0gdXNlUmVnaXN0cnkoKTtcbiAgY29uc3QgZGltZW5zaW9uTWFyc2hhbCA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIHJldHVybiBjcmVhdGVEaW1lbnNpb25NYXJzaGFsKHJlZ2lzdHJ5LCBtYXJzaGFsQ2FsbGJhY2tzKTtcbiAgfSwgW3JlZ2lzdHJ5LCBtYXJzaGFsQ2FsbGJhY2tzXSk7XG4gIGNvbnN0IGF1dG9TY3JvbGxlciA9IHVzZU1lbW8oKCkgPT4gY3JlYXRlQXV0b1Njcm9sbGVyKHtcbiAgICBzY3JvbGxXaW5kb3csXG4gICAgc2Nyb2xsRHJvcHBhYmxlOiBkaW1lbnNpb25NYXJzaGFsLnNjcm9sbERyb3BwYWJsZSxcbiAgICBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zLFxuICAgIC4uLmJpbmRBY3Rpb25DcmVhdG9ycyh7XG4gICAgICBtb3ZlXG4gICAgfSwgbGF6eURpc3BhdGNoKVxuICB9KSwgW2RpbWVuc2lvbk1hcnNoYWwuc2Nyb2xsRHJvcHBhYmxlLCBsYXp5RGlzcGF0Y2gsIGdldEF1dG9TY3JvbGxlck9wdGlvbnNdKTtcbiAgY29uc3QgZm9jdXNNYXJzaGFsID0gdXNlRm9jdXNNYXJzaGFsKGNvbnRleHRJZCk7XG4gIGNvbnN0IHN0b3JlID0gdXNlTWVtbygoKSA9PiBjcmVhdGVTdG9yZSh7XG4gICAgYW5ub3VuY2UsXG4gICAgYXV0b1Njcm9sbGVyLFxuICAgIGRpbWVuc2lvbk1hcnNoYWwsXG4gICAgZm9jdXNNYXJzaGFsLFxuICAgIGdldFJlc3BvbmRlcnMsXG4gICAgc3R5bGVNYXJzaGFsXG4gIH0pLCBbYW5ub3VuY2UsIGF1dG9TY3JvbGxlciwgZGltZW5zaW9uTWFyc2hhbCwgZm9jdXNNYXJzaGFsLCBnZXRSZXNwb25kZXJzLCBzdHlsZU1hcnNoYWxdKTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAobGF6eVN0b3JlUmVmLmN1cnJlbnQgJiYgbGF6eVN0b3JlUmVmLmN1cnJlbnQgIT09IHN0b3JlKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKCd1bmV4cGVjdGVkIHN0b3JlIGNoYW5nZScpIDogdm9pZCAwO1xuICAgIH1cbiAgfVxuICBsYXp5U3RvcmVSZWYuY3VycmVudCA9IHN0b3JlO1xuICBjb25zdCB0cnlSZXNldFN0b3JlID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGNvbnN0IGN1cnJlbnQgPSBnZXRTdG9yZShsYXp5U3RvcmVSZWYpO1xuICAgIGNvbnN0IHN0YXRlID0gY3VycmVudC5nZXRTdGF0ZSgpO1xuICAgIGlmIChzdGF0ZS5waGFzZSAhPT0gJ0lETEUnKSB7XG4gICAgICBjdXJyZW50LmRpc3BhdGNoKGZsdXNoKCkpO1xuICAgIH1cbiAgfSwgW10pO1xuICBjb25zdCBpc0RyYWdnaW5nID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGNvbnN0IHN0YXRlID0gZ2V0U3RvcmUobGF6eVN0b3JlUmVmKS5nZXRTdGF0ZSgpO1xuICAgIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0RST1BfQU5JTUFUSU5HJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0lETEUnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZS5pc0RyYWdnaW5nO1xuICB9LCBbXSk7XG4gIGNvbnN0IGFwcENhbGxiYWNrcyA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICBpc0RyYWdnaW5nLFxuICAgIHRyeUFib3J0OiB0cnlSZXNldFN0b3JlXG4gIH0pLCBbaXNEcmFnZ2luZywgdHJ5UmVzZXRTdG9yZV0pO1xuICBzZXRDYWxsYmFja3MoYXBwQ2FsbGJhY2tzKTtcbiAgY29uc3QgZ2V0Q2FuTGlmdCA9IHVzZUNhbGxiYWNrKGlkID0+IGNhblN0YXJ0RHJhZyhnZXRTdG9yZShsYXp5U3RvcmVSZWYpLmdldFN0YXRlKCksIGlkKSwgW10pO1xuICBjb25zdCBnZXRJc01vdmVtZW50QWxsb3dlZCA9IHVzZUNhbGxiYWNrKCgpID0+IGlzTW92ZW1lbnRBbGxvd2VkKGdldFN0b3JlKGxhenlTdG9yZVJlZikuZ2V0U3RhdGUoKSksIFtdKTtcbiAgY29uc3QgYXBwQ29udGV4dCA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICBtYXJzaGFsOiBkaW1lbnNpb25NYXJzaGFsLFxuICAgIGZvY3VzOiBmb2N1c01hcnNoYWwsXG4gICAgY29udGV4dElkLFxuICAgIGNhbkxpZnQ6IGdldENhbkxpZnQsXG4gICAgaXNNb3ZlbWVudEFsbG93ZWQ6IGdldElzTW92ZW1lbnRBbGxvd2VkLFxuICAgIGRyYWdIYW5kbGVVc2FnZUluc3RydWN0aW9uc0lkLFxuICAgIHJlZ2lzdHJ5XG4gIH0pLCBbY29udGV4dElkLCBkaW1lbnNpb25NYXJzaGFsLCBkcmFnSGFuZGxlVXNhZ2VJbnN0cnVjdGlvbnNJZCwgZm9jdXNNYXJzaGFsLCBnZXRDYW5MaWZ0LCBnZXRJc01vdmVtZW50QWxsb3dlZCwgcmVnaXN0cnldKTtcbiAgdXNlU2Vuc29yTWFyc2hhbCh7XG4gICAgY29udGV4dElkLFxuICAgIHN0b3JlLFxuICAgIHJlZ2lzdHJ5LFxuICAgIGN1c3RvbVNlbnNvcnM6IHNlbnNvcnMgfHwgbnVsbCxcbiAgICBlbmFibGVEZWZhdWx0U2Vuc29yczogcHJvcHMuZW5hYmxlRGVmYXVsdFNlbnNvcnMgIT09IGZhbHNlXG4gIH0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiB0cnlSZXNldFN0b3JlO1xuICB9LCBbdHJ5UmVzZXRTdG9yZV0pO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChBcHBDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGFwcENvbnRleHRcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChQcm92aWRlciwge1xuICAgIGNvbnRleHQ6IFN0b3JlQ29udGV4dCxcbiAgICBzdG9yZTogc3RvcmVcbiAgfSwgcHJvcHMuY2hpbGRyZW4pKTtcbn1cblxubGV0IGNvdW50ID0gMDtcbmZ1bmN0aW9uIHJlc2V0RGVwcmVjYXRlZFVuaXF1ZUNvbnRleHRJZCgpIHtcbiAgY291bnQgPSAwO1xufVxuZnVuY3Rpb24gdXNlRGVwcmVjYXRlZFVuaXF1ZUNvbnRleHRJZCgpIHtcbiAgcmV0dXJuIHVzZU1lbW8oKCkgPT4gYCR7Y291bnQrK31gLCBbXSk7XG59XG5mdW5jdGlvbiB1c2VVbmlxdWVDb250ZXh0SWQoKSB7XG4gIHJldHVybiBSZWFjdC51c2VJZCgpO1xufVxudmFyIHVzZVVuaXF1ZUNvbnRleHRJZCQxID0gJ3VzZUlkJyBpbiBSZWFjdCA/IHVzZVVuaXF1ZUNvbnRleHRJZCA6IHVzZURlcHJlY2F0ZWRVbmlxdWVDb250ZXh0SWQ7XG5cbmZ1bmN0aW9uIHJlc2V0U2VydmVyQ29udGV4dCgpIHtcbiAgaWYgKCd1c2VJZCcgaW4gUmVhY3QpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGBJdCBpcyBub3QgbmVjZXNzYXJ5IHRvIGNhbGwgcmVzZXRTZXJ2ZXJDb250ZXh0IHdoZW4gdXNpbmcgUmVhY3QgMTgrYCkgOiB2b2lkIDA7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJlc2V0RGVwcmVjYXRlZFVuaXF1ZUNvbnRleHRJZCgpO1xuICByZXNldERlcHJlY2F0ZWRVbmlxdWVJZCgpO1xufVxuZnVuY3Rpb24gRHJhZ0Ryb3BDb250ZXh0KHByb3BzKSB7XG4gIGNvbnN0IGNvbnRleHRJZCA9IHVzZVVuaXF1ZUNvbnRleHRJZCQxKCk7XG4gIGNvbnN0IGRyYWdIYW5kbGVVc2FnZUluc3RydWN0aW9ucyA9IHByb3BzLmRyYWdIYW5kbGVVc2FnZUluc3RydWN0aW9ucyB8fCBwcmVzZXQkMS5kcmFnSGFuZGxlVXNhZ2VJbnN0cnVjdGlvbnM7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KEVycm9yQm91bmRhcnksIG51bGwsIHNldENhbGxiYWNrcyA9PiBSZWFjdC5jcmVhdGVFbGVtZW50KEFwcCwge1xuICAgIG5vbmNlOiBwcm9wcy5ub25jZSxcbiAgICBjb250ZXh0SWQ6IGNvbnRleHRJZCxcbiAgICBzZXRDYWxsYmFja3M6IHNldENhbGxiYWNrcyxcbiAgICBkcmFnSGFuZGxlVXNhZ2VJbnN0cnVjdGlvbnM6IGRyYWdIYW5kbGVVc2FnZUluc3RydWN0aW9ucyxcbiAgICBlbmFibGVEZWZhdWx0U2Vuc29yczogcHJvcHMuZW5hYmxlRGVmYXVsdFNlbnNvcnMsXG4gICAgc2Vuc29yczogcHJvcHMuc2Vuc29ycyxcbiAgICBvbkJlZm9yZUNhcHR1cmU6IHByb3BzLm9uQmVmb3JlQ2FwdHVyZSxcbiAgICBvbkJlZm9yZURyYWdTdGFydDogcHJvcHMub25CZWZvcmVEcmFnU3RhcnQsXG4gICAgb25EcmFnU3RhcnQ6IHByb3BzLm9uRHJhZ1N0YXJ0LFxuICAgIG9uRHJhZ1VwZGF0ZTogcHJvcHMub25EcmFnVXBkYXRlLFxuICAgIG9uRHJhZ0VuZDogcHJvcHMub25EcmFnRW5kLFxuICAgIGF1dG9TY3JvbGxlck9wdGlvbnM6IHByb3BzLmF1dG9TY3JvbGxlck9wdGlvbnNcbiAgfSwgcHJvcHMuY2hpbGRyZW4pKTtcbn1cblxuY29uc3QgekluZGV4T3B0aW9ucyA9IHtcbiAgZHJhZ2dpbmc6IDUwMDAsXG4gIGRyb3BBbmltYXRpbmc6IDQ1MDBcbn07XG5jb25zdCBnZXREcmFnZ2luZ1RyYW5zaXRpb24gPSAoc2hvdWxkQW5pbWF0ZURyYWdNb3ZlbWVudCwgZHJvcHBpbmcpID0+IHtcbiAgaWYgKGRyb3BwaW5nKSB7XG4gICAgcmV0dXJuIHRyYW5zaXRpb25zLmRyb3AoZHJvcHBpbmcuZHVyYXRpb24pO1xuICB9XG4gIGlmIChzaG91bGRBbmltYXRlRHJhZ01vdmVtZW50KSB7XG4gICAgcmV0dXJuIHRyYW5zaXRpb25zLnNuYXA7XG4gIH1cbiAgcmV0dXJuIHRyYW5zaXRpb25zLmZsdWlkO1xufTtcbmNvbnN0IGdldERyYWdnaW5nT3BhY2l0eSA9IChpc0NvbWJpbmluZywgaXNEcm9wQW5pbWF0aW5nKSA9PiB7XG4gIGlmICghaXNDb21iaW5pbmcpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiBpc0Ryb3BBbmltYXRpbmcgPyBjb21iaW5lLm9wYWNpdHkuZHJvcCA6IGNvbWJpbmUub3BhY2l0eS5jb21iaW5pbmc7XG59O1xuY29uc3QgZ2V0U2hvdWxkRHJhZ2dpbmdBbmltYXRlID0gZHJhZ2dpbmcgPT4ge1xuICBpZiAoZHJhZ2dpbmcuZm9yY2VTaG91bGRBbmltYXRlICE9IG51bGwpIHtcbiAgICByZXR1cm4gZHJhZ2dpbmcuZm9yY2VTaG91bGRBbmltYXRlO1xuICB9XG4gIHJldHVybiBkcmFnZ2luZy5tb2RlID09PSAnU05BUCc7XG59O1xuZnVuY3Rpb24gZ2V0RHJhZ2dpbmdTdHlsZShkcmFnZ2luZykge1xuICBjb25zdCBkaW1lbnNpb24gPSBkcmFnZ2luZy5kaW1lbnNpb247XG4gIGNvbnN0IGJveCA9IGRpbWVuc2lvbi5jbGllbnQ7XG4gIGNvbnN0IHtcbiAgICBvZmZzZXQsXG4gICAgY29tYmluZVdpdGgsXG4gICAgZHJvcHBpbmdcbiAgfSA9IGRyYWdnaW5nO1xuICBjb25zdCBpc0NvbWJpbmluZyA9IEJvb2xlYW4oY29tYmluZVdpdGgpO1xuICBjb25zdCBzaG91bGRBbmltYXRlID0gZ2V0U2hvdWxkRHJhZ2dpbmdBbmltYXRlKGRyYWdnaW5nKTtcbiAgY29uc3QgaXNEcm9wQW5pbWF0aW5nID0gQm9vbGVhbihkcm9wcGluZyk7XG4gIGNvbnN0IHRyYW5zZm9ybSA9IGlzRHJvcEFuaW1hdGluZyA/IHRyYW5zZm9ybXMuZHJvcChvZmZzZXQsIGlzQ29tYmluaW5nKSA6IHRyYW5zZm9ybXMubW92ZVRvKG9mZnNldCk7XG4gIGNvbnN0IHN0eWxlID0ge1xuICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgIHRvcDogYm94Lm1hcmdpbkJveC50b3AsXG4gICAgbGVmdDogYm94Lm1hcmdpbkJveC5sZWZ0LFxuICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxuICAgIHdpZHRoOiBib3guYm9yZGVyQm94LndpZHRoLFxuICAgIGhlaWdodDogYm94LmJvcmRlckJveC5oZWlnaHQsXG4gICAgdHJhbnNpdGlvbjogZ2V0RHJhZ2dpbmdUcmFuc2l0aW9uKHNob3VsZEFuaW1hdGUsIGRyb3BwaW5nKSxcbiAgICB0cmFuc2Zvcm0sXG4gICAgb3BhY2l0eTogZ2V0RHJhZ2dpbmdPcGFjaXR5KGlzQ29tYmluaW5nLCBpc0Ryb3BBbmltYXRpbmcpLFxuICAgIHpJbmRleDogaXNEcm9wQW5pbWF0aW5nID8gekluZGV4T3B0aW9ucy5kcm9wQW5pbWF0aW5nIDogekluZGV4T3B0aW9ucy5kcmFnZ2luZyxcbiAgICBwb2ludGVyRXZlbnRzOiAnbm9uZSdcbiAgfTtcbiAgcmV0dXJuIHN0eWxlO1xufVxuZnVuY3Rpb24gZ2V0U2Vjb25kYXJ5U3R5bGUoc2Vjb25kYXJ5KSB7XG4gIHJldHVybiB7XG4gICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm1zLm1vdmVUbyhzZWNvbmRhcnkub2Zmc2V0KSxcbiAgICB0cmFuc2l0aW9uOiBzZWNvbmRhcnkuc2hvdWxkQW5pbWF0ZURpc3BsYWNlbWVudCA/IHVuZGVmaW5lZCA6ICdub25lJ1xuICB9O1xufVxuZnVuY3Rpb24gZ2V0U3R5bGUkMShtYXBwZWQpIHtcbiAgcmV0dXJuIG1hcHBlZC50eXBlID09PSAnRFJBR0dJTkcnID8gZ2V0RHJhZ2dpbmdTdHlsZShtYXBwZWQpIDogZ2V0U2Vjb25kYXJ5U3R5bGUobWFwcGVkKTtcbn1cblxuZnVuY3Rpb24gZ2V0RGltZW5zaW9uJDEoZGVzY3JpcHRvciwgZWwsIHdpbmRvd1Njcm9sbCA9IG9yaWdpbikge1xuICBjb25zdCBjb21wdXRlZFN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgY29uc3QgYm9yZGVyQm94ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGNvbnN0IGNsaWVudCA9IGNhbGN1bGF0ZUJveChib3JkZXJCb3gsIGNvbXB1dGVkU3R5bGVzKTtcbiAgY29uc3QgcGFnZSA9IHdpdGhTY3JvbGwoY2xpZW50LCB3aW5kb3dTY3JvbGwpO1xuICBjb25zdCBwbGFjZWhvbGRlciA9IHtcbiAgICBjbGllbnQsXG4gICAgdGFnTmFtZTogZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpLFxuICAgIGRpc3BsYXk6IGNvbXB1dGVkU3R5bGVzLmRpc3BsYXlcbiAgfTtcbiAgY29uc3QgZGlzcGxhY2VCeSA9IHtcbiAgICB4OiBjbGllbnQubWFyZ2luQm94LndpZHRoLFxuICAgIHk6IGNsaWVudC5tYXJnaW5Cb3guaGVpZ2h0XG4gIH07XG4gIGNvbnN0IGRpbWVuc2lvbiA9IHtcbiAgICBkZXNjcmlwdG9yLFxuICAgIHBsYWNlaG9sZGVyLFxuICAgIGRpc3BsYWNlQnksXG4gICAgY2xpZW50LFxuICAgIHBhZ2VcbiAgfTtcbiAgcmV0dXJuIGRpbWVuc2lvbjtcbn1cblxuZnVuY3Rpb24gdXNlRHJhZ2dhYmxlUHVibGlzaGVyKGFyZ3MpIHtcbiAgY29uc3QgdW5pcXVlSWQgPSB1c2VVbmlxdWVJZCQxKCdkcmFnZ2FibGUnKTtcbiAgY29uc3Qge1xuICAgIGRlc2NyaXB0b3IsXG4gICAgcmVnaXN0cnksXG4gICAgZ2V0RHJhZ2dhYmxlUmVmLFxuICAgIGNhbkRyYWdJbnRlcmFjdGl2ZUVsZW1lbnRzLFxuICAgIHNob3VsZFJlc3BlY3RGb3JjZVByZXNzLFxuICAgIGlzRW5hYmxlZFxuICB9ID0gYXJncztcbiAgY29uc3Qgb3B0aW9ucyA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICBjYW5EcmFnSW50ZXJhY3RpdmVFbGVtZW50cyxcbiAgICBzaG91bGRSZXNwZWN0Rm9yY2VQcmVzcyxcbiAgICBpc0VuYWJsZWRcbiAgfSksIFtjYW5EcmFnSW50ZXJhY3RpdmVFbGVtZW50cywgaXNFbmFibGVkLCBzaG91bGRSZXNwZWN0Rm9yY2VQcmVzc10pO1xuICBjb25zdCBnZXREaW1lbnNpb24gPSB1c2VDYWxsYmFjayh3aW5kb3dTY3JvbGwgPT4ge1xuICAgIGNvbnN0IGVsID0gZ2V0RHJhZ2dhYmxlUmVmKCk7XG4gICAgIWVsID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IGdldCBkaW1lbnNpb24gd2hlbiBubyByZWYgaXMgc2V0JykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIHJldHVybiBnZXREaW1lbnNpb24kMShkZXNjcmlwdG9yLCBlbCwgd2luZG93U2Nyb2xsKTtcbiAgfSwgW2Rlc2NyaXB0b3IsIGdldERyYWdnYWJsZVJlZl0pO1xuICBjb25zdCBlbnRyeSA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICB1bmlxdWVJZCxcbiAgICBkZXNjcmlwdG9yLFxuICAgIG9wdGlvbnMsXG4gICAgZ2V0RGltZW5zaW9uXG4gIH0pLCBbZGVzY3JpcHRvciwgZ2V0RGltZW5zaW9uLCBvcHRpb25zLCB1bmlxdWVJZF0pO1xuICBjb25zdCBwdWJsaXNoZWRSZWYgPSB1c2VSZWYoZW50cnkpO1xuICBjb25zdCBpc0ZpcnN0UHVibGlzaFJlZiA9IHVzZVJlZih0cnVlKTtcbiAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICByZWdpc3RyeS5kcmFnZ2FibGUucmVnaXN0ZXIocHVibGlzaGVkUmVmLmN1cnJlbnQpO1xuICAgIHJldHVybiAoKSA9PiByZWdpc3RyeS5kcmFnZ2FibGUudW5yZWdpc3RlcihwdWJsaXNoZWRSZWYuY3VycmVudCk7XG4gIH0sIFtyZWdpc3RyeS5kcmFnZ2FibGVdKTtcbiAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAoaXNGaXJzdFB1Ymxpc2hSZWYuY3VycmVudCkge1xuICAgICAgaXNGaXJzdFB1Ymxpc2hSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsYXN0ID0gcHVibGlzaGVkUmVmLmN1cnJlbnQ7XG4gICAgcHVibGlzaGVkUmVmLmN1cnJlbnQgPSBlbnRyeTtcbiAgICByZWdpc3RyeS5kcmFnZ2FibGUudXBkYXRlKGVudHJ5LCBsYXN0KTtcbiAgfSwgW2VudHJ5LCByZWdpc3RyeS5kcmFnZ2FibGVdKTtcbn1cblxudmFyIERyb3BwYWJsZUNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuXG5mdW5jdGlvbiBjaGVja0lzVmFsaWRJbm5lclJlZihlbCkge1xuICAhKGVsICYmIGlzSHRtbEVsZW1lbnQoZWwpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYFxuICAgIHByb3ZpZGVkLmlubmVyUmVmIGhhcyBub3QgYmVlbiBwcm92aWRlZCB3aXRoIGEgSFRNTEVsZW1lbnQuXG5cbiAgICBZb3UgY2FuIGZpbmQgYSBndWlkZSBvbiB1c2luZyB0aGUgaW5uZXJSZWYgY2FsbGJhY2sgZnVuY3Rpb25zIGF0OlxuICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9oZWxsby1wYW5nZWEvZG5kL2Jsb2IvbWFpbi9kb2NzL2d1aWRlcy91c2luZy1pbm5lci1yZWYubWRcbiAgYCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xufVxuXG5mdW5jdGlvbiB1c2VWYWxpZGF0aW9uJDEocHJvcHMsIGNvbnRleHRJZCwgZ2V0UmVmKSB7XG4gIHVzZURldlNldHVwV2FybmluZygoKSA9PiB7XG4gICAgZnVuY3Rpb24gcHJlZml4KGlkKSB7XG4gICAgICByZXR1cm4gYERyYWdnYWJsZVtpZDogJHtpZH1dOiBgO1xuICAgIH1cbiAgICBjb25zdCBpZCA9IHByb3BzLmRyYWdnYWJsZUlkO1xuICAgICFpZCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0RyYWdnYWJsZSByZXF1aXJlcyBhIGRyYWdnYWJsZUlkJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgICEodHlwZW9mIGlkID09PSAnc3RyaW5nJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGBEcmFnZ2FibGUgcmVxdWlyZXMgYSBbc3RyaW5nXSBkcmFnZ2FibGVJZC5cbiAgICAgIFByb3ZpZGVkOiBbdHlwZTogJHt0eXBlb2YgaWR9XSAodmFsdWU6ICR7aWR9KWApIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAhTnVtYmVyLmlzSW50ZWdlcihwcm9wcy5pbmRleCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGAke3ByZWZpeChpZCl9IHJlcXVpcmVzIGFuIGludGVnZXIgaW5kZXggcHJvcGApIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBpZiAocHJvcHMubWFwcGVkLnR5cGUgPT09ICdEUkFHR0lORycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2hlY2tJc1ZhbGlkSW5uZXJSZWYoZ2V0UmVmKCkpO1xuICAgIGlmIChwcm9wcy5pc0VuYWJsZWQpIHtcbiAgICAgICFmaW5kRHJhZ0hhbmRsZShjb250ZXh0SWQsIGlkKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYCR7cHJlZml4KGlkKX0gVW5hYmxlIHRvIGZpbmQgZHJhZyBoYW5kbGVgKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHVzZUNsb25lUHJvcFZhbGlkYXRpb24oaXNDbG9uZSkge1xuICB1c2VEZXYoKCkgPT4ge1xuICAgIGNvbnN0IGluaXRpYWxSZWYgPSB1c2VSZWYoaXNDbG9uZSk7XG4gICAgdXNlRGV2U2V0dXBXYXJuaW5nKCgpID0+IHtcbiAgICAgICEoaXNDbG9uZSA9PT0gaW5pdGlhbFJlZi5jdXJyZW50KSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0RyYWdnYWJsZSBpc0Nsb25lIHByb3AgdmFsdWUgY2hhbmdlZCBkdXJpbmcgY29tcG9uZW50IGxpZmUnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgfSwgW2lzQ2xvbmVdKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHVzZVJlcXVpcmVkQ29udGV4dChDb250ZXh0KSB7XG4gIGNvbnN0IHJlc3VsdCA9IHVzZUNvbnRleHQoQ29udGV4dCk7XG4gICFyZXN1bHQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDb3VsZCBub3QgZmluZCByZXF1aXJlZCBjb250ZXh0JykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBwcmV2ZW50SHRtbDVEbmQoZXZlbnQpIHtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbn1cbmNvbnN0IERyYWdnYWJsZSA9IHByb3BzID0+IHtcbiAgY29uc3QgcmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBzZXRSZWYgPSB1c2VDYWxsYmFjaygoZWwgPSBudWxsKSA9PiB7XG4gICAgcmVmLmN1cnJlbnQgPSBlbDtcbiAgfSwgW10pO1xuICBjb25zdCBnZXRSZWYgPSB1c2VDYWxsYmFjaygoKSA9PiByZWYuY3VycmVudCwgW10pO1xuICBjb25zdCB7XG4gICAgY29udGV4dElkLFxuICAgIGRyYWdIYW5kbGVVc2FnZUluc3RydWN0aW9uc0lkLFxuICAgIHJlZ2lzdHJ5XG4gIH0gPSB1c2VSZXF1aXJlZENvbnRleHQoQXBwQ29udGV4dCk7XG4gIGNvbnN0IHtcbiAgICB0eXBlLFxuICAgIGRyb3BwYWJsZUlkXG4gIH0gPSB1c2VSZXF1aXJlZENvbnRleHQoRHJvcHBhYmxlQ29udGV4dCk7XG4gIGNvbnN0IGRlc2NyaXB0b3IgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgaWQ6IHByb3BzLmRyYWdnYWJsZUlkLFxuICAgIGluZGV4OiBwcm9wcy5pbmRleCxcbiAgICB0eXBlLFxuICAgIGRyb3BwYWJsZUlkXG4gIH0pLCBbcHJvcHMuZHJhZ2dhYmxlSWQsIHByb3BzLmluZGV4LCB0eXBlLCBkcm9wcGFibGVJZF0pO1xuICBjb25zdCB7XG4gICAgY2hpbGRyZW4sXG4gICAgZHJhZ2dhYmxlSWQsXG4gICAgaXNFbmFibGVkLFxuICAgIHNob3VsZFJlc3BlY3RGb3JjZVByZXNzLFxuICAgIGNhbkRyYWdJbnRlcmFjdGl2ZUVsZW1lbnRzLFxuICAgIGlzQ2xvbmUsXG4gICAgbWFwcGVkLFxuICAgIGRyb3BBbmltYXRpb25GaW5pc2hlZDogZHJvcEFuaW1hdGlvbkZpbmlzaGVkQWN0aW9uXG4gIH0gPSBwcm9wcztcbiAgdXNlVmFsaWRhdGlvbiQxKHByb3BzLCBjb250ZXh0SWQsIGdldFJlZik7XG4gIHVzZUNsb25lUHJvcFZhbGlkYXRpb24oaXNDbG9uZSk7XG4gIGlmICghaXNDbG9uZSkge1xuICAgIGNvbnN0IGZvclB1Ymxpc2hlciA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICAgIGRlc2NyaXB0b3IsXG4gICAgICByZWdpc3RyeSxcbiAgICAgIGdldERyYWdnYWJsZVJlZjogZ2V0UmVmLFxuICAgICAgY2FuRHJhZ0ludGVyYWN0aXZlRWxlbWVudHMsXG4gICAgICBzaG91bGRSZXNwZWN0Rm9yY2VQcmVzcyxcbiAgICAgIGlzRW5hYmxlZFxuICAgIH0pLCBbZGVzY3JpcHRvciwgcmVnaXN0cnksIGdldFJlZiwgY2FuRHJhZ0ludGVyYWN0aXZlRWxlbWVudHMsIHNob3VsZFJlc3BlY3RGb3JjZVByZXNzLCBpc0VuYWJsZWRdKTtcbiAgICB1c2VEcmFnZ2FibGVQdWJsaXNoZXIoZm9yUHVibGlzaGVyKTtcbiAgfVxuICBjb25zdCBkcmFnSGFuZGxlUHJvcHMgPSB1c2VNZW1vKCgpID0+IGlzRW5hYmxlZCA/IHtcbiAgICB0YWJJbmRleDogMCxcbiAgICByb2xlOiAnYnV0dG9uJyxcbiAgICAnYXJpYS1kZXNjcmliZWRieSc6IGRyYWdIYW5kbGVVc2FnZUluc3RydWN0aW9uc0lkLFxuICAgICdkYXRhLXJmZC1kcmFnLWhhbmRsZS1kcmFnZ2FibGUtaWQnOiBkcmFnZ2FibGVJZCxcbiAgICAnZGF0YS1yZmQtZHJhZy1oYW5kbGUtY29udGV4dC1pZCc6IGNvbnRleHRJZCxcbiAgICBkcmFnZ2FibGU6IGZhbHNlLFxuICAgIG9uRHJhZ1N0YXJ0OiBwcmV2ZW50SHRtbDVEbmRcbiAgfSA6IG51bGwsIFtjb250ZXh0SWQsIGRyYWdIYW5kbGVVc2FnZUluc3RydWN0aW9uc0lkLCBkcmFnZ2FibGVJZCwgaXNFbmFibGVkXSk7XG4gIGNvbnN0IG9uTW92ZUVuZCA9IHVzZUNhbGxiYWNrKGV2ZW50ID0+IHtcbiAgICBpZiAobWFwcGVkLnR5cGUgIT09ICdEUkFHR0lORycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFtYXBwZWQuZHJvcHBpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGV2ZW50LnByb3BlcnR5TmFtZSAhPT0gJ3RyYW5zZm9ybScpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKFJlYWN0LnZlcnNpb24uc3RhcnRzV2l0aCgnMTYnKSB8fCBSZWFjdC52ZXJzaW9uLnN0YXJ0c1dpdGgoJzE3JykpIHtcbiAgICAgIGRyb3BBbmltYXRpb25GaW5pc2hlZEFjdGlvbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmbHVzaFN5bmMoZHJvcEFuaW1hdGlvbkZpbmlzaGVkQWN0aW9uKTtcbiAgICB9XG4gIH0sIFtkcm9wQW5pbWF0aW9uRmluaXNoZWRBY3Rpb24sIG1hcHBlZF0pO1xuICBjb25zdCBwcm92aWRlZCA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IHN0eWxlID0gZ2V0U3R5bGUkMShtYXBwZWQpO1xuICAgIGNvbnN0IG9uVHJhbnNpdGlvbkVuZCA9IG1hcHBlZC50eXBlID09PSAnRFJBR0dJTkcnICYmIG1hcHBlZC5kcm9wcGluZyA/IG9uTW92ZUVuZCA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICBpbm5lclJlZjogc2V0UmVmLFxuICAgICAgZHJhZ2dhYmxlUHJvcHM6IHtcbiAgICAgICAgJ2RhdGEtcmZkLWRyYWdnYWJsZS1jb250ZXh0LWlkJzogY29udGV4dElkLFxuICAgICAgICAnZGF0YS1yZmQtZHJhZ2dhYmxlLWlkJzogZHJhZ2dhYmxlSWQsXG4gICAgICAgIHN0eWxlLFxuICAgICAgICBvblRyYW5zaXRpb25FbmRcbiAgICAgIH0sXG4gICAgICBkcmFnSGFuZGxlUHJvcHNcbiAgICB9O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sIFtjb250ZXh0SWQsIGRyYWdIYW5kbGVQcm9wcywgZHJhZ2dhYmxlSWQsIG1hcHBlZCwgb25Nb3ZlRW5kLCBzZXRSZWZdKTtcbiAgY29uc3QgcnVicmljID0gdXNlTWVtbygoKSA9PiAoe1xuICAgIGRyYWdnYWJsZUlkOiBkZXNjcmlwdG9yLmlkLFxuICAgIHR5cGU6IGRlc2NyaXB0b3IudHlwZSxcbiAgICBzb3VyY2U6IHtcbiAgICAgIGluZGV4OiBkZXNjcmlwdG9yLmluZGV4LFxuICAgICAgZHJvcHBhYmxlSWQ6IGRlc2NyaXB0b3IuZHJvcHBhYmxlSWRcbiAgICB9XG4gIH0pLCBbZGVzY3JpcHRvci5kcm9wcGFibGVJZCwgZGVzY3JpcHRvci5pZCwgZGVzY3JpcHRvci5pbmRleCwgZGVzY3JpcHRvci50eXBlXSk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCBjaGlsZHJlbihwcm92aWRlZCwgbWFwcGVkLnNuYXBzaG90LCBydWJyaWMpKTtcbn07XG52YXIgRHJhZ2dhYmxlJDEgPSBEcmFnZ2FibGU7XG5cbnZhciBpc1N0cmljdEVxdWFsID0gKChhLCBiKSA9PiBhID09PSBiKTtcblxudmFyIHdoYXRJc0RyYWdnZWRPdmVyRnJvbVJlc3VsdCA9IChyZXN1bHQgPT4ge1xuICBjb25zdCB7XG4gICAgY29tYmluZSxcbiAgICBkZXN0aW5hdGlvblxuICB9ID0gcmVzdWx0O1xuICBpZiAoZGVzdGluYXRpb24pIHtcbiAgICByZXR1cm4gZGVzdGluYXRpb24uZHJvcHBhYmxlSWQ7XG4gIH1cbiAgaWYgKGNvbWJpbmUpIHtcbiAgICByZXR1cm4gY29tYmluZS5kcm9wcGFibGVJZDtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn0pO1xuXG5jb25zdCBnZXRDb21iaW5lV2l0aEZyb21SZXN1bHQgPSByZXN1bHQgPT4ge1xuICByZXR1cm4gcmVzdWx0LmNvbWJpbmUgPyByZXN1bHQuY29tYmluZS5kcmFnZ2FibGVJZCA6IG51bGw7XG59O1xuY29uc3QgZ2V0Q29tYmluZVdpdGhGcm9tSW1wYWN0ID0gaW1wYWN0ID0+IHtcbiAgcmV0dXJuIGltcGFjdC5hdCAmJiBpbXBhY3QuYXQudHlwZSA9PT0gJ0NPTUJJTkUnID8gaW1wYWN0LmF0LmNvbWJpbmUuZHJhZ2dhYmxlSWQgOiBudWxsO1xufTtcbmZ1bmN0aW9uIGdldERyYWdnYWJsZVNlbGVjdG9yKCkge1xuICBjb25zdCBtZW1vaXplZE9mZnNldCA9IG1lbW9pemVPbmUoKHgsIHkpID0+ICh7XG4gICAgeCxcbiAgICB5XG4gIH0pKTtcbiAgY29uc3QgZ2V0TWVtb2l6ZWRTbmFwc2hvdCA9IG1lbW9pemVPbmUoKG1vZGUsIGlzQ2xvbmUsIGRyYWdnaW5nT3ZlciA9IG51bGwsIGNvbWJpbmVXaXRoID0gbnVsbCwgZHJvcHBpbmcgPSBudWxsKSA9PiAoe1xuICAgIGlzRHJhZ2dpbmc6IHRydWUsXG4gICAgaXNDbG9uZSxcbiAgICBpc0Ryb3BBbmltYXRpbmc6IEJvb2xlYW4oZHJvcHBpbmcpLFxuICAgIGRyb3BBbmltYXRpb246IGRyb3BwaW5nLFxuICAgIG1vZGUsXG4gICAgZHJhZ2dpbmdPdmVyLFxuICAgIGNvbWJpbmVXaXRoLFxuICAgIGNvbWJpbmVUYXJnZXRGb3I6IG51bGxcbiAgfSkpO1xuICBjb25zdCBnZXRNZW1vaXplZFByb3BzID0gbWVtb2l6ZU9uZSgob2Zmc2V0LCBtb2RlLCBkaW1lbnNpb24sIGlzQ2xvbmUsIGRyYWdnaW5nT3ZlciA9IG51bGwsIGNvbWJpbmVXaXRoID0gbnVsbCwgZm9yY2VTaG91bGRBbmltYXRlID0gbnVsbCkgPT4gKHtcbiAgICBtYXBwZWQ6IHtcbiAgICAgIHR5cGU6ICdEUkFHR0lORycsXG4gICAgICBkcm9wcGluZzogbnVsbCxcbiAgICAgIGRyYWdnaW5nT3ZlcixcbiAgICAgIGNvbWJpbmVXaXRoLFxuICAgICAgbW9kZSxcbiAgICAgIG9mZnNldCxcbiAgICAgIGRpbWVuc2lvbixcbiAgICAgIGZvcmNlU2hvdWxkQW5pbWF0ZSxcbiAgICAgIHNuYXBzaG90OiBnZXRNZW1vaXplZFNuYXBzaG90KG1vZGUsIGlzQ2xvbmUsIGRyYWdnaW5nT3ZlciwgY29tYmluZVdpdGgsIG51bGwpXG4gICAgfVxuICB9KSk7XG4gIGNvbnN0IHNlbGVjdG9yID0gKHN0YXRlLCBvd25Qcm9wcykgPT4ge1xuICAgIGlmIChpc0RyYWdnaW5nKHN0YXRlKSkge1xuICAgICAgaWYgKHN0YXRlLmNyaXRpY2FsLmRyYWdnYWJsZS5pZCAhPT0gb3duUHJvcHMuZHJhZ2dhYmxlSWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBjb25zdCBvZmZzZXQgPSBzdGF0ZS5jdXJyZW50LmNsaWVudC5vZmZzZXQ7XG4gICAgICBjb25zdCBkaW1lbnNpb24gPSBzdGF0ZS5kaW1lbnNpb25zLmRyYWdnYWJsZXNbb3duUHJvcHMuZHJhZ2dhYmxlSWRdO1xuICAgICAgY29uc3QgZHJhZ2dpbmdPdmVyID0gd2hhdElzRHJhZ2dlZE92ZXIoc3RhdGUuaW1wYWN0KTtcbiAgICAgIGNvbnN0IGNvbWJpbmVXaXRoID0gZ2V0Q29tYmluZVdpdGhGcm9tSW1wYWN0KHN0YXRlLmltcGFjdCk7XG4gICAgICBjb25zdCBmb3JjZVNob3VsZEFuaW1hdGUgPSBzdGF0ZS5mb3JjZVNob3VsZEFuaW1hdGU7XG4gICAgICByZXR1cm4gZ2V0TWVtb2l6ZWRQcm9wcyhtZW1vaXplZE9mZnNldChvZmZzZXQueCwgb2Zmc2V0LnkpLCBzdGF0ZS5tb3ZlbWVudE1vZGUsIGRpbWVuc2lvbiwgb3duUHJvcHMuaXNDbG9uZSwgZHJhZ2dpbmdPdmVyLCBjb21iaW5lV2l0aCwgZm9yY2VTaG91bGRBbmltYXRlKTtcbiAgICB9XG4gICAgaWYgKHN0YXRlLnBoYXNlID09PSAnRFJPUF9BTklNQVRJTkcnKSB7XG4gICAgICBjb25zdCBjb21wbGV0ZWQgPSBzdGF0ZS5jb21wbGV0ZWQ7XG4gICAgICBpZiAoY29tcGxldGVkLnJlc3VsdC5kcmFnZ2FibGVJZCAhPT0gb3duUHJvcHMuZHJhZ2dhYmxlSWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBjb25zdCBpc0Nsb25lID0gb3duUHJvcHMuaXNDbG9uZTtcbiAgICAgIGNvbnN0IGRpbWVuc2lvbiA9IHN0YXRlLmRpbWVuc2lvbnMuZHJhZ2dhYmxlc1tvd25Qcm9wcy5kcmFnZ2FibGVJZF07XG4gICAgICBjb25zdCByZXN1bHQgPSBjb21wbGV0ZWQucmVzdWx0O1xuICAgICAgY29uc3QgbW9kZSA9IHJlc3VsdC5tb2RlO1xuICAgICAgY29uc3QgZHJhZ2dpbmdPdmVyID0gd2hhdElzRHJhZ2dlZE92ZXJGcm9tUmVzdWx0KHJlc3VsdCk7XG4gICAgICBjb25zdCBjb21iaW5lV2l0aCA9IGdldENvbWJpbmVXaXRoRnJvbVJlc3VsdChyZXN1bHQpO1xuICAgICAgY29uc3QgZHVyYXRpb24gPSBzdGF0ZS5kcm9wRHVyYXRpb247XG4gICAgICBjb25zdCBkcm9wcGluZyA9IHtcbiAgICAgICAgZHVyYXRpb24sXG4gICAgICAgIGN1cnZlOiBjdXJ2ZXMuZHJvcCxcbiAgICAgICAgbW92ZVRvOiBzdGF0ZS5uZXdIb21lQ2xpZW50T2Zmc2V0LFxuICAgICAgICBvcGFjaXR5OiBjb21iaW5lV2l0aCA/IGNvbWJpbmUub3BhY2l0eS5kcm9wIDogbnVsbCxcbiAgICAgICAgc2NhbGU6IGNvbWJpbmVXaXRoID8gY29tYmluZS5zY2FsZS5kcm9wIDogbnVsbFxuICAgICAgfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1hcHBlZDoge1xuICAgICAgICAgIHR5cGU6ICdEUkFHR0lORycsXG4gICAgICAgICAgb2Zmc2V0OiBzdGF0ZS5uZXdIb21lQ2xpZW50T2Zmc2V0LFxuICAgICAgICAgIGRpbWVuc2lvbixcbiAgICAgICAgICBkcm9wcGluZyxcbiAgICAgICAgICBkcmFnZ2luZ092ZXIsXG4gICAgICAgICAgY29tYmluZVdpdGgsXG4gICAgICAgICAgbW9kZSxcbiAgICAgICAgICBmb3JjZVNob3VsZEFuaW1hdGU6IG51bGwsXG4gICAgICAgICAgc25hcHNob3Q6IGdldE1lbW9pemVkU25hcHNob3QobW9kZSwgaXNDbG9uZSwgZHJhZ2dpbmdPdmVyLCBjb21iaW5lV2l0aCwgZHJvcHBpbmcpXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9O1xuICByZXR1cm4gc2VsZWN0b3I7XG59XG5mdW5jdGlvbiBnZXRTZWNvbmRhcnlTbmFwc2hvdChjb21iaW5lVGFyZ2V0Rm9yID0gbnVsbCkge1xuICByZXR1cm4ge1xuICAgIGlzRHJhZ2dpbmc6IGZhbHNlLFxuICAgIGlzRHJvcEFuaW1hdGluZzogZmFsc2UsXG4gICAgaXNDbG9uZTogZmFsc2UsXG4gICAgZHJvcEFuaW1hdGlvbjogbnVsbCxcbiAgICBtb2RlOiBudWxsLFxuICAgIGRyYWdnaW5nT3ZlcjogbnVsbCxcbiAgICBjb21iaW5lVGFyZ2V0Rm9yLFxuICAgIGNvbWJpbmVXaXRoOiBudWxsXG4gIH07XG59XG5jb25zdCBhdFJlc3QgPSB7XG4gIG1hcHBlZDoge1xuICAgIHR5cGU6ICdTRUNPTkRBUlknLFxuICAgIG9mZnNldDogb3JpZ2luLFxuICAgIGNvbWJpbmVUYXJnZXRGb3I6IG51bGwsXG4gICAgc2hvdWxkQW5pbWF0ZURpc3BsYWNlbWVudDogdHJ1ZSxcbiAgICBzbmFwc2hvdDogZ2V0U2Vjb25kYXJ5U25hcHNob3QobnVsbClcbiAgfVxufTtcbmZ1bmN0aW9uIGdldFNlY29uZGFyeVNlbGVjdG9yKCkge1xuICBjb25zdCBtZW1vaXplZE9mZnNldCA9IG1lbW9pemVPbmUoKHgsIHkpID0+ICh7XG4gICAgeCxcbiAgICB5XG4gIH0pKTtcbiAgY29uc3QgZ2V0TWVtb2l6ZWRTbmFwc2hvdCA9IG1lbW9pemVPbmUoZ2V0U2Vjb25kYXJ5U25hcHNob3QpO1xuICBjb25zdCBnZXRNZW1vaXplZFByb3BzID0gbWVtb2l6ZU9uZSgob2Zmc2V0LCBjb21iaW5lVGFyZ2V0Rm9yID0gbnVsbCwgc2hvdWxkQW5pbWF0ZURpc3BsYWNlbWVudCkgPT4gKHtcbiAgICBtYXBwZWQ6IHtcbiAgICAgIHR5cGU6ICdTRUNPTkRBUlknLFxuICAgICAgb2Zmc2V0LFxuICAgICAgY29tYmluZVRhcmdldEZvcixcbiAgICAgIHNob3VsZEFuaW1hdGVEaXNwbGFjZW1lbnQsXG4gICAgICBzbmFwc2hvdDogZ2V0TWVtb2l6ZWRTbmFwc2hvdChjb21iaW5lVGFyZ2V0Rm9yKVxuICAgIH1cbiAgfSkpO1xuICBjb25zdCBnZXRGYWxsYmFjayA9IGNvbWJpbmVUYXJnZXRGb3IgPT4ge1xuICAgIHJldHVybiBjb21iaW5lVGFyZ2V0Rm9yID8gZ2V0TWVtb2l6ZWRQcm9wcyhvcmlnaW4sIGNvbWJpbmVUYXJnZXRGb3IsIHRydWUpIDogbnVsbDtcbiAgfTtcbiAgY29uc3QgZ2V0UHJvcHMgPSAob3duSWQsIGRyYWdnaW5nSWQsIGltcGFjdCwgYWZ0ZXJDcml0aWNhbCkgPT4ge1xuICAgIGNvbnN0IHZpc3VhbERpc3BsYWNlbWVudCA9IGltcGFjdC5kaXNwbGFjZWQudmlzaWJsZVtvd25JZF07XG4gICAgY29uc3QgaXNBZnRlckNyaXRpY2FsSW5WaXJ0dWFsTGlzdCA9IEJvb2xlYW4oYWZ0ZXJDcml0aWNhbC5pblZpcnR1YWxMaXN0ICYmIGFmdGVyQ3JpdGljYWwuZWZmZWN0ZWRbb3duSWRdKTtcbiAgICBjb25zdCBjb21iaW5lID0gdHJ5R2V0Q29tYmluZShpbXBhY3QpO1xuICAgIGNvbnN0IGNvbWJpbmVUYXJnZXRGb3IgPSBjb21iaW5lICYmIGNvbWJpbmUuZHJhZ2dhYmxlSWQgPT09IG93bklkID8gZHJhZ2dpbmdJZCA6IG51bGw7XG4gICAgaWYgKCF2aXN1YWxEaXNwbGFjZW1lbnQpIHtcbiAgICAgIGlmICghaXNBZnRlckNyaXRpY2FsSW5WaXJ0dWFsTGlzdCkge1xuICAgICAgICByZXR1cm4gZ2V0RmFsbGJhY2soY29tYmluZVRhcmdldEZvcik7XG4gICAgICB9XG4gICAgICBpZiAoaW1wYWN0LmRpc3BsYWNlZC5pbnZpc2libGVbb3duSWRdKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgY29uc3QgY2hhbmdlID0gbmVnYXRlKGFmdGVyQ3JpdGljYWwuZGlzcGxhY2VkQnkucG9pbnQpO1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gbWVtb2l6ZWRPZmZzZXQoY2hhbmdlLngsIGNoYW5nZS55KTtcbiAgICAgIHJldHVybiBnZXRNZW1vaXplZFByb3BzKG9mZnNldCwgY29tYmluZVRhcmdldEZvciwgdHJ1ZSk7XG4gICAgfVxuICAgIGlmIChpc0FmdGVyQ3JpdGljYWxJblZpcnR1YWxMaXN0KSB7XG4gICAgICByZXR1cm4gZ2V0RmFsbGJhY2soY29tYmluZVRhcmdldEZvcik7XG4gICAgfVxuICAgIGNvbnN0IGRpc3BsYWNlQnkgPSBpbXBhY3QuZGlzcGxhY2VkQnkucG9pbnQ7XG4gICAgY29uc3Qgb2Zmc2V0ID0gbWVtb2l6ZWRPZmZzZXQoZGlzcGxhY2VCeS54LCBkaXNwbGFjZUJ5LnkpO1xuICAgIHJldHVybiBnZXRNZW1vaXplZFByb3BzKG9mZnNldCwgY29tYmluZVRhcmdldEZvciwgdmlzdWFsRGlzcGxhY2VtZW50LnNob3VsZEFuaW1hdGUpO1xuICB9O1xuICBjb25zdCBzZWxlY3RvciA9IChzdGF0ZSwgb3duUHJvcHMpID0+IHtcbiAgICBpZiAoaXNEcmFnZ2luZyhzdGF0ZSkpIHtcbiAgICAgIGlmIChzdGF0ZS5jcml0aWNhbC5kcmFnZ2FibGUuaWQgPT09IG93blByb3BzLmRyYWdnYWJsZUlkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdldFByb3BzKG93blByb3BzLmRyYWdnYWJsZUlkLCBzdGF0ZS5jcml0aWNhbC5kcmFnZ2FibGUuaWQsIHN0YXRlLmltcGFjdCwgc3RhdGUuYWZ0ZXJDcml0aWNhbCk7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0RST1BfQU5JTUFUSU5HJykge1xuICAgICAgY29uc3QgY29tcGxldGVkID0gc3RhdGUuY29tcGxldGVkO1xuICAgICAgaWYgKGNvbXBsZXRlZC5yZXN1bHQuZHJhZ2dhYmxlSWQgPT09IG93blByb3BzLmRyYWdnYWJsZUlkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdldFByb3BzKG93blByb3BzLmRyYWdnYWJsZUlkLCBjb21wbGV0ZWQucmVzdWx0LmRyYWdnYWJsZUlkLCBjb21wbGV0ZWQuaW1wYWN0LCBjb21wbGV0ZWQuYWZ0ZXJDcml0aWNhbCk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9O1xuICByZXR1cm4gc2VsZWN0b3I7XG59XG5jb25zdCBtYWtlTWFwU3RhdGVUb1Byb3BzJDEgPSAoKSA9PiB7XG4gIGNvbnN0IGRyYWdnaW5nU2VsZWN0b3IgPSBnZXREcmFnZ2FibGVTZWxlY3RvcigpO1xuICBjb25zdCBzZWNvbmRhcnlTZWxlY3RvciA9IGdldFNlY29uZGFyeVNlbGVjdG9yKCk7XG4gIGNvbnN0IHNlbGVjdG9yID0gKHN0YXRlLCBvd25Qcm9wcykgPT4gZHJhZ2dpbmdTZWxlY3RvcihzdGF0ZSwgb3duUHJvcHMpIHx8IHNlY29uZGFyeVNlbGVjdG9yKHN0YXRlLCBvd25Qcm9wcykgfHwgYXRSZXN0O1xuICByZXR1cm4gc2VsZWN0b3I7XG59O1xuY29uc3QgbWFwRGlzcGF0Y2hUb1Byb3BzJDEgPSB7XG4gIGRyb3BBbmltYXRpb25GaW5pc2hlZDogZHJvcEFuaW1hdGlvbkZpbmlzaGVkXG59O1xuY29uc3QgQ29ubmVjdGVkRHJhZ2dhYmxlID0gY29ubmVjdChtYWtlTWFwU3RhdGVUb1Byb3BzJDEsIG1hcERpc3BhdGNoVG9Qcm9wcyQxLCBudWxsLCB7XG4gIGNvbnRleHQ6IFN0b3JlQ29udGV4dCxcbiAgYXJlU3RhdGVQcm9wc0VxdWFsOiBpc1N0cmljdEVxdWFsXG59KShEcmFnZ2FibGUkMSk7XG52YXIgQ29ubmVjdGVkRHJhZ2dhYmxlJDEgPSBDb25uZWN0ZWREcmFnZ2FibGU7XG5cbmZ1bmN0aW9uIFByaXZhdGVEcmFnZ2FibGUocHJvcHMpIHtcbiAgY29uc3QgZHJvcHBhYmxlQ29udGV4dCA9IHVzZVJlcXVpcmVkQ29udGV4dChEcm9wcGFibGVDb250ZXh0KTtcbiAgY29uc3QgaXNVc2luZ0Nsb25lRm9yID0gZHJvcHBhYmxlQ29udGV4dC5pc1VzaW5nQ2xvbmVGb3I7XG4gIGlmIChpc1VzaW5nQ2xvbmVGb3IgPT09IHByb3BzLmRyYWdnYWJsZUlkICYmICFwcm9wcy5pc0Nsb25lKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29ubmVjdGVkRHJhZ2dhYmxlJDEsIHByb3BzKTtcbn1cbmZ1bmN0aW9uIFB1YmxpY0RyYWdnYWJsZShwcm9wcykge1xuICBjb25zdCBpc0VuYWJsZWQgPSB0eXBlb2YgcHJvcHMuaXNEcmFnRGlzYWJsZWQgPT09ICdib29sZWFuJyA/ICFwcm9wcy5pc0RyYWdEaXNhYmxlZCA6IHRydWU7XG4gIGNvbnN0IGNhbkRyYWdJbnRlcmFjdGl2ZUVsZW1lbnRzID0gQm9vbGVhbihwcm9wcy5kaXNhYmxlSW50ZXJhY3RpdmVFbGVtZW50QmxvY2tpbmcpO1xuICBjb25zdCBzaG91bGRSZXNwZWN0Rm9yY2VQcmVzcyA9IEJvb2xlYW4ocHJvcHMuc2hvdWxkUmVzcGVjdEZvcmNlUHJlc3MpO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChQcml2YXRlRHJhZ2dhYmxlLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICBpc0Nsb25lOiBmYWxzZSxcbiAgICBpc0VuYWJsZWQ6IGlzRW5hYmxlZCxcbiAgICBjYW5EcmFnSW50ZXJhY3RpdmVFbGVtZW50czogY2FuRHJhZ0ludGVyYWN0aXZlRWxlbWVudHMsXG4gICAgc2hvdWxkUmVzcGVjdEZvcmNlUHJlc3M6IHNob3VsZFJlc3BlY3RGb3JjZVByZXNzXG4gIH0pKTtcbn1cblxuY29uc3QgaXNFcXVhbCA9IGJhc2UgPT4gdmFsdWUgPT4gYmFzZSA9PT0gdmFsdWU7XG5jb25zdCBpc1Njcm9sbCA9IGlzRXF1YWwoJ3Njcm9sbCcpO1xuY29uc3QgaXNBdXRvID0gaXNFcXVhbCgnYXV0bycpO1xuY29uc3QgaXNWaXNpYmxlID0gaXNFcXVhbCgndmlzaWJsZScpO1xuY29uc3QgaXNFaXRoZXIgPSAob3ZlcmZsb3csIGZuKSA9PiBmbihvdmVyZmxvdy5vdmVyZmxvd1gpIHx8IGZuKG92ZXJmbG93Lm92ZXJmbG93WSk7XG5jb25zdCBpc0JvdGggPSAob3ZlcmZsb3csIGZuKSA9PiBmbihvdmVyZmxvdy5vdmVyZmxvd1gpICYmIGZuKG92ZXJmbG93Lm92ZXJmbG93WSk7XG5jb25zdCBpc0VsZW1lbnRTY3JvbGxhYmxlID0gZWwgPT4ge1xuICBjb25zdCBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgY29uc3Qgb3ZlcmZsb3cgPSB7XG4gICAgb3ZlcmZsb3dYOiBzdHlsZS5vdmVyZmxvd1gsXG4gICAgb3ZlcmZsb3dZOiBzdHlsZS5vdmVyZmxvd1lcbiAgfTtcbiAgcmV0dXJuIGlzRWl0aGVyKG92ZXJmbG93LCBpc1Njcm9sbCkgfHwgaXNFaXRoZXIob3ZlcmZsb3csIGlzQXV0byk7XG59O1xuY29uc3QgaXNCb2R5U2Nyb2xsYWJsZSA9ICgpID0+IHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgYm9keSA9IGdldEJvZHlFbGVtZW50KCk7XG4gIGNvbnN0IGh0bWwgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICFodG1sID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIGlmICghaXNFbGVtZW50U2Nyb2xsYWJsZShib2R5KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBodG1sU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShodG1sKTtcbiAgY29uc3QgaHRtbE92ZXJmbG93ID0ge1xuICAgIG92ZXJmbG93WDogaHRtbFN0eWxlLm92ZXJmbG93WCxcbiAgICBvdmVyZmxvd1k6IGh0bWxTdHlsZS5vdmVyZmxvd1lcbiAgfTtcbiAgaWYgKGlzQm90aChodG1sT3ZlcmZsb3csIGlzVmlzaWJsZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhgXG4gICAgV2UgaGF2ZSBkZXRlY3RlZCB0aGF0IHlvdXIgPGJvZHk+IGVsZW1lbnQgbWlnaHQgYmUgYSBzY3JvbGwgY29udGFpbmVyLlxuICAgIFdlIGhhdmUgZm91bmQgbm8gcmVsaWFibGUgd2F5IG9mIGRldGVjdGluZyB3aGV0aGVyIHRoZSA8Ym9keT4gZWxlbWVudCBpcyBhIHNjcm9sbCBjb250YWluZXIuXG4gICAgVW5kZXIgbW9zdCBjaXJjdW1zdGFuY2VzIGEgPGJvZHk+IHNjcm9sbCBiYXIgd2lsbCBiZSBvbiB0aGUgPGh0bWw+IGVsZW1lbnQgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudClcblxuICAgIEJlY2F1c2Ugd2UgY2Fubm90IGRldGVybWluZSBpZiB0aGUgPGJvZHk+IGlzIGEgc2Nyb2xsIGNvbnRhaW5lciwgYW5kIGdlbmVyYWxseSBpdCBpcyBub3Qgb25lLFxuICAgIHdlIHdpbGwgYmUgdHJlYXRpbmcgdGhlIDxib2R5PiBhcyAqbm90KiBhIHNjcm9sbCBjb250YWluZXJcblxuICAgIE1vcmUgaW5mb3JtYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9oZWxsby1wYW5nZWEvZG5kL2Jsb2IvbWFpbi9kb2NzL2d1aWRlcy9ob3ctd2UtZGV0ZWN0LXNjcm9sbC1jb250YWluZXJzLm1kXG4gIGApIDogdm9pZCAwO1xuICByZXR1cm4gZmFsc2U7XG59O1xuY29uc3QgZ2V0Q2xvc2VzdFNjcm9sbGFibGUgPSBlbCA9PiB7XG4gIGlmIChlbCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKGVsID09PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgcmV0dXJuIGlzQm9keVNjcm9sbGFibGUoKSA/IGVsIDogbnVsbDtcbiAgfVxuICBpZiAoZWwgPT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmICghaXNFbGVtZW50U2Nyb2xsYWJsZShlbCkpIHtcbiAgICByZXR1cm4gZ2V0Q2xvc2VzdFNjcm9sbGFibGUoZWwucGFyZW50RWxlbWVudCk7XG4gIH1cbiAgcmV0dXJuIGVsO1xufTtcblxudmFyIGNoZWNrRm9yTmVzdGVkU2Nyb2xsQ29udGFpbmVycyA9IChzY3JvbGxhYmxlID0+IHtcbiAgaWYgKCFzY3JvbGxhYmxlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGFub3RoZXJTY3JvbGxQYXJlbnQgPSBnZXRDbG9zZXN0U2Nyb2xsYWJsZShzY3JvbGxhYmxlLnBhcmVudEVsZW1lbnQpO1xuICBpZiAoIWFub3RoZXJTY3JvbGxQYXJlbnQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhgXG4gICAgRHJvcHBhYmxlOiB1bnN1cHBvcnRlZCBuZXN0ZWQgc2Nyb2xsIGNvbnRhaW5lciBkZXRlY3RlZC5cbiAgICBBIERyb3BwYWJsZSBjYW4gb25seSBoYXZlIG9uZSBzY3JvbGwgcGFyZW50ICh3aGljaCBjYW4gYmUgaXRzZWxmKVxuICAgIE5lc3RlZCBzY3JvbGwgY29udGFpbmVycyBhcmUgY3VycmVudGx5IG5vdCBzdXBwb3J0ZWQuXG5cbiAgICBXZSBob3BlIHRvIHN1cHBvcnQgbmVzdGVkIHNjcm9sbCBjb250YWluZXJzIHNvb246IGh0dHBzOi8vZ2l0aHViLmNvbS9hdGxhc3NpYW4vcmVhY3QtYmVhdXRpZnVsLWRuZC9pc3N1ZXMvMTMxXG4gIGApIDogdm9pZCAwO1xufSk7XG5cbnZhciBnZXRTY3JvbGwgPSAoZWwgPT4gKHtcbiAgeDogZWwuc2Nyb2xsTGVmdCxcbiAgeTogZWwuc2Nyb2xsVG9wXG59KSk7XG5cbmNvbnN0IGdldElzRml4ZWQgPSBlbCA9PiB7XG4gIGlmICghZWwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3Qgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gIGlmIChzdHlsZS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBnZXRJc0ZpeGVkKGVsLnBhcmVudEVsZW1lbnQpO1xufTtcbnZhciBnZXRFbnYgPSAoc3RhcnQgPT4ge1xuICBjb25zdCBjbG9zZXN0U2Nyb2xsYWJsZSA9IGdldENsb3Nlc3RTY3JvbGxhYmxlKHN0YXJ0KTtcbiAgY29uc3QgaXNGaXhlZE9uUGFnZSA9IGdldElzRml4ZWQoc3RhcnQpO1xuICByZXR1cm4ge1xuICAgIGNsb3Nlc3RTY3JvbGxhYmxlLFxuICAgIGlzRml4ZWRPblBhZ2VcbiAgfTtcbn0pO1xuXG52YXIgZ2V0RHJvcHBhYmxlRGltZW5zaW9uID0gKCh7XG4gIGRlc2NyaXB0b3IsXG4gIGlzRW5hYmxlZCxcbiAgaXNDb21iaW5lRW5hYmxlZCxcbiAgaXNGaXhlZE9uUGFnZSxcbiAgZGlyZWN0aW9uLFxuICBjbGllbnQsXG4gIHBhZ2UsXG4gIGNsb3Nlc3Rcbn0pID0+IHtcbiAgY29uc3QgZnJhbWUgPSAoKCkgPT4ge1xuICAgIGlmICghY2xvc2VzdCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHNjcm9sbFNpemUsXG4gICAgICBjbGllbnQ6IGZyYW1lQ2xpZW50XG4gICAgfSA9IGNsb3Nlc3Q7XG4gICAgY29uc3QgbWF4U2Nyb2xsID0gZ2V0TWF4U2Nyb2xsKHtcbiAgICAgIHNjcm9sbEhlaWdodDogc2Nyb2xsU2l6ZS5zY3JvbGxIZWlnaHQsXG4gICAgICBzY3JvbGxXaWR0aDogc2Nyb2xsU2l6ZS5zY3JvbGxXaWR0aCxcbiAgICAgIGhlaWdodDogZnJhbWVDbGllbnQucGFkZGluZ0JveC5oZWlnaHQsXG4gICAgICB3aWR0aDogZnJhbWVDbGllbnQucGFkZGluZ0JveC53aWR0aFxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBwYWdlTWFyZ2luQm94OiBjbG9zZXN0LnBhZ2UubWFyZ2luQm94LFxuICAgICAgZnJhbWVDbGllbnQsXG4gICAgICBzY3JvbGxTaXplLFxuICAgICAgc2hvdWxkQ2xpcFN1YmplY3Q6IGNsb3Nlc3Quc2hvdWxkQ2xpcFN1YmplY3QsXG4gICAgICBzY3JvbGw6IHtcbiAgICAgICAgaW5pdGlhbDogY2xvc2VzdC5zY3JvbGwsXG4gICAgICAgIGN1cnJlbnQ6IGNsb3Nlc3Quc2Nyb2xsLFxuICAgICAgICBtYXg6IG1heFNjcm9sbCxcbiAgICAgICAgZGlmZjoge1xuICAgICAgICAgIHZhbHVlOiBvcmlnaW4sXG4gICAgICAgICAgZGlzcGxhY2VtZW50OiBvcmlnaW5cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH0pKCk7XG4gIGNvbnN0IGF4aXMgPSBkaXJlY3Rpb24gPT09ICd2ZXJ0aWNhbCcgPyB2ZXJ0aWNhbCA6IGhvcml6b250YWw7XG4gIGNvbnN0IHN1YmplY3QgPSBnZXRTdWJqZWN0KHtcbiAgICBwYWdlLFxuICAgIHdpdGhQbGFjZWhvbGRlcjogbnVsbCxcbiAgICBheGlzLFxuICAgIGZyYW1lXG4gIH0pO1xuICBjb25zdCBkaW1lbnNpb24gPSB7XG4gICAgZGVzY3JpcHRvcixcbiAgICBpc0NvbWJpbmVFbmFibGVkLFxuICAgIGlzRml4ZWRPblBhZ2UsXG4gICAgYXhpcyxcbiAgICBpc0VuYWJsZWQsXG4gICAgY2xpZW50LFxuICAgIHBhZ2UsXG4gICAgZnJhbWUsXG4gICAgc3ViamVjdFxuICB9O1xuICByZXR1cm4gZGltZW5zaW9uO1xufSk7XG5cbmNvbnN0IGdldENsaWVudCA9ICh0YXJnZXRSZWYsIGNsb3Nlc3RTY3JvbGxhYmxlKSA9PiB7XG4gIGNvbnN0IGJhc2UgPSBnZXRCb3godGFyZ2V0UmVmKTtcbiAgaWYgKCFjbG9zZXN0U2Nyb2xsYWJsZSkge1xuICAgIHJldHVybiBiYXNlO1xuICB9XG4gIGlmICh0YXJnZXRSZWYgIT09IGNsb3Nlc3RTY3JvbGxhYmxlKSB7XG4gICAgcmV0dXJuIGJhc2U7XG4gIH1cbiAgY29uc3QgdG9wID0gYmFzZS5wYWRkaW5nQm94LnRvcCAtIGNsb3Nlc3RTY3JvbGxhYmxlLnNjcm9sbFRvcDtcbiAgY29uc3QgbGVmdCA9IGJhc2UucGFkZGluZ0JveC5sZWZ0IC0gY2xvc2VzdFNjcm9sbGFibGUuc2Nyb2xsTGVmdDtcbiAgY29uc3QgYm90dG9tID0gdG9wICsgY2xvc2VzdFNjcm9sbGFibGUuc2Nyb2xsSGVpZ2h0O1xuICBjb25zdCByaWdodCA9IGxlZnQgKyBjbG9zZXN0U2Nyb2xsYWJsZS5zY3JvbGxXaWR0aDtcbiAgY29uc3QgcGFkZGluZ0JveCA9IHtcbiAgICB0b3AsXG4gICAgcmlnaHQsXG4gICAgYm90dG9tLFxuICAgIGxlZnRcbiAgfTtcbiAgY29uc3QgYm9yZGVyQm94ID0gZXhwYW5kKHBhZGRpbmdCb3gsIGJhc2UuYm9yZGVyKTtcbiAgY29uc3QgY2xpZW50ID0gY3JlYXRlQm94KHtcbiAgICBib3JkZXJCb3gsXG4gICAgbWFyZ2luOiBiYXNlLm1hcmdpbixcbiAgICBib3JkZXI6IGJhc2UuYm9yZGVyLFxuICAgIHBhZGRpbmc6IGJhc2UucGFkZGluZ1xuICB9KTtcbiAgcmV0dXJuIGNsaWVudDtcbn07XG52YXIgZ2V0RGltZW5zaW9uID0gKCh7XG4gIHJlZixcbiAgZGVzY3JpcHRvcixcbiAgZW52LFxuICB3aW5kb3dTY3JvbGwsXG4gIGRpcmVjdGlvbixcbiAgaXNEcm9wRGlzYWJsZWQsXG4gIGlzQ29tYmluZUVuYWJsZWQsXG4gIHNob3VsZENsaXBTdWJqZWN0XG59KSA9PiB7XG4gIGNvbnN0IGNsb3Nlc3RTY3JvbGxhYmxlID0gZW52LmNsb3Nlc3RTY3JvbGxhYmxlO1xuICBjb25zdCBjbGllbnQgPSBnZXRDbGllbnQocmVmLCBjbG9zZXN0U2Nyb2xsYWJsZSk7XG4gIGNvbnN0IHBhZ2UgPSB3aXRoU2Nyb2xsKGNsaWVudCwgd2luZG93U2Nyb2xsKTtcbiAgY29uc3QgY2xvc2VzdCA9ICgoKSA9PiB7XG4gICAgaWYgKCFjbG9zZXN0U2Nyb2xsYWJsZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGZyYW1lQ2xpZW50ID0gZ2V0Qm94KGNsb3Nlc3RTY3JvbGxhYmxlKTtcbiAgICBjb25zdCBzY3JvbGxTaXplID0ge1xuICAgICAgc2Nyb2xsSGVpZ2h0OiBjbG9zZXN0U2Nyb2xsYWJsZS5zY3JvbGxIZWlnaHQsXG4gICAgICBzY3JvbGxXaWR0aDogY2xvc2VzdFNjcm9sbGFibGUuc2Nyb2xsV2lkdGhcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICBjbGllbnQ6IGZyYW1lQ2xpZW50LFxuICAgICAgcGFnZTogd2l0aFNjcm9sbChmcmFtZUNsaWVudCwgd2luZG93U2Nyb2xsKSxcbiAgICAgIHNjcm9sbDogZ2V0U2Nyb2xsKGNsb3Nlc3RTY3JvbGxhYmxlKSxcbiAgICAgIHNjcm9sbFNpemUsXG4gICAgICBzaG91bGRDbGlwU3ViamVjdFxuICAgIH07XG4gIH0pKCk7XG4gIGNvbnN0IGRpbWVuc2lvbiA9IGdldERyb3BwYWJsZURpbWVuc2lvbih7XG4gICAgZGVzY3JpcHRvcixcbiAgICBpc0VuYWJsZWQ6ICFpc0Ryb3BEaXNhYmxlZCxcbiAgICBpc0NvbWJpbmVFbmFibGVkLFxuICAgIGlzRml4ZWRPblBhZ2U6IGVudi5pc0ZpeGVkT25QYWdlLFxuICAgIGRpcmVjdGlvbixcbiAgICBjbGllbnQsXG4gICAgcGFnZSxcbiAgICBjbG9zZXN0XG4gIH0pO1xuICByZXR1cm4gZGltZW5zaW9uO1xufSk7XG5cbmNvbnN0IGltbWVkaWF0ZSA9IHtcbiAgcGFzc2l2ZTogZmFsc2Vcbn07XG5jb25zdCBkZWxheWVkID0ge1xuICBwYXNzaXZlOiB0cnVlXG59O1xudmFyIGdldExpc3RlbmVyT3B0aW9ucyA9IChvcHRpb25zID0+IG9wdGlvbnMuc2hvdWxkUHVibGlzaEltbWVkaWF0ZWx5ID8gaW1tZWRpYXRlIDogZGVsYXllZCk7XG5cbmNvbnN0IGdldENsb3Nlc3RTY3JvbGxhYmxlRnJvbURyYWcgPSBkcmFnZ2luZyA9PiBkcmFnZ2luZyAmJiBkcmFnZ2luZy5lbnYuY2xvc2VzdFNjcm9sbGFibGUgfHwgbnVsbDtcbmZ1bmN0aW9uIHVzZURyb3BwYWJsZVB1Ymxpc2hlcihhcmdzKSB7XG4gIGNvbnN0IHdoaWxlRHJhZ2dpbmdSZWYgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IGFwcENvbnRleHQgPSB1c2VSZXF1aXJlZENvbnRleHQoQXBwQ29udGV4dCk7XG4gIGNvbnN0IHVuaXF1ZUlkID0gdXNlVW5pcXVlSWQkMSgnZHJvcHBhYmxlJyk7XG4gIGNvbnN0IHtcbiAgICByZWdpc3RyeSxcbiAgICBtYXJzaGFsXG4gIH0gPSBhcHBDb250ZXh0O1xuICBjb25zdCBwcmV2aW91c1JlZiA9IHVzZVByZXZpb3VzKGFyZ3MpO1xuICBjb25zdCBkZXNjcmlwdG9yID0gdXNlTWVtbygoKSA9PiAoe1xuICAgIGlkOiBhcmdzLmRyb3BwYWJsZUlkLFxuICAgIHR5cGU6IGFyZ3MudHlwZSxcbiAgICBtb2RlOiBhcmdzLm1vZGVcbiAgfSksIFthcmdzLmRyb3BwYWJsZUlkLCBhcmdzLm1vZGUsIGFyZ3MudHlwZV0pO1xuICBjb25zdCBwdWJsaXNoZWREZXNjcmlwdG9yUmVmID0gdXNlUmVmKGRlc2NyaXB0b3IpO1xuICBjb25zdCBtZW1vaXplZFVwZGF0ZVNjcm9sbCA9IHVzZU1lbW8oKCkgPT4gbWVtb2l6ZU9uZSgoeCwgeSkgPT4ge1xuICAgICF3aGlsZURyYWdnaW5nUmVmLmN1cnJlbnQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW4gb25seSB1cGRhdGUgc2Nyb2xsIHdoZW4gZHJhZ2dpbmcnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgY29uc3Qgc2Nyb2xsID0ge1xuICAgICAgeCxcbiAgICAgIHlcbiAgICB9O1xuICAgIG1hcnNoYWwudXBkYXRlRHJvcHBhYmxlU2Nyb2xsKGRlc2NyaXB0b3IuaWQsIHNjcm9sbCk7XG4gIH0pLCBbZGVzY3JpcHRvci5pZCwgbWFyc2hhbF0pO1xuICBjb25zdCBnZXRDbG9zZXN0U2Nyb2xsID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGNvbnN0IGRyYWdnaW5nID0gd2hpbGVEcmFnZ2luZ1JlZi5jdXJyZW50O1xuICAgIGlmICghZHJhZ2dpbmcgfHwgIWRyYWdnaW5nLmVudi5jbG9zZXN0U2Nyb2xsYWJsZSkge1xuICAgICAgcmV0dXJuIG9yaWdpbjtcbiAgICB9XG4gICAgcmV0dXJuIGdldFNjcm9sbChkcmFnZ2luZy5lbnYuY2xvc2VzdFNjcm9sbGFibGUpO1xuICB9LCBbXSk7XG4gIGNvbnN0IHVwZGF0ZVNjcm9sbCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBjb25zdCBzY3JvbGwgPSBnZXRDbG9zZXN0U2Nyb2xsKCk7XG4gICAgbWVtb2l6ZWRVcGRhdGVTY3JvbGwoc2Nyb2xsLngsIHNjcm9sbC55KTtcbiAgfSwgW2dldENsb3Nlc3RTY3JvbGwsIG1lbW9pemVkVXBkYXRlU2Nyb2xsXSk7XG4gIGNvbnN0IHNjaGVkdWxlU2Nyb2xsVXBkYXRlID0gdXNlTWVtbygoKSA9PiByYWZTY2hkKHVwZGF0ZVNjcm9sbCksIFt1cGRhdGVTY3JvbGxdKTtcbiAgY29uc3Qgb25DbG9zZXN0U2Nyb2xsID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGNvbnN0IGRyYWdnaW5nID0gd2hpbGVEcmFnZ2luZ1JlZi5jdXJyZW50O1xuICAgIGNvbnN0IGNsb3Nlc3QgPSBnZXRDbG9zZXN0U2Nyb2xsYWJsZUZyb21EcmFnKGRyYWdnaW5nKTtcbiAgICAhKGRyYWdnaW5nICYmIGNsb3Nlc3QpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ291bGQgbm90IGZpbmQgc2Nyb2xsIG9wdGlvbnMgd2hpbGUgc2Nyb2xsaW5nJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIGNvbnN0IG9wdGlvbnMgPSBkcmFnZ2luZy5zY3JvbGxPcHRpb25zO1xuICAgIGlmIChvcHRpb25zLnNob3VsZFB1Ymxpc2hJbW1lZGlhdGVseSkge1xuICAgICAgdXBkYXRlU2Nyb2xsKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNjaGVkdWxlU2Nyb2xsVXBkYXRlKCk7XG4gIH0sIFtzY2hlZHVsZVNjcm9sbFVwZGF0ZSwgdXBkYXRlU2Nyb2xsXSk7XG4gIGNvbnN0IGdldERpbWVuc2lvbkFuZFdhdGNoU2Nyb2xsID0gdXNlQ2FsbGJhY2soKHdpbmRvd1Njcm9sbCwgb3B0aW9ucykgPT4ge1xuICAgICEhd2hpbGVEcmFnZ2luZ1JlZi5jdXJyZW50ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IGNvbGxlY3QgYSBkcm9wcGFibGUgd2hpbGUgYSBkcmFnIGlzIG9jY3VycmluZycpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBjb25zdCBwcmV2aW91cyA9IHByZXZpb3VzUmVmLmN1cnJlbnQ7XG4gICAgY29uc3QgcmVmID0gcHJldmlvdXMuZ2V0RHJvcHBhYmxlUmVmKCk7XG4gICAgIXJlZiA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBjb2xsZWN0IHdpdGhvdXQgYSBkcm9wcGFibGUgcmVmJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIGNvbnN0IGVudiA9IGdldEVudihyZWYpO1xuICAgIGNvbnN0IGRyYWdnaW5nID0ge1xuICAgICAgcmVmLFxuICAgICAgZGVzY3JpcHRvcixcbiAgICAgIGVudixcbiAgICAgIHNjcm9sbE9wdGlvbnM6IG9wdGlvbnNcbiAgICB9O1xuICAgIHdoaWxlRHJhZ2dpbmdSZWYuY3VycmVudCA9IGRyYWdnaW5nO1xuICAgIGNvbnN0IGRpbWVuc2lvbiA9IGdldERpbWVuc2lvbih7XG4gICAgICByZWYsXG4gICAgICBkZXNjcmlwdG9yLFxuICAgICAgZW52LFxuICAgICAgd2luZG93U2Nyb2xsLFxuICAgICAgZGlyZWN0aW9uOiBwcmV2aW91cy5kaXJlY3Rpb24sXG4gICAgICBpc0Ryb3BEaXNhYmxlZDogcHJldmlvdXMuaXNEcm9wRGlzYWJsZWQsXG4gICAgICBpc0NvbWJpbmVFbmFibGVkOiBwcmV2aW91cy5pc0NvbWJpbmVFbmFibGVkLFxuICAgICAgc2hvdWxkQ2xpcFN1YmplY3Q6ICFwcmV2aW91cy5pZ25vcmVDb250YWluZXJDbGlwcGluZ1xuICAgIH0pO1xuICAgIGNvbnN0IHNjcm9sbGFibGUgPSBlbnYuY2xvc2VzdFNjcm9sbGFibGU7XG4gICAgaWYgKHNjcm9sbGFibGUpIHtcbiAgICAgIHNjcm9sbGFibGUuc2V0QXR0cmlidXRlKHNjcm9sbENvbnRhaW5lci5jb250ZXh0SWQsIGFwcENvbnRleHQuY29udGV4dElkKTtcbiAgICAgIHNjcm9sbGFibGUuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgb25DbG9zZXN0U2Nyb2xsLCBnZXRMaXN0ZW5lck9wdGlvbnMoZHJhZ2dpbmcuc2Nyb2xsT3B0aW9ucykpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgY2hlY2tGb3JOZXN0ZWRTY3JvbGxDb250YWluZXJzKHNjcm9sbGFibGUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGltZW5zaW9uO1xuICB9LCBbYXBwQ29udGV4dC5jb250ZXh0SWQsIGRlc2NyaXB0b3IsIG9uQ2xvc2VzdFNjcm9sbCwgcHJldmlvdXNSZWZdKTtcbiAgY29uc3QgZ2V0U2Nyb2xsV2hpbGVEcmFnZ2luZyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBjb25zdCBkcmFnZ2luZyA9IHdoaWxlRHJhZ2dpbmdSZWYuY3VycmVudDtcbiAgICBjb25zdCBjbG9zZXN0ID0gZ2V0Q2xvc2VzdFNjcm9sbGFibGVGcm9tRHJhZyhkcmFnZ2luZyk7XG4gICAgIShkcmFnZ2luZyAmJiBjbG9zZXN0KSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0NhbiBvbmx5IHJlY29sbGVjdCBEcm9wcGFibGUgY2xpZW50IGZvciBEcm9wcGFibGVzIHRoYXQgaGF2ZSBhIHNjcm9sbCBjb250YWluZXInKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgcmV0dXJuIGdldFNjcm9sbChjbG9zZXN0KTtcbiAgfSwgW10pO1xuICBjb25zdCBkcmFnU3RvcHBlZCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBjb25zdCBkcmFnZ2luZyA9IHdoaWxlRHJhZ2dpbmdSZWYuY3VycmVudDtcbiAgICAhZHJhZ2dpbmcgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3Qgc3RvcCBkcmFnIHdoZW4gbm8gYWN0aXZlIGRyYWcnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgY29uc3QgY2xvc2VzdCA9IGdldENsb3Nlc3RTY3JvbGxhYmxlRnJvbURyYWcoZHJhZ2dpbmcpO1xuICAgIHdoaWxlRHJhZ2dpbmdSZWYuY3VycmVudCA9IG51bGw7XG4gICAgaWYgKCFjbG9zZXN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNjaGVkdWxlU2Nyb2xsVXBkYXRlLmNhbmNlbCgpO1xuICAgIGNsb3Nlc3QucmVtb3ZlQXR0cmlidXRlKHNjcm9sbENvbnRhaW5lci5jb250ZXh0SWQpO1xuICAgIGNsb3Nlc3QucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgb25DbG9zZXN0U2Nyb2xsLCBnZXRMaXN0ZW5lck9wdGlvbnMoZHJhZ2dpbmcuc2Nyb2xsT3B0aW9ucykpO1xuICB9LCBbb25DbG9zZXN0U2Nyb2xsLCBzY2hlZHVsZVNjcm9sbFVwZGF0ZV0pO1xuICBjb25zdCBzY3JvbGwgPSB1c2VDYWxsYmFjayhjaGFuZ2UgPT4ge1xuICAgIGNvbnN0IGRyYWdnaW5nID0gd2hpbGVEcmFnZ2luZ1JlZi5jdXJyZW50O1xuICAgICFkcmFnZ2luZyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBzY3JvbGwgd2hlbiB0aGVyZSBpcyBubyBkcmFnJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIGNvbnN0IGNsb3Nlc3QgPSBnZXRDbG9zZXN0U2Nyb2xsYWJsZUZyb21EcmFnKGRyYWdnaW5nKTtcbiAgICAhY2xvc2VzdCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBzY3JvbGwgYSBkcm9wcGFibGUgd2l0aCBubyBjbG9zZXN0IHNjcm9sbGFibGUnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgY2xvc2VzdC5zY3JvbGxUb3AgKz0gY2hhbmdlLnk7XG4gICAgY2xvc2VzdC5zY3JvbGxMZWZ0ICs9IGNoYW5nZS54O1xuICB9LCBbXSk7XG4gIGNvbnN0IGNhbGxiYWNrcyA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBnZXREaW1lbnNpb25BbmRXYXRjaFNjcm9sbCxcbiAgICAgIGdldFNjcm9sbFdoaWxlRHJhZ2dpbmcsXG4gICAgICBkcmFnU3RvcHBlZCxcbiAgICAgIHNjcm9sbFxuICAgIH07XG4gIH0sIFtkcmFnU3RvcHBlZCwgZ2V0RGltZW5zaW9uQW5kV2F0Y2hTY3JvbGwsIGdldFNjcm9sbFdoaWxlRHJhZ2dpbmcsIHNjcm9sbF0pO1xuICBjb25zdCBlbnRyeSA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICB1bmlxdWVJZCxcbiAgICBkZXNjcmlwdG9yLFxuICAgIGNhbGxiYWNrc1xuICB9KSwgW2NhbGxiYWNrcywgZGVzY3JpcHRvciwgdW5pcXVlSWRdKTtcbiAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBwdWJsaXNoZWREZXNjcmlwdG9yUmVmLmN1cnJlbnQgPSBlbnRyeS5kZXNjcmlwdG9yO1xuICAgIHJlZ2lzdHJ5LmRyb3BwYWJsZS5yZWdpc3RlcihlbnRyeSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmICh3aGlsZURyYWdnaW5nUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZygnVW5zdXBwb3J0ZWQ6IGNoYW5naW5nIHRoZSBkcm9wcGFibGVJZCBvciB0eXBlIG9mIGEgRHJvcHBhYmxlIGR1cmluZyBhIGRyYWcnKSA6IHZvaWQgMDtcbiAgICAgICAgZHJhZ1N0b3BwZWQoKTtcbiAgICAgIH1cbiAgICAgIHJlZ2lzdHJ5LmRyb3BwYWJsZS51bnJlZ2lzdGVyKGVudHJ5KTtcbiAgICB9O1xuICB9LCBbY2FsbGJhY2tzLCBkZXNjcmlwdG9yLCBkcmFnU3RvcHBlZCwgZW50cnksIG1hcnNoYWwsIHJlZ2lzdHJ5LmRyb3BwYWJsZV0pO1xuICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghd2hpbGVEcmFnZ2luZ1JlZi5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG1hcnNoYWwudXBkYXRlRHJvcHBhYmxlSXNFbmFibGVkKHB1Ymxpc2hlZERlc2NyaXB0b3JSZWYuY3VycmVudC5pZCwgIWFyZ3MuaXNEcm9wRGlzYWJsZWQpO1xuICB9LCBbYXJncy5pc0Ryb3BEaXNhYmxlZCwgbWFyc2hhbF0pO1xuICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghd2hpbGVEcmFnZ2luZ1JlZi5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG1hcnNoYWwudXBkYXRlRHJvcHBhYmxlSXNDb21iaW5lRW5hYmxlZChwdWJsaXNoZWREZXNjcmlwdG9yUmVmLmN1cnJlbnQuaWQsIGFyZ3MuaXNDb21iaW5lRW5hYmxlZCk7XG4gIH0sIFthcmdzLmlzQ29tYmluZUVuYWJsZWQsIG1hcnNoYWxdKTtcbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5jb25zdCBlbXB0eSA9IHtcbiAgd2lkdGg6IDAsXG4gIGhlaWdodDogMCxcbiAgbWFyZ2luOiBub1NwYWNpbmdcbn07XG5jb25zdCBnZXRTaXplID0gKHtcbiAgaXNBbmltYXRpbmdPcGVuT25Nb3VudCxcbiAgcGxhY2Vob2xkZXIsXG4gIGFuaW1hdGVcbn0pID0+IHtcbiAgaWYgKGlzQW5pbWF0aW5nT3Blbk9uTW91bnQpIHtcbiAgICByZXR1cm4gZW1wdHk7XG4gIH1cbiAgaWYgKGFuaW1hdGUgPT09ICdjbG9zZScpIHtcbiAgICByZXR1cm4gZW1wdHk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBoZWlnaHQ6IHBsYWNlaG9sZGVyLmNsaWVudC5ib3JkZXJCb3guaGVpZ2h0LFxuICAgIHdpZHRoOiBwbGFjZWhvbGRlci5jbGllbnQuYm9yZGVyQm94LndpZHRoLFxuICAgIG1hcmdpbjogcGxhY2Vob2xkZXIuY2xpZW50Lm1hcmdpblxuICB9O1xufTtcbmNvbnN0IGdldFN0eWxlID0gKHtcbiAgaXNBbmltYXRpbmdPcGVuT25Nb3VudCxcbiAgcGxhY2Vob2xkZXIsXG4gIGFuaW1hdGVcbn0pID0+IHtcbiAgY29uc3Qgc2l6ZSA9IGdldFNpemUoe1xuICAgIGlzQW5pbWF0aW5nT3Blbk9uTW91bnQsXG4gICAgcGxhY2Vob2xkZXIsXG4gICAgYW5pbWF0ZVxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBkaXNwbGF5OiBwbGFjZWhvbGRlci5kaXNwbGF5LFxuICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxuICAgIHdpZHRoOiBzaXplLndpZHRoLFxuICAgIGhlaWdodDogc2l6ZS5oZWlnaHQsXG4gICAgbWFyZ2luVG9wOiBzaXplLm1hcmdpbi50b3AsXG4gICAgbWFyZ2luUmlnaHQ6IHNpemUubWFyZ2luLnJpZ2h0LFxuICAgIG1hcmdpbkJvdHRvbTogc2l6ZS5tYXJnaW4uYm90dG9tLFxuICAgIG1hcmdpbkxlZnQ6IHNpemUubWFyZ2luLmxlZnQsXG4gICAgZmxleFNocmluazogJzAnLFxuICAgIGZsZXhHcm93OiAnMCcsXG4gICAgcG9pbnRlckV2ZW50czogJ25vbmUnLFxuICAgIHRyYW5zaXRpb246IGFuaW1hdGUgIT09ICdub25lJyA/IHRyYW5zaXRpb25zLnBsYWNlaG9sZGVyIDogbnVsbFxuICB9O1xufTtcbmNvbnN0IFBsYWNlaG9sZGVyID0gcHJvcHMgPT4ge1xuICBjb25zdCBhbmltYXRlT3BlblRpbWVyUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCB0cnlDbGVhckFuaW1hdGVPcGVuVGltZXIgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKCFhbmltYXRlT3BlblRpbWVyUmVmLmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2xlYXJUaW1lb3V0KGFuaW1hdGVPcGVuVGltZXJSZWYuY3VycmVudCk7XG4gICAgYW5pbWF0ZU9wZW5UaW1lclJlZi5jdXJyZW50ID0gbnVsbDtcbiAgfSwgW10pO1xuICBjb25zdCB7XG4gICAgYW5pbWF0ZSxcbiAgICBvblRyYW5zaXRpb25FbmQsXG4gICAgb25DbG9zZSxcbiAgICBjb250ZXh0SWRcbiAgfSA9IHByb3BzO1xuICBjb25zdCBbaXNBbmltYXRpbmdPcGVuT25Nb3VudCwgc2V0SXNBbmltYXRpbmdPcGVuT25Nb3VudF0gPSB1c2VTdGF0ZShwcm9wcy5hbmltYXRlID09PSAnb3BlbicpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghaXNBbmltYXRpbmdPcGVuT25Nb3VudCkge1xuICAgICAgcmV0dXJuIG5vb3A7XG4gICAgfVxuICAgIGlmIChhbmltYXRlICE9PSAnb3BlbicpIHtcbiAgICAgIHRyeUNsZWFyQW5pbWF0ZU9wZW5UaW1lcigpO1xuICAgICAgc2V0SXNBbmltYXRpbmdPcGVuT25Nb3VudChmYWxzZSk7XG4gICAgICByZXR1cm4gbm9vcDtcbiAgICB9XG4gICAgaWYgKGFuaW1hdGVPcGVuVGltZXJSZWYuY3VycmVudCkge1xuICAgICAgcmV0dXJuIG5vb3A7XG4gICAgfVxuICAgIGFuaW1hdGVPcGVuVGltZXJSZWYuY3VycmVudCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgYW5pbWF0ZU9wZW5UaW1lclJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgIHNldElzQW5pbWF0aW5nT3Blbk9uTW91bnQoZmFsc2UpO1xuICAgIH0pO1xuICAgIHJldHVybiB0cnlDbGVhckFuaW1hdGVPcGVuVGltZXI7XG4gIH0sIFthbmltYXRlLCBpc0FuaW1hdGluZ09wZW5Pbk1vdW50LCB0cnlDbGVhckFuaW1hdGVPcGVuVGltZXJdKTtcbiAgY29uc3Qgb25TaXplQ2hhbmdlRW5kID0gdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xuICAgIGlmIChldmVudC5wcm9wZXJ0eU5hbWUgIT09ICdoZWlnaHQnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG9uVHJhbnNpdGlvbkVuZCgpO1xuICAgIGlmIChhbmltYXRlID09PSAnY2xvc2UnKSB7XG4gICAgICBvbkNsb3NlKCk7XG4gICAgfVxuICB9LCBbYW5pbWF0ZSwgb25DbG9zZSwgb25UcmFuc2l0aW9uRW5kXSk7XG4gIGNvbnN0IHN0eWxlID0gZ2V0U3R5bGUoe1xuICAgIGlzQW5pbWF0aW5nT3Blbk9uTW91bnQsXG4gICAgYW5pbWF0ZTogcHJvcHMuYW5pbWF0ZSxcbiAgICBwbGFjZWhvbGRlcjogcHJvcHMucGxhY2Vob2xkZXJcbiAgfSk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KHByb3BzLnBsYWNlaG9sZGVyLnRhZ05hbWUsIHtcbiAgICBzdHlsZSxcbiAgICAnZGF0YS1yZmQtcGxhY2Vob2xkZXItY29udGV4dC1pZCc6IGNvbnRleHRJZCxcbiAgICBvblRyYW5zaXRpb25FbmQ6IG9uU2l6ZUNoYW5nZUVuZCxcbiAgICByZWY6IHByb3BzLmlubmVyUmVmXG4gIH0pO1xufTtcbnZhciBQbGFjZWhvbGRlciQxID0gUmVhY3QubWVtbyhQbGFjZWhvbGRlcik7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbic7XG59XG5mdW5jdGlvbiBydW5DaGVja3MoYXJncywgY2hlY2tzKSB7XG4gIGNoZWNrcy5mb3JFYWNoKGNoZWNrID0+IGNoZWNrKGFyZ3MpKTtcbn1cbmNvbnN0IHNoYXJlZCA9IFtmdW5jdGlvbiByZXF1aXJlZCh7XG4gIHByb3BzXG59KSB7XG4gICFwcm9wcy5kcm9wcGFibGVJZCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0EgRHJvcHBhYmxlIHJlcXVpcmVzIGEgZHJvcHBhYmxlSWQgcHJvcCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgISh0eXBlb2YgcHJvcHMuZHJvcHBhYmxlSWQgPT09ICdzdHJpbmcnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYEEgRHJvcHBhYmxlIHJlcXVpcmVzIGEgW3N0cmluZ10gZHJvcHBhYmxlSWQuIFByb3ZpZGVkOiBbJHt0eXBlb2YgcHJvcHMuZHJvcHBhYmxlSWR9XWApIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbn0sIGZ1bmN0aW9uIGJvb2xlYW4oe1xuICBwcm9wc1xufSkge1xuICAhaXNCb29sZWFuKHByb3BzLmlzRHJvcERpc2FibGVkKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ2lzRHJvcERpc2FibGVkIG11c3QgYmUgYSBib29sZWFuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAhaXNCb29sZWFuKHByb3BzLmlzQ29tYmluZUVuYWJsZWQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnaXNDb21iaW5lRW5hYmxlZCBtdXN0IGJlIGEgYm9vbGVhbicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgIWlzQm9vbGVhbihwcm9wcy5pZ25vcmVDb250YWluZXJDbGlwcGluZykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdpZ25vcmVDb250YWluZXJDbGlwcGluZyBtdXN0IGJlIGEgYm9vbGVhbicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbn0sIGZ1bmN0aW9uIHJlZih7XG4gIGdldERyb3BwYWJsZVJlZlxufSkge1xuICBjaGVja0lzVmFsaWRJbm5lclJlZihnZXREcm9wcGFibGVSZWYoKSk7XG59XTtcbmNvbnN0IHN0YW5kYXJkID0gW2Z1bmN0aW9uIHBsYWNlaG9sZGVyKHtcbiAgcHJvcHMsXG4gIGdldFBsYWNlaG9sZGVyUmVmXG59KSB7XG4gIGlmICghcHJvcHMucGxhY2Vob2xkZXIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcmVmID0gZ2V0UGxhY2Vob2xkZXJSZWYoKTtcbiAgaWYgKHJlZikge1xuICAgIHJldHVybjtcbiAgfVxuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGBcbiAgICAgIERyb3BwYWJsZSBzZXR1cCBpc3N1ZSBbZHJvcHBhYmxlSWQ6IFwiJHtwcm9wcy5kcm9wcGFibGVJZH1cIl06XG4gICAgICBEcm9wcGFibGVQcm92aWRlZCA+IHBsYWNlaG9sZGVyIGNvdWxkIG5vdCBiZSBmb3VuZC5cblxuICAgICAgUGxlYXNlIGJlIHN1cmUgdG8gYWRkIHRoZSB7cHJvdmlkZWQucGxhY2Vob2xkZXJ9IFJlYWN0IE5vZGUgYXMgYSBjaGlsZCBvZiB5b3VyIERyb3BwYWJsZS5cbiAgICAgIE1vcmUgaW5mb3JtYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9oZWxsby1wYW5nZWEvZG5kL2Jsb2IvbWFpbi9kb2NzL2FwaS9kcm9wcGFibGUubWRcbiAgICBgKSA6IHZvaWQgMDtcbn1dO1xuY29uc3QgdmlydHVhbCA9IFtmdW5jdGlvbiBoYXNDbG9uZSh7XG4gIHByb3BzXG59KSB7XG4gICFwcm9wcy5yZW5kZXJDbG9uZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ011c3QgcHJvdmlkZSBhIGNsb25lIHJlbmRlciBmdW5jdGlvbiAocmVuZGVyQ2xvbmUpIGZvciB2aXJ0dWFsIGxpc3RzJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xufSwgZnVuY3Rpb24gaGFzTm9QbGFjZWhvbGRlcih7XG4gIGdldFBsYWNlaG9sZGVyUmVmXG59KSB7XG4gICEhZ2V0UGxhY2Vob2xkZXJSZWYoKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHZpcnR1YWwgbGlzdCB0byBub3QgaGF2ZSBhIHBsYWNlaG9sZGVyJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xufV07XG5mdW5jdGlvbiB1c2VWYWxpZGF0aW9uKGFyZ3MpIHtcbiAgdXNlRGV2U2V0dXBXYXJuaW5nKCgpID0+IHtcbiAgICBydW5DaGVja3MoYXJncywgc2hhcmVkKTtcbiAgICBpZiAoYXJncy5wcm9wcy5tb2RlID09PSAnc3RhbmRhcmQnKSB7XG4gICAgICBydW5DaGVja3MoYXJncywgc3RhbmRhcmQpO1xuICAgIH1cbiAgICBpZiAoYXJncy5wcm9wcy5tb2RlID09PSAndmlydHVhbCcpIHtcbiAgICAgIHJ1bkNoZWNrcyhhcmdzLCB2aXJ0dWFsKTtcbiAgICB9XG4gIH0pO1xufVxuXG5jbGFzcyBBbmltYXRlSW5PdXQgZXh0ZW5kcyBSZWFjdC5QdXJlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBpc1Zpc2libGU6IEJvb2xlYW4odGhpcy5wcm9wcy5vbiksXG4gICAgICBkYXRhOiB0aGlzLnByb3BzLm9uLFxuICAgICAgYW5pbWF0ZTogdGhpcy5wcm9wcy5zaG91bGRBbmltYXRlICYmIHRoaXMucHJvcHMub24gPyAnb3BlbicgOiAnbm9uZSdcbiAgICB9O1xuICAgIHRoaXMub25DbG9zZSA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLnN0YXRlLmFuaW1hdGUgIT09ICdjbG9zZScpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGlzVmlzaWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH07XG4gIH1cbiAgc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhwcm9wcywgc3RhdGUpIHtcbiAgICBpZiAoIXByb3BzLnNob3VsZEFuaW1hdGUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzVmlzaWJsZTogQm9vbGVhbihwcm9wcy5vbiksXG4gICAgICAgIGRhdGE6IHByb3BzLm9uLFxuICAgICAgICBhbmltYXRlOiAnbm9uZSdcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChwcm9wcy5vbikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNWaXNpYmxlOiB0cnVlLFxuICAgICAgICBkYXRhOiBwcm9wcy5vbixcbiAgICAgICAgYW5pbWF0ZTogJ29wZW4nXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoc3RhdGUuaXNWaXNpYmxlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpc1Zpc2libGU6IHRydWUsXG4gICAgICAgIGRhdGE6IHN0YXRlLmRhdGEsXG4gICAgICAgIGFuaW1hdGU6ICdjbG9zZSdcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBpc1Zpc2libGU6IGZhbHNlLFxuICAgICAgYW5pbWF0ZTogJ2Nsb3NlJyxcbiAgICAgIGRhdGE6IG51bGxcbiAgICB9O1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBpZiAoIXRoaXMuc3RhdGUuaXNWaXNpYmxlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgcHJvdmlkZWQgPSB7XG4gICAgICBvbkNsb3NlOiB0aGlzLm9uQ2xvc2UsXG4gICAgICBkYXRhOiB0aGlzLnN0YXRlLmRhdGEsXG4gICAgICBhbmltYXRlOiB0aGlzLnN0YXRlLmFuaW1hdGVcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuKHByb3ZpZGVkKTtcbiAgfVxufVxuXG5jb25zdCBEcm9wcGFibGUgPSBwcm9wcyA9PiB7XG4gIGNvbnN0IGFwcENvbnRleHQgPSB1c2VDb250ZXh0KEFwcENvbnRleHQpO1xuICAhYXBwQ29udGV4dCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0NvdWxkIG5vdCBmaW5kIGFwcCBjb250ZXh0JykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICBjb25zdCB7XG4gICAgY29udGV4dElkLFxuICAgIGlzTW92ZW1lbnRBbGxvd2VkXG4gIH0gPSBhcHBDb250ZXh0O1xuICBjb25zdCBkcm9wcGFibGVSZWYgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IHBsYWNlaG9sZGVyUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCB7XG4gICAgY2hpbGRyZW4sXG4gICAgZHJvcHBhYmxlSWQsXG4gICAgdHlwZSxcbiAgICBtb2RlLFxuICAgIGRpcmVjdGlvbixcbiAgICBpZ25vcmVDb250YWluZXJDbGlwcGluZyxcbiAgICBpc0Ryb3BEaXNhYmxlZCxcbiAgICBpc0NvbWJpbmVFbmFibGVkLFxuICAgIHNuYXBzaG90LFxuICAgIHVzZUNsb25lLFxuICAgIHVwZGF0ZVZpZXdwb3J0TWF4U2Nyb2xsLFxuICAgIGdldENvbnRhaW5lckZvckNsb25lXG4gIH0gPSBwcm9wcztcbiAgY29uc3QgZ2V0RHJvcHBhYmxlUmVmID0gdXNlQ2FsbGJhY2soKCkgPT4gZHJvcHBhYmxlUmVmLmN1cnJlbnQsIFtdKTtcbiAgY29uc3Qgc2V0RHJvcHBhYmxlUmVmID0gdXNlQ2FsbGJhY2soKHZhbHVlID0gbnVsbCkgPT4ge1xuICAgIGRyb3BwYWJsZVJlZi5jdXJyZW50ID0gdmFsdWU7XG4gIH0sIFtdKTtcbiAgY29uc3QgZ2V0UGxhY2Vob2xkZXJSZWYgPSB1c2VDYWxsYmFjaygoKSA9PiBwbGFjZWhvbGRlclJlZi5jdXJyZW50LCBbXSk7XG4gIGNvbnN0IHNldFBsYWNlaG9sZGVyUmVmID0gdXNlQ2FsbGJhY2soKHZhbHVlID0gbnVsbCkgPT4ge1xuICAgIHBsYWNlaG9sZGVyUmVmLmN1cnJlbnQgPSB2YWx1ZTtcbiAgfSwgW10pO1xuICB1c2VWYWxpZGF0aW9uKHtcbiAgICBwcm9wcyxcbiAgICBnZXREcm9wcGFibGVSZWYsXG4gICAgZ2V0UGxhY2Vob2xkZXJSZWZcbiAgfSk7XG4gIGNvbnN0IG9uUGxhY2Vob2xkZXJUcmFuc2l0aW9uRW5kID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmIChpc01vdmVtZW50QWxsb3dlZCgpKSB7XG4gICAgICB1cGRhdGVWaWV3cG9ydE1heFNjcm9sbCh7XG4gICAgICAgIG1heFNjcm9sbDogZ2V0TWF4V2luZG93U2Nyb2xsKClcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgW2lzTW92ZW1lbnRBbGxvd2VkLCB1cGRhdGVWaWV3cG9ydE1heFNjcm9sbF0pO1xuICB1c2VEcm9wcGFibGVQdWJsaXNoZXIoe1xuICAgIGRyb3BwYWJsZUlkLFxuICAgIHR5cGUsXG4gICAgbW9kZSxcbiAgICBkaXJlY3Rpb24sXG4gICAgaXNEcm9wRGlzYWJsZWQsXG4gICAgaXNDb21iaW5lRW5hYmxlZCxcbiAgICBpZ25vcmVDb250YWluZXJDbGlwcGluZyxcbiAgICBnZXREcm9wcGFibGVSZWZcbiAgfSk7XG4gIGNvbnN0IHBsYWNlaG9sZGVyID0gdXNlTWVtbygoKSA9PiBSZWFjdC5jcmVhdGVFbGVtZW50KEFuaW1hdGVJbk91dCwge1xuICAgIG9uOiBwcm9wcy5wbGFjZWhvbGRlcixcbiAgICBzaG91bGRBbmltYXRlOiBwcm9wcy5zaG91bGRBbmltYXRlUGxhY2Vob2xkZXJcbiAgfSwgKHtcbiAgICBvbkNsb3NlLFxuICAgIGRhdGEsXG4gICAgYW5pbWF0ZVxuICB9KSA9PiBSZWFjdC5jcmVhdGVFbGVtZW50KFBsYWNlaG9sZGVyJDEsIHtcbiAgICBwbGFjZWhvbGRlcjogZGF0YSxcbiAgICBvbkNsb3NlOiBvbkNsb3NlLFxuICAgIGlubmVyUmVmOiBzZXRQbGFjZWhvbGRlclJlZixcbiAgICBhbmltYXRlOiBhbmltYXRlLFxuICAgIGNvbnRleHRJZDogY29udGV4dElkLFxuICAgIG9uVHJhbnNpdGlvbkVuZDogb25QbGFjZWhvbGRlclRyYW5zaXRpb25FbmRcbiAgfSkpLCBbY29udGV4dElkLCBvblBsYWNlaG9sZGVyVHJhbnNpdGlvbkVuZCwgcHJvcHMucGxhY2Vob2xkZXIsIHByb3BzLnNob3VsZEFuaW1hdGVQbGFjZWhvbGRlciwgc2V0UGxhY2Vob2xkZXJSZWZdKTtcbiAgY29uc3QgcHJvdmlkZWQgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgaW5uZXJSZWY6IHNldERyb3BwYWJsZVJlZixcbiAgICBwbGFjZWhvbGRlcixcbiAgICBkcm9wcGFibGVQcm9wczoge1xuICAgICAgJ2RhdGEtcmZkLWRyb3BwYWJsZS1pZCc6IGRyb3BwYWJsZUlkLFxuICAgICAgJ2RhdGEtcmZkLWRyb3BwYWJsZS1jb250ZXh0LWlkJzogY29udGV4dElkXG4gICAgfVxuICB9KSwgW2NvbnRleHRJZCwgZHJvcHBhYmxlSWQsIHBsYWNlaG9sZGVyLCBzZXREcm9wcGFibGVSZWZdKTtcbiAgY29uc3QgaXNVc2luZ0Nsb25lRm9yID0gdXNlQ2xvbmUgPyB1c2VDbG9uZS5kcmFnZ2luZy5kcmFnZ2FibGVJZCA6IG51bGw7XG4gIGNvbnN0IGRyb3BwYWJsZUNvbnRleHQgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgZHJvcHBhYmxlSWQsXG4gICAgdHlwZSxcbiAgICBpc1VzaW5nQ2xvbmVGb3JcbiAgfSksIFtkcm9wcGFibGVJZCwgaXNVc2luZ0Nsb25lRm9yLCB0eXBlXSk7XG4gIGZ1bmN0aW9uIGdldENsb25lKCkge1xuICAgIGlmICghdXNlQ2xvbmUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBkcmFnZ2luZyxcbiAgICAgIHJlbmRlclxuICAgIH0gPSB1c2VDbG9uZTtcbiAgICBjb25zdCBub2RlID0gUmVhY3QuY3JlYXRlRWxlbWVudChQcml2YXRlRHJhZ2dhYmxlLCB7XG4gICAgICBkcmFnZ2FibGVJZDogZHJhZ2dpbmcuZHJhZ2dhYmxlSWQsXG4gICAgICBpbmRleDogZHJhZ2dpbmcuc291cmNlLmluZGV4LFxuICAgICAgaXNDbG9uZTogdHJ1ZSxcbiAgICAgIGlzRW5hYmxlZDogdHJ1ZSxcbiAgICAgIHNob3VsZFJlc3BlY3RGb3JjZVByZXNzOiBmYWxzZSxcbiAgICAgIGNhbkRyYWdJbnRlcmFjdGl2ZUVsZW1lbnRzOiB0cnVlXG4gICAgfSwgKGRyYWdnYWJsZVByb3ZpZGVkLCBkcmFnZ2FibGVTbmFwc2hvdCkgPT4gcmVuZGVyKGRyYWdnYWJsZVByb3ZpZGVkLCBkcmFnZ2FibGVTbmFwc2hvdCwgZHJhZ2dpbmcpKTtcbiAgICByZXR1cm4gUmVhY3RET00uY3JlYXRlUG9ydGFsKG5vZGUsIGdldENvbnRhaW5lckZvckNsb25lKCkpO1xuICB9XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KERyb3BwYWJsZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogZHJvcHBhYmxlQ29udGV4dFxuICB9LCBjaGlsZHJlbihwcm92aWRlZCwgc25hcHNob3QpLCBnZXRDbG9uZSgpKTtcbn07XG52YXIgRHJvcHBhYmxlJDEgPSBEcm9wcGFibGU7XG5cbmZ1bmN0aW9uIGdldEJvZHkoKSB7XG4gICFkb2N1bWVudC5ib2R5ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnZG9jdW1lbnQuYm9keSBpcyBub3QgcmVhZHknKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIHJldHVybiBkb2N1bWVudC5ib2R5O1xufVxuY29uc3QgZGVmYXVsdFByb3BzID0ge1xuICBtb2RlOiAnc3RhbmRhcmQnLFxuICB0eXBlOiAnREVGQVVMVCcsXG4gIGRpcmVjdGlvbjogJ3ZlcnRpY2FsJyxcbiAgaXNEcm9wRGlzYWJsZWQ6IGZhbHNlLFxuICBpc0NvbWJpbmVFbmFibGVkOiBmYWxzZSxcbiAgaWdub3JlQ29udGFpbmVyQ2xpcHBpbmc6IGZhbHNlLFxuICByZW5kZXJDbG9uZTogbnVsbCxcbiAgZ2V0Q29udGFpbmVyRm9yQ2xvbmU6IGdldEJvZHlcbn07XG5jb25zdCBhdHRhY2hEZWZhdWx0UHJvcHNUb093blByb3BzID0gb3duUHJvcHMgPT4ge1xuICBsZXQgbWVyZ2VkUHJvcHMgPSB7XG4gICAgLi4ub3duUHJvcHNcbiAgfTtcbiAgbGV0IGRlZmF1bHRQcm9wS2V5O1xuICBmb3IgKGRlZmF1bHRQcm9wS2V5IGluIGRlZmF1bHRQcm9wcykge1xuICAgIGlmIChvd25Qcm9wc1tkZWZhdWx0UHJvcEtleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgbWVyZ2VkUHJvcHMgPSB7XG4gICAgICAgIC4uLm1lcmdlZFByb3BzLFxuICAgICAgICBbZGVmYXVsdFByb3BLZXldOiBkZWZhdWx0UHJvcHNbZGVmYXVsdFByb3BLZXldXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWVyZ2VkUHJvcHM7XG59O1xuY29uc3QgaXNNYXRjaGluZ1R5cGUgPSAodHlwZSwgY3JpdGljYWwpID0+IHR5cGUgPT09IGNyaXRpY2FsLmRyb3BwYWJsZS50eXBlO1xuY29uc3QgZ2V0RHJhZ2dhYmxlID0gKGNyaXRpY2FsLCBkaW1lbnNpb25zKSA9PiBkaW1lbnNpb25zLmRyYWdnYWJsZXNbY3JpdGljYWwuZHJhZ2dhYmxlLmlkXTtcbmNvbnN0IG1ha2VNYXBTdGF0ZVRvUHJvcHMgPSAoKSA9PiB7XG4gIGNvbnN0IGlkbGVXaXRoQW5pbWF0aW9uID0ge1xuICAgIHBsYWNlaG9sZGVyOiBudWxsLFxuICAgIHNob3VsZEFuaW1hdGVQbGFjZWhvbGRlcjogdHJ1ZSxcbiAgICBzbmFwc2hvdDoge1xuICAgICAgaXNEcmFnZ2luZ092ZXI6IGZhbHNlLFxuICAgICAgZHJhZ2dpbmdPdmVyV2l0aDogbnVsbCxcbiAgICAgIGRyYWdnaW5nRnJvbVRoaXNXaXRoOiBudWxsLFxuICAgICAgaXNVc2luZ1BsYWNlaG9sZGVyOiBmYWxzZVxuICAgIH0sXG4gICAgdXNlQ2xvbmU6IG51bGxcbiAgfTtcbiAgY29uc3QgaWRsZVdpdGhvdXRBbmltYXRpb24gPSB7XG4gICAgLi4uaWRsZVdpdGhBbmltYXRpb24sXG4gICAgc2hvdWxkQW5pbWF0ZVBsYWNlaG9sZGVyOiBmYWxzZVxuICB9O1xuICBjb25zdCBnZXREcmFnZ2FibGVSdWJyaWMgPSBtZW1vaXplT25lKGRlc2NyaXB0b3IgPT4gKHtcbiAgICBkcmFnZ2FibGVJZDogZGVzY3JpcHRvci5pZCxcbiAgICB0eXBlOiBkZXNjcmlwdG9yLnR5cGUsXG4gICAgc291cmNlOiB7XG4gICAgICBpbmRleDogZGVzY3JpcHRvci5pbmRleCxcbiAgICAgIGRyb3BwYWJsZUlkOiBkZXNjcmlwdG9yLmRyb3BwYWJsZUlkXG4gICAgfVxuICB9KSk7XG4gIGNvbnN0IGdldE1hcFByb3BzID0gbWVtb2l6ZU9uZSgoaWQsIGlzRW5hYmxlZCwgaXNEcmFnZ2luZ092ZXJGb3JDb25zdW1lciwgaXNEcmFnZ2luZ092ZXJGb3JJbXBhY3QsIGRyYWdnaW5nLCByZW5kZXJDbG9uZSkgPT4ge1xuICAgIGNvbnN0IGRyYWdnYWJsZUlkID0gZHJhZ2dpbmcuZGVzY3JpcHRvci5pZDtcbiAgICBjb25zdCBpc0hvbWUgPSBkcmFnZ2luZy5kZXNjcmlwdG9yLmRyb3BwYWJsZUlkID09PSBpZDtcbiAgICBpZiAoaXNIb21lKSB7XG4gICAgICBjb25zdCB1c2VDbG9uZSA9IHJlbmRlckNsb25lID8ge1xuICAgICAgICByZW5kZXI6IHJlbmRlckNsb25lLFxuICAgICAgICBkcmFnZ2luZzogZ2V0RHJhZ2dhYmxlUnVicmljKGRyYWdnaW5nLmRlc2NyaXB0b3IpXG4gICAgICB9IDogbnVsbDtcbiAgICAgIGNvbnN0IHNuYXBzaG90ID0ge1xuICAgICAgICBpc0RyYWdnaW5nT3ZlcjogaXNEcmFnZ2luZ092ZXJGb3JDb25zdW1lcixcbiAgICAgICAgZHJhZ2dpbmdPdmVyV2l0aDogaXNEcmFnZ2luZ092ZXJGb3JDb25zdW1lciA/IGRyYWdnYWJsZUlkIDogbnVsbCxcbiAgICAgICAgZHJhZ2dpbmdGcm9tVGhpc1dpdGg6IGRyYWdnYWJsZUlkLFxuICAgICAgICBpc1VzaW5nUGxhY2Vob2xkZXI6IHRydWVcbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwbGFjZWhvbGRlcjogZHJhZ2dpbmcucGxhY2Vob2xkZXIsXG4gICAgICAgIHNob3VsZEFuaW1hdGVQbGFjZWhvbGRlcjogZmFsc2UsXG4gICAgICAgIHNuYXBzaG90LFxuICAgICAgICB1c2VDbG9uZVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKCFpc0VuYWJsZWQpIHtcbiAgICAgIHJldHVybiBpZGxlV2l0aG91dEFuaW1hdGlvbjtcbiAgICB9XG4gICAgaWYgKCFpc0RyYWdnaW5nT3ZlckZvckltcGFjdCkge1xuICAgICAgcmV0dXJuIGlkbGVXaXRoQW5pbWF0aW9uO1xuICAgIH1cbiAgICBjb25zdCBzbmFwc2hvdCA9IHtcbiAgICAgIGlzRHJhZ2dpbmdPdmVyOiBpc0RyYWdnaW5nT3ZlckZvckNvbnN1bWVyLFxuICAgICAgZHJhZ2dpbmdPdmVyV2l0aDogZHJhZ2dhYmxlSWQsXG4gICAgICBkcmFnZ2luZ0Zyb21UaGlzV2l0aDogbnVsbCxcbiAgICAgIGlzVXNpbmdQbGFjZWhvbGRlcjogdHJ1ZVxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIHBsYWNlaG9sZGVyOiBkcmFnZ2luZy5wbGFjZWhvbGRlcixcbiAgICAgIHNob3VsZEFuaW1hdGVQbGFjZWhvbGRlcjogdHJ1ZSxcbiAgICAgIHNuYXBzaG90LFxuICAgICAgdXNlQ2xvbmU6IG51bGxcbiAgICB9O1xuICB9KTtcbiAgY29uc3Qgc2VsZWN0b3IgPSAoc3RhdGUsIG93blByb3BzKSA9PiB7XG4gICAgY29uc3Qgb3duUHJvcHNXaXRoRGVmYXVsdFByb3BzID0gYXR0YWNoRGVmYXVsdFByb3BzVG9Pd25Qcm9wcyhvd25Qcm9wcyk7XG4gICAgY29uc3QgaWQgPSBvd25Qcm9wc1dpdGhEZWZhdWx0UHJvcHMuZHJvcHBhYmxlSWQ7XG4gICAgY29uc3QgdHlwZSA9IG93blByb3BzV2l0aERlZmF1bHRQcm9wcy50eXBlO1xuICAgIGNvbnN0IGlzRW5hYmxlZCA9ICFvd25Qcm9wc1dpdGhEZWZhdWx0UHJvcHMuaXNEcm9wRGlzYWJsZWQ7XG4gICAgY29uc3QgcmVuZGVyQ2xvbmUgPSBvd25Qcm9wc1dpdGhEZWZhdWx0UHJvcHMucmVuZGVyQ2xvbmU7XG4gICAgaWYgKGlzRHJhZ2dpbmcoc3RhdGUpKSB7XG4gICAgICBjb25zdCBjcml0aWNhbCA9IHN0YXRlLmNyaXRpY2FsO1xuICAgICAgaWYgKCFpc01hdGNoaW5nVHlwZSh0eXBlLCBjcml0aWNhbCkpIHtcbiAgICAgICAgcmV0dXJuIGlkbGVXaXRob3V0QW5pbWF0aW9uO1xuICAgICAgfVxuICAgICAgY29uc3QgZHJhZ2dpbmcgPSBnZXREcmFnZ2FibGUoY3JpdGljYWwsIHN0YXRlLmRpbWVuc2lvbnMpO1xuICAgICAgY29uc3QgaXNEcmFnZ2luZ092ZXIgPSB3aGF0SXNEcmFnZ2VkT3ZlcihzdGF0ZS5pbXBhY3QpID09PSBpZDtcbiAgICAgIHJldHVybiBnZXRNYXBQcm9wcyhpZCwgaXNFbmFibGVkLCBpc0RyYWdnaW5nT3ZlciwgaXNEcmFnZ2luZ092ZXIsIGRyYWdnaW5nLCByZW5kZXJDbG9uZSk7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0RST1BfQU5JTUFUSU5HJykge1xuICAgICAgY29uc3QgY29tcGxldGVkID0gc3RhdGUuY29tcGxldGVkO1xuICAgICAgaWYgKCFpc01hdGNoaW5nVHlwZSh0eXBlLCBjb21wbGV0ZWQuY3JpdGljYWwpKSB7XG4gICAgICAgIHJldHVybiBpZGxlV2l0aG91dEFuaW1hdGlvbjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRyYWdnaW5nID0gZ2V0RHJhZ2dhYmxlKGNvbXBsZXRlZC5jcml0aWNhbCwgc3RhdGUuZGltZW5zaW9ucyk7XG4gICAgICByZXR1cm4gZ2V0TWFwUHJvcHMoaWQsIGlzRW5hYmxlZCwgd2hhdElzRHJhZ2dlZE92ZXJGcm9tUmVzdWx0KGNvbXBsZXRlZC5yZXN1bHQpID09PSBpZCwgd2hhdElzRHJhZ2dlZE92ZXIoY29tcGxldGVkLmltcGFjdCkgPT09IGlkLCBkcmFnZ2luZywgcmVuZGVyQ2xvbmUpO1xuICAgIH1cbiAgICBpZiAoc3RhdGUucGhhc2UgPT09ICdJRExFJyAmJiBzdGF0ZS5jb21wbGV0ZWQgJiYgIXN0YXRlLnNob3VsZEZsdXNoKSB7XG4gICAgICBjb25zdCBjb21wbGV0ZWQgPSBzdGF0ZS5jb21wbGV0ZWQ7XG4gICAgICBpZiAoIWlzTWF0Y2hpbmdUeXBlKHR5cGUsIGNvbXBsZXRlZC5jcml0aWNhbCkpIHtcbiAgICAgICAgcmV0dXJuIGlkbGVXaXRob3V0QW5pbWF0aW9uO1xuICAgICAgfVxuICAgICAgY29uc3Qgd2FzT3ZlciA9IHdoYXRJc0RyYWdnZWRPdmVyKGNvbXBsZXRlZC5pbXBhY3QpID09PSBpZDtcbiAgICAgIGNvbnN0IHdhc0NvbWJpbmluZyA9IEJvb2xlYW4oY29tcGxldGVkLmltcGFjdC5hdCAmJiBjb21wbGV0ZWQuaW1wYWN0LmF0LnR5cGUgPT09ICdDT01CSU5FJyk7XG4gICAgICBjb25zdCBpc0hvbWUgPSBjb21wbGV0ZWQuY3JpdGljYWwuZHJvcHBhYmxlLmlkID09PSBpZDtcbiAgICAgIGlmICh3YXNPdmVyKSB7XG4gICAgICAgIHJldHVybiB3YXNDb21iaW5pbmcgPyBpZGxlV2l0aEFuaW1hdGlvbiA6IGlkbGVXaXRob3V0QW5pbWF0aW9uO1xuICAgICAgfVxuICAgICAgaWYgKGlzSG9tZSkge1xuICAgICAgICByZXR1cm4gaWRsZVdpdGhBbmltYXRpb247XG4gICAgICB9XG4gICAgICByZXR1cm4gaWRsZVdpdGhvdXRBbmltYXRpb247XG4gICAgfVxuICAgIHJldHVybiBpZGxlV2l0aG91dEFuaW1hdGlvbjtcbiAgfTtcbiAgcmV0dXJuIHNlbGVjdG9yO1xufTtcbmNvbnN0IG1hcERpc3BhdGNoVG9Qcm9wcyA9IHtcbiAgdXBkYXRlVmlld3BvcnRNYXhTY3JvbGw6IHVwZGF0ZVZpZXdwb3J0TWF4U2Nyb2xsXG59O1xuY29uc3QgQ29ubmVjdGVkRHJvcHBhYmxlID0gY29ubmVjdChtYWtlTWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIChzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcykgPT4ge1xuICByZXR1cm4ge1xuICAgIC4uLmF0dGFjaERlZmF1bHRQcm9wc1RvT3duUHJvcHMob3duUHJvcHMpLFxuICAgIC4uLnN0YXRlUHJvcHMsXG4gICAgLi4uZGlzcGF0Y2hQcm9wc1xuICB9O1xufSwge1xuICBjb250ZXh0OiBTdG9yZUNvbnRleHQsXG4gIGFyZVN0YXRlUHJvcHNFcXVhbDogaXNTdHJpY3RFcXVhbFxufSkoRHJvcHBhYmxlJDEpO1xudmFyIENvbm5lY3RlZERyb3BwYWJsZSQxID0gQ29ubmVjdGVkRHJvcHBhYmxlO1xuXG5leHBvcnQgeyBEcmFnRHJvcENvbnRleHQsIFB1YmxpY0RyYWdnYWJsZSBhcyBEcmFnZ2FibGUsIENvbm5lY3RlZERyb3BwYWJsZSQxIGFzIERyb3BwYWJsZSwgcmVzZXRTZXJ2ZXJDb250ZXh0LCB1c2VLZXlib2FyZFNlbnNvciwgdXNlTW91c2VTZW5zb3IsIHVzZVRvdWNoU2Vuc29yIH07XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VMYXlvdXRFZmZlY3QkMSIsInVzZUVmZmVjdCIsInVzZVJlZiIsInVzZVN0YXRlIiwidXNlQ29udGV4dCIsIlJlYWN0RE9NIiwiZmx1c2hTeW5jIiwiY3JlYXRlU3RvcmUiLCJjcmVhdGVTdG9yZSQxIiwiYXBwbHlNaWRkbGV3YXJlIiwiY29tcG9zZSIsImJpbmRBY3Rpb25DcmVhdG9ycyIsIlByb3ZpZGVyIiwiY29ubmVjdCIsInVzZU1lbW8iLCJ1c2VDYWxsYmFjayIsImdldFJlY3QiLCJleHBhbmQiLCJvZmZzZXQiLCJ3aXRoU2Nyb2xsIiwiY2FsY3VsYXRlQm94IiwiZ2V0Qm94IiwiY3JlYXRlQm94IiwibWVtb2l6ZU9uZSIsInJhZlNjaGQiLCJfZXh0ZW5kcyIsImlzUHJvZHVjdGlvbiQxIiwicHJvY2VzcyIsInNwYWNlc0FuZFRhYnMiLCJsaW5lU3RhcnRXaXRoU3BhY2VzIiwiY2xlYW4kMiIsInZhbHVlIiwicmVwbGFjZSIsInRyaW0iLCJnZXREZXZNZXNzYWdlIiwibWVzc2FnZSIsImdldEZvcm1hdHRlZE1lc3NhZ2UiLCJpc0Rpc2FibGVkRmxhZyIsImxvZyIsInR5cGUiLCJ3aW5kb3ciLCJjb25zb2xlIiwid2FybmluZyIsImJpbmQiLCJlcnJvciIsIm5vb3AkMiIsImdldE9wdGlvbnMiLCJzaGFyZWQiLCJmcm9tQmluZGluZyIsImJpbmRFdmVudHMiLCJlbCIsImJpbmRpbmdzIiwic2hhcmVkT3B0aW9ucyIsInVuYmluZGluZ3MiLCJtYXAiLCJiaW5kaW5nIiwib3B0aW9ucyIsImFkZEV2ZW50TGlzdGVuZXIiLCJldmVudE5hbWUiLCJmbiIsInVuYmluZCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJ1bmJpbmRBbGwiLCJmb3JFYWNoIiwiaXNQcm9kdWN0aW9uIiwicHJlZml4JDEiLCJSYmRJbnZhcmlhbnQiLCJFcnJvciIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiaW52YXJpYW50IiwiY29uZGl0aW9uIiwiRXJyb3JCb3VuZGFyeSIsIkNvbXBvbmVudCIsImNvbnN0cnVjdG9yIiwiYXJncyIsImNhbGxiYWNrcyIsIm9uV2luZG93RXJyb3IiLCJldmVudCIsImdldENhbGxiYWNrcyIsImlzRHJhZ2dpbmciLCJ0cnlBYm9ydCIsImVyciIsInByZXZlbnREZWZhdWx0Iiwic2V0Q2FsbGJhY2tzIiwiY29tcG9uZW50RGlkTW91bnQiLCJjb21wb25lbnREaWRDYXRjaCIsInNldFN0YXRlIiwiY29tcG9uZW50V2lsbFVubW91bnQiLCJyZW5kZXIiLCJwcm9wcyIsImNoaWxkcmVuIiwiZHJhZ0hhbmRsZVVzYWdlSW5zdHJ1Y3Rpb25zIiwicG9zaXRpb24iLCJpbmRleCIsIm9uRHJhZ1N0YXJ0Iiwic3RhcnQiLCJzb3VyY2UiLCJ3aXRoTG9jYXRpb24iLCJkZXN0aW5hdGlvbiIsImlzSW5Ib21lTGlzdCIsImRyb3BwYWJsZUlkIiwic3RhcnRQb3NpdGlvbiIsImVuZFBvc2l0aW9uIiwid2l0aENvbWJpbmUiLCJpZCIsImNvbWJpbmUiLCJpbkhvbWVMaXN0IiwiZHJhZ2dhYmxlSWQiLCJvbkRyYWdVcGRhdGUiLCJ1cGRhdGUiLCJsb2NhdGlvbiIsInJldHVybmVkVG9TdGFydCIsIm9uRHJhZ0VuZCIsInJlc3VsdCIsInJlYXNvbiIsInByZXNldCIsInByZXNldCQxIiwib3JpZ2luIiwieCIsInkiLCJhZGQiLCJwb2ludDEiLCJwb2ludDIiLCJzdWJ0cmFjdCIsImlzRXF1YWwkMSIsIm5lZ2F0ZSIsInBvaW50IiwicGF0Y2giLCJsaW5lIiwib3RoZXJWYWx1ZSIsImRpc3RhbmNlIiwiTWF0aCIsInNxcnQiLCJjbG9zZXN0JDEiLCJ0YXJnZXQiLCJwb2ludHMiLCJtaW4iLCJhcHBseSIsImV4ZWN1dGVDbGlwIiwiZnJhbWUiLCJzdWJqZWN0IiwidG9wIiwibWF4IiwicmlnaHQiLCJib3R0b20iLCJsZWZ0Iiwid2lkdGgiLCJoZWlnaHQiLCJvZmZzZXRCeVBvc2l0aW9uIiwic3BhY2luZyIsImdldENvcm5lcnMiLCJub1NwYWNpbmciLCJzY3JvbGwkMSIsInNjcm9sbCIsImRpZmYiLCJkaXNwbGFjZW1lbnQiLCJpbmNyZWFzZSIsImF4aXMiLCJ3aXRoUGxhY2Vob2xkZXIiLCJpbmNyZWFzZWRCeSIsImVuZCIsImNsaXAiLCJzaG91bGRDbGlwU3ViamVjdCIsInBhZ2VNYXJnaW5Cb3giLCJnZXRTdWJqZWN0IiwicGFnZSIsInNjcm9sbGVkIiwibWFyZ2luQm94IiwiaW5jcmVhc2VkIiwiY2xpcHBlZCIsImFjdGl2ZSIsInNjcm9sbERyb3BwYWJsZSIsImRyb3BwYWJsZSIsIm5ld1Njcm9sbCIsInNjcm9sbGFibGUiLCJzY3JvbGxEaWZmIiwiaW5pdGlhbCIsInNjcm9sbERpc3BsYWNlbWVudCIsImN1cnJlbnQiLCJ0b0Ryb3BwYWJsZU1hcCIsImRyb3BwYWJsZXMiLCJyZWR1Y2UiLCJwcmV2aW91cyIsImRlc2NyaXB0b3IiLCJ0b0RyYWdnYWJsZU1hcCIsImRyYWdnYWJsZXMiLCJ0b0Ryb3BwYWJsZUxpc3QiLCJPYmplY3QiLCJ2YWx1ZXMiLCJ0b0RyYWdnYWJsZUxpc3QiLCJnZXREcmFnZ2FibGVzSW5zaWRlRHJvcHBhYmxlIiwiZmlsdGVyIiwiZHJhZ2dhYmxlIiwic29ydCIsImEiLCJiIiwidHJ5R2V0RGVzdGluYXRpb24iLCJpbXBhY3QiLCJhdCIsInRyeUdldENvbWJpbmUiLCJyZW1vdmVEcmFnZ2FibGVGcm9tTGlzdCIsInJlbW92ZSIsImxpc3QiLCJpdGVtIiwibW92ZVRvTmV4dENvbWJpbmUiLCJpc01vdmluZ0ZvcndhcmQiLCJpbnNpZGVEZXN0aW5hdGlvbiIsInByZXZpb3VzSW1wYWN0IiwiaXNDb21iaW5lRW5hYmxlZCIsImdldEltcGFjdCIsImFsbCIsImRpc3BsYWNlZCIsImNsb3Nlc3RJZCIsImxlbmd0aCIsIndpdGhvdXREcmFnZ2FibGUiLCJsYXN0IiwiaW5kZXhPZkNsb3Nlc3QiLCJmaW5kSW5kZXgiLCJkIiwicHJvcG9zZWRJbmRleCIsImJlZm9yZSIsImlzSG9tZU9mIiwibm9EaXNwbGFjZWRCeSIsImVtcHR5R3JvdXBzIiwiaW52aXNpYmxlIiwidmlzaWJsZSIsIm5vSW1wYWN0IiwiZGlzcGxhY2VkQnkiLCJub0ltcGFjdCQxIiwiaXNXaXRoaW4iLCJsb3dlckJvdW5kIiwidXBwZXJCb3VuZCIsImlzUGFydGlhbGx5VmlzaWJsZVRocm91Z2hGcmFtZSIsImlzV2l0aGluVmVydGljYWwiLCJpc1dpdGhpbkhvcml6b250YWwiLCJpc0NvbnRhaW5lZCIsImlzUGFydGlhbGx5VmlzaWJsZVZlcnRpY2FsbHkiLCJpc1BhcnRpYWxseVZpc2libGVIb3Jpem9udGFsbHkiLCJpc1BhcnRpYWxseUNvbnRhaW5lZCIsImlzQmlnZ2VyVmVydGljYWxseSIsImlzQmlnZ2VySG9yaXpvbnRhbGx5IiwiaXNUYXJnZXRCaWdnZXJUaGFuRnJhbWUiLCJpc1RhcmdldEJpZ2dlck9uT25lQXhpcyIsImlzVG90YWxseVZpc2libGVUaHJvdWdoRnJhbWUiLCJ2ZXJ0aWNhbCIsImRpcmVjdGlvbiIsImNyb3NzQXhpc0xpbmUiLCJzaXplIiwiY3Jvc3NBeGlzU3RhcnQiLCJjcm9zc0F4aXNFbmQiLCJjcm9zc0F4aXNTaXplIiwiaG9yaXpvbnRhbCIsImlzVG90YWxseVZpc2libGVUaHJvdWdoRnJhbWVPbkF4aXMiLCJnZXREcm9wcGFibGVEaXNwbGFjZWQiLCJpc1Zpc2libGVJbkRyb3BwYWJsZSIsImlzVmlzaWJsZVRocm91Z2hGcmFtZUZuIiwiaXNWaXNpYmxlSW5WaWV3cG9ydCIsInZpZXdwb3J0IiwiaXNWaXNpYmxlJDEiLCJ0b0JlRGlzcGxhY2VkIiwid2l0aERyb3BwYWJsZURpc3BsYWNlbWVudCIsImRpc3BsYWNlZFRhcmdldCIsImlzUGFydGlhbGx5VmlzaWJsZSIsImlzVG90YWxseVZpc2libGUiLCJpc1RvdGFsbHlWaXNpYmxlT25BeGlzIiwiZ2V0U2hvdWxkQW5pbWF0ZSIsImZvcmNlU2hvdWxkQW5pbWF0ZSIsInNob3VsZEFuaW1hdGUiLCJnZXRUYXJnZXQiLCJleHBhbmRCeSIsImdldERpc3BsYWNlbWVudEdyb3VwcyIsImFmdGVyRHJhZ2dpbmciLCJncm91cHMiLCJwdXNoIiwiaXNWaXNpYmxlIiwiZ2V0SW5kZXhPZkxhc3RJdGVtIiwiaW5kZXhPZkxhc3RJdGVtIiwiZ29BdEVuZCIsIm5ld0luZGV4IiwiY2FsY3VsYXRlUmVvcmRlckltcGFjdCIsIm1hdGNoIiwiZmluZCIsIndpdGhvdXREcmFnZ2luZyIsInNsaWNlRnJvbSIsImluZGV4T2YiLCJpbXBhY3RlZCIsInNsaWNlIiwiZGlkU3RhcnRBZnRlckNyaXRpY2FsIiwiYWZ0ZXJDcml0aWNhbCIsIkJvb2xlYW4iLCJlZmZlY3RlZCIsImZyb21Db21iaW5lIiwiY29tYmluZUlkIiwiY29tYmluZVdpdGgiLCJjb21iaW5lV2l0aEluZGV4IiwiZGlkQ29tYmluZVdpdGhTdGFydEFmdGVyQ3JpdGljYWwiLCJmcm9tUmVvcmRlciIsImN1cnJlbnRJbmRleCIsImZpcnN0SW5kZXgiLCJsYXN0SW5kZXgiLCJtb3ZlVG9OZXh0SW5kZXgiLCJ3YXNBdCIsImdldENvbWJpbmVkSXRlbURpc3BsYWNlbWVudCIsImlzRGlzcGxhY2VkIiwid2hlbkNvbWJpbmluZyIsImNlbnRlciIsImJvcmRlckJveCIsImRpc3BsYWNlQnkiLCJkaXN0YW5jZUZyb21TdGFydFRvQm9yZGVyQm94Q2VudGVyIiwiYm94IiwibWFyZ2luIiwiZGlzdGFuY2VGcm9tRW5kVG9Cb3JkZXJCb3hDZW50ZXIiLCJnZXRDcm9zc0F4aXNCb3JkZXJCb3hDZW50ZXIiLCJpc01vdmluZyIsImdvQWZ0ZXIiLCJtb3ZlUmVsYXRpdmVUbyIsImdvQmVmb3JlIiwiZ29JbnRvU3RhcnQiLCJtb3ZlSW50byIsImNvbnRlbnRCb3giLCJ3aGVuUmVvcmRlcmluZyIsImRyYWdnYWJsZVBhZ2UiLCJjbG9zZXN0QWZ0ZXIiLCJjbG9zZXN0Iiwid2l0aERpc3BsYWNlbWVudCIsImdldFJlc3VsdFdpdGhvdXREcm9wcGFibGVEaXNwbGFjZW1lbnQiLCJvcmlnaW5hbCIsImdldFBhZ2VCb3JkZXJCb3hDZW50ZXJGcm9tSW1wYWN0Iiwid2l0aG91dERpc3BsYWNlbWVudCIsInNjcm9sbFZpZXdwb3J0IiwidXBkYXRlZCIsImdldERyYWdnYWJsZXMkMSIsImlkcyIsInRyeUdldFZpc2libGUiLCJpIiwic3BlY3VsYXRpdmVseUluY3JlYXNlIiwibWF4U2Nyb2xsQ2hhbmdlIiwic2Nyb2xsZWRWaWV3cG9ydCIsInNjcm9sbGVkRHJvcHBhYmxlIiwid2l0aFZpZXdwb3J0U2Nyb2xsIiwid2l0aERyb3BwYWJsZVNjcm9sbCIsIm5ld0ltcGFjdCIsIndpdGhWaWV3cG9ydERpc3BsYWNlbWVudCIsImdldENsaWVudEZyb21QYWdlQm9yZGVyQm94Q2VudGVyIiwicGFnZUJvcmRlckJveENlbnRlciIsIndpdGhvdXRQYWdlU2Nyb2xsQ2hhbmdlIiwiY2xpZW50IiwiaXNUb3RhbGx5VmlzaWJsZUluTmV3TG9jYXRpb24iLCJuZXdQYWdlQm9yZGVyQm94Q2VudGVyIiwib25seU9uTWFpbkF4aXMiLCJjaGFuZ2VOZWVkZWQiLCJzaGlmdGVkIiwibW92ZVRvTmV4dFBsYWNlIiwicHJldmlvdXNQYWdlQm9yZGVyQm94Q2VudGVyIiwicHJldmlvdXNDbGllbnRTZWxlY3Rpb24iLCJpc0VuYWJsZWQiLCJpc1Zpc2libGVJbk5ld0xvY2F0aW9uIiwiY2xpZW50U2VsZWN0aW9uIiwic2Nyb2xsSnVtcFJlcXVlc3QiLCJjYXV0aW91cyIsImdldEtub3duQWN0aXZlIiwicmVjdCIsImdldEJlc3RDcm9zc0F4aXNEcm9wcGFibGUiLCJpc0JldHdlZW5Tb3VyY2VDbGlwcGVkIiwiY2FuZGlkYXRlcyIsImFjdGl2ZU9mVGFyZ2V0IiwiaXNCZXR3ZWVuRGVzdGluYXRpb25DbGlwcGVkIiwiZmlyc3QiLCJzZWNvbmQiLCJhcnJheSIsImNvbnRhaW5zIiwiaXNXaXRoaW5Ecm9wcGFibGUiLCJnZXRDdXJyZW50UGFnZUJvcmRlckJveENlbnRlciIsImdldEN1cnJlbnRQYWdlQm9yZGVyQm94IiwiZ2V0Q2xvc2VzdERyYWdnYWJsZSIsInNvcnRlZCIsImRpc3RhbmNlVG9BIiwiZGlzdGFuY2VUb0IiLCJnZXREaXNwbGFjZWRCeSIsImdldFJlcXVpcmVkR3Jvd3RoRm9yUGxhY2Vob2xkZXIiLCJwbGFjZWhvbGRlclNpemUiLCJtb2RlIiwiYXZhaWxhYmxlU3BhY2UiLCJpbnNpZGVEcm9wcGFibGUiLCJzcGFjZVVzZWQiLCJzdW0iLCJkaW1lbnNpb24iLCJyZXF1aXJlZFNwYWNlIiwibmVlZHNUb0dyb3dCeSIsIndpdGhNYXhTY3JvbGwiLCJhZGRQbGFjZWhvbGRlciIsInJlcXVpcmVkR3Jvd3RoIiwiYWRkZWQiLCJvbGRGcmFtZU1heFNjcm9sbCIsIm1heFNjcm9sbCIsIm5ld0ZyYW1lIiwicmVtb3ZlUGxhY2Vob2xkZXIiLCJvbGRNYXhTY3JvbGwiLCJtb3ZlVG9OZXdEcm9wcGFibGUiLCJwcm9wb3NlZCIsInByb3Bvc2VkUGFnZUJvcmRlckJveENlbnRlciIsImlzR29pbmdCZWZvcmVUYXJnZXQiLCJyZWxhdGl2ZVRvIiwibW92ZUNyb3NzQXhpcyIsImlzT3ZlciIsIndoYXRJc0RyYWdnZWRPdmVyIiwiZ2V0RHJvcHBhYmxlT3ZlciQxIiwibW92ZUluRGlyZWN0aW9uIiwic3RhdGUiLCJpc0FjdHVhbGx5T3ZlciIsImRpbWVuc2lvbnMiLCJpc01haW5BeGlzTW92ZW1lbnRBbGxvd2VkIiwiaG9tZSIsImNyaXRpY2FsIiwiaXNNb3ZpbmdPbk1haW5BeGlzIiwiYm9yZGVyQm94Q2VudGVyIiwic2VsZWN0aW9uIiwiaXNNb3ZlbWVudEFsbG93ZWQiLCJwaGFzZSIsImlzUG9zaXRpb25JbkZyYW1lIiwicnVuIiwiZ2V0SGFzT3ZlcmxhcCIsImdldEZ1cnRoZXN0QXdheSIsInBhZ2VCb3JkZXJCb3giLCJzdGFydENlbnRlciIsImNhbmRpZGF0ZSIsImdldERyb3BwYWJsZU92ZXIiLCJjaGlsZENlbnRlciIsImlzU3RhcnRDb250YWluZWQiLCJpc0VuZENvbnRhaW5lZCIsIm9mZnNldFJlY3RCeVBvc2l0aW9uIiwiYXJlYSIsImdldElzRGlzcGxhY2VkIiwiYXRJbmRleCIsImdldFJlb3JkZXJJbXBhY3QiLCJwYWdlQm9yZGVyQm94V2l0aERyb3BwYWJsZVNjcm9sbCIsInRhcmdldFJlY3QiLCJ0YXJnZXRTdGFydCIsInRhcmdldEVuZCIsImNoaWxkIiwiZGlkU3RhcnRBZnRlckNyaXRpY2FsJDEiLCJjb21iaW5lVGhyZXNob2xkRGl2aXNvciIsImdldENvbWJpbmVJbXBhY3QiLCJjaGlsZFJlY3QiLCJjaGlsZFNpemUiLCJ0aHJlc2hvbGQiLCJnZXREcmFnSW1wYWN0IiwicGFnZU9mZnNldCIsImRlc3RpbmF0aW9uSWQiLCJwYXRjaERyb3BwYWJsZU1hcCIsImNsZWFyVW51c2VkUGxhY2Vob2xkZXIiLCJub3ciLCJsYXN0RHJvcHBhYmxlIiwicmVjb21wdXRlUGxhY2Vob2xkZXJzIiwiY2xlYW5lZCIsInBhdGNoZWQiLCJmb3JjZWRDbGllbnRTZWxlY3Rpb24iLCJmb3JjZWREaW1lbnNpb25zIiwiZm9yY2VkVmlld3BvcnQiLCJmb3JjZWRJbXBhY3QiLCJ3aXRoVXBkYXRlZFBsYWNlaG9sZGVycyIsImdldERyYWdnYWJsZXMiLCJyZWNvbXB1dGUiLCJnZXRDbGllbnRCb3JkZXJCb3hDZW50ZXIiLCJyZWZyZXNoU25hcCIsIm1vdmVtZW50TW9kZSIsIm5lZWRzVmlzaWJpbGl0eUNoZWNrIiwiZ2V0SG9tZUxvY2F0aW9uIiwiZ2V0TGlmdEVmZmVjdCIsImluc2lkZUhvbWUiLCJyYXdJbmRleCIsImluVmlydHVhbExpc3QiLCJwYXRjaERpbWVuc2lvbk1hcCIsImtleSIsImZpbmlzaCIsIm9mZnNldERyYWdnYWJsZSIsIm9mZnNldCQxIiwiaW5pdGlhbFdpbmRvd1Njcm9sbCIsIm1vdmVkIiwicGxhY2Vob2xkZXIiLCJnZXRGcmFtZSIsImFkanVzdEFkZGl0aW9uc0ZvclNjcm9sbENoYW5nZXMiLCJhZGRpdGlvbnMiLCJ1cGRhdGVkRHJvcHBhYmxlcyIsIndpbmRvd1Njcm9sbENoYW5nZSIsIm1vZGlmaWVkIiwiZHJvcHBhYmxlU2Nyb2xsQ2hhbmdlIiwidG90YWxDaGFuZ2UiLCJ0aW1pbmdzS2V5IiwicHVibGlzaFdoaWxlRHJhZ2dpbmdJblZpcnR1YWwiLCJwdWJsaXNoZWQiLCJ3aXRoU2Nyb2xsQ2hhbmdlIiwiZXhpc3RpbmciLCJ1cGRhdGVkQWRkaXRpb25zIiwicmVtb3ZhbHMiLCJ3YXNPdmVySWQiLCJ3YXNPdmVyIiwib25MaWZ0SW1wYWN0IiwiZHJhZ2dpbmdTdGF0ZSIsImRyb3BQZW5kaW5nIiwiaXNXYWl0aW5nIiwiaXNTbmFwcGluZyIsInBvc3REcm9wcGFibGVDaGFuZ2UiLCJpc0VuYWJsZWRDaGFuZ2luZyIsInJlbW92ZVNjcm9sbEp1bXBSZXF1ZXN0IiwiaWRsZSQyIiwiY29tcGxldGVkIiwic2hvdWxkRmx1c2giLCJyZWR1Y2VyIiwiYWN0aW9uIiwicGF5bG9hZCIsImlzV2luZG93U2Nyb2xsQWxsb3dlZCIsImV2ZXJ5IiwiaXNGaXhlZE9uUGFnZSIsIlN0cmluZyIsIm5ld1N0YXRlIiwiZHJvcER1cmF0aW9uIiwibmV3SG9tZUNsaWVudE9mZnNldCIsImJlZm9yZUluaXRpYWxDYXB0dXJlIiwibGlmdCQxIiwiaW5pdGlhbFB1Ymxpc2giLCJwdWJsaXNoV2hpbGVEcmFnZ2luZyIsImNvbGxlY3Rpb25TdGFydGluZyIsInVwZGF0ZURyb3BwYWJsZVNjcm9sbCIsInVwZGF0ZURyb3BwYWJsZUlzRW5hYmxlZCIsInVwZGF0ZURyb3BwYWJsZUlzQ29tYmluZUVuYWJsZWQiLCJtb3ZlIiwibW92ZUJ5V2luZG93U2Nyb2xsIiwidXBkYXRlVmlld3BvcnRNYXhTY3JvbGwiLCJtb3ZlVXAiLCJtb3ZlRG93biIsIm1vdmVSaWdodCIsIm1vdmVMZWZ0IiwiZmx1c2giLCJhbmltYXRlRHJvcCIsImNvbXBsZXRlRHJvcCIsImRyb3AkMSIsImRyb3BBbmltYXRpb25GaW5pc2hlZCIsImNoZWNrSW5kZXhlcyIsImluZGV4ZXMiLCJlcnJvcnMiLCJrZXlzIiwiZm9ybWF0dGVkIiwiaGFzRXJyb3IiLCJqb2luIiwidmFsaWRhdGVEaW1lbnNpb25zIiwibGlmdCIsIm1hcnNoYWwiLCJnZXRTdGF0ZSIsImRpc3BhdGNoIiwibmV4dCIsInNjcm9sbE9wdGlvbnMiLCJzaG91bGRQdWJsaXNoSW1tZWRpYXRlbHkiLCJyZXF1ZXN0Iiwic3RhcnRQdWJsaXNoaW5nIiwic3R5bGUiLCJkcmFnZ2luZyIsImRyb3BwaW5nIiwicmVzdGluZyIsImN1cnZlcyIsIm91dE9mVGhlV2F5IiwiZHJvcCIsIm9wYWNpdHkiLCJjb21iaW5pbmciLCJzY2FsZSIsInRpbWluZ3MiLCJtaW5Ecm9wVGltZSIsIm1heERyb3BUaW1lIiwib3V0T2ZUaGVXYXlUaW1pbmciLCJ0cmFuc2l0aW9ucyIsImZsdWlkIiwic25hcCIsImR1cmF0aW9uIiwidGltaW5nIiwibW92ZVRvIiwidW5kZWZpbmVkIiwidHJhbnNmb3JtcyIsImlzQ29tYmluaW5nIiwidHJhbnNsYXRlIiwiZHJvcFRpbWVSYW5nZSIsIm1heERyb3BUaW1lQXREaXN0YW5jZSIsImNhbmNlbERyb3BNb2RpZmllciIsImdldERyb3BEdXJhdGlvbiIsImRpc3RhbmNlJDEiLCJwZXJjZW50YWdlIiwid2l0aER1cmF0aW9uIiwiTnVtYmVyIiwidG9GaXhlZCIsImdldE5ld0hvbWVDbGllbnRPZmZzZXQiLCJuZXdDbGllbnRDZW50ZXIiLCJnZXREcm9wSW1wYWN0IiwibGFzdEltcGFjdCIsInJlY29tcHV0ZWRIb21lSW1wYWN0IiwiZGlkRHJvcEluc2lkZURyb3BwYWJsZSIsIndpdGhvdXRNb3ZlbWVudCIsImRyb3BNaWRkbGV3YXJlIiwiaXNXYWl0aW5nRm9yRHJvcCIsImlzQW5pbWF0aW9uUmVxdWlyZWQiLCJnZXRXaW5kb3dTY3JvbGwiLCJwYWdlWE9mZnNldCIsInBhZ2VZT2Zmc2V0IiwiZ2V0V2luZG93U2Nyb2xsQmluZGluZyIsInBhc3NpdmUiLCJjYXB0dXJlIiwiZG9jdW1lbnQiLCJnZXRTY3JvbGxMaXN0ZW5lciIsIm9uV2luZG93U2Nyb2xsIiwidXBkYXRlU2Nyb2xsIiwic2NoZWR1bGVkIiwiaXNBY3RpdmUiLCJzdG9wIiwiY2FuY2VsIiwic2hvdWxkRW5kIiwic2Nyb2xsTGlzdGVuZXIiLCJzdG9yZSIsImxpc3RlbmVyIiwic2Nyb2xsTGlzdGVuZXIkMSIsImdldEV4cGlyaW5nQW5ub3VuY2UiLCJhbm5vdW5jZSIsIndhc0NhbGxlZCIsImlzRXhwaXJlZCIsInRpbWVvdXRJZCIsInNldFRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJnZXRBc3luY01hcnNoYWwiLCJlbnRyaWVzIiwiZXhlY3V0ZSIsInRpbWVySWQiLCJlbnRyeSIsInNwbGljZSIsImNhbGxiYWNrIiwic2hhbGxvdyIsImFyZUxvY2F0aW9uc0VxdWFsIiwiaXNDb21iaW5lRXF1YWwiLCJpc0NyaXRpY2FsRXF1YWwiLCJpc0RyYWdnYWJsZUVxdWFsIiwiaXNEcm9wcGFibGVFcXVhbCIsIndpdGhUaW1pbmdzIiwiZ2V0RHJhZ1N0YXJ0IiwicmVzcG9uZGVyIiwiZGF0YSIsImdldERlZmF1bHRNZXNzYWdlIiwid2lsbEV4cGlyZSIsInByb3ZpZGVkIiwiZ2V0UHVibGlzaGVyIiwiZ2V0UmVzcG9uZGVycyIsImFzeW5jTWFyc2hhbCIsImJlZm9yZUNhcHR1cmUiLCJvbkJlZm9yZUNhcHR1cmUiLCJiZWZvcmVTdGFydCIsIm9uQmVmb3JlRHJhZ1N0YXJ0IiwibGFzdENyaXRpY2FsIiwibGFzdExvY2F0aW9uIiwibGFzdENvbWJpbmUiLCJoYXNDcml0aWNhbENoYW5nZWQiLCJoYXNMb2NhdGlvbkNoYW5nZWQiLCJoYXNHcm91cGluZ0NoYW5nZWQiLCJhYm9ydCIsInJlc3BvbmRlcnMiLCJwdWJsaXNoZXIiLCJkcm9wQW5pbWF0aW9uRmluaXNoTWlkZGxld2FyZSIsImRyb3BBbmltYXRpb25GaW5pc2giLCJkcm9wQW5pbWF0aW9uRmx1c2hPblNjcm9sbE1pZGRsZXdhcmUiLCJmcmFtZUlkIiwiY2xlYXIiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsIm9uY2UiLCJmbHVzaERyb3BBbmltYXRpb24iLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJkcm9wQW5pbWF0aW9uRmx1c2hPblNjcm9sbCIsImRpbWVuc2lvbk1hcnNoYWxTdG9wcGVyIiwic3RvcFB1Ymxpc2hpbmciLCJmb2N1cyIsImlzV2F0Y2hpbmciLCJ0cnlSZWNvcmRGb2N1cyIsInRyeVJlc3RvcmVGb2N1c1JlY29yZGVkIiwidHJ5U2hpZnRSZWNvcmQiLCJzaG91bGRTdG9wIiwiYXV0b1Njcm9sbCIsImF1dG9TY3JvbGxlciIsInBlbmRpbmdEcm9wIiwicG9zdEFjdGlvblN0YXRlIiwicGVuZGluZ0Ryb3AkMSIsImNvbXBvc2VFbmhhbmNlcnMiLCJfX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9DT01QT1NFX18iLCJuYW1lIiwiZGltZW5zaW9uTWFyc2hhbCIsImZvY3VzTWFyc2hhbCIsInN0eWxlTWFyc2hhbCIsImNsZWFuJDEiLCJjcmVhdGVQdWJsaXNoZXIiLCJyZWdpc3RyeSIsInN0YWdpbmciLCJjb2xsZWN0IiwiZ2V0QnlJZCIsImdldERpbWVuc2lvbiIsImdldFNjcm9sbFdoaWxlRHJhZ2dpbmciLCJwdWJsaXNoIiwiZ2V0TWF4U2Nyb2xsIiwic2Nyb2xsSGVpZ2h0Iiwic2Nyb2xsV2lkdGgiLCJhZGp1c3RlZE1heFNjcm9sbCIsImdldERvY3VtZW50RWxlbWVudCIsImRvYyIsImRvY3VtZW50RWxlbWVudCIsImdldE1heFdpbmRvd1Njcm9sbCIsImNsaWVudFdpZHRoIiwiY2xpZW50SGVpZ2h0IiwiZ2V0Vmlld3BvcnQiLCJnZXRJbml0aWFsUHVibGlzaCIsIndpbmRvd1Njcm9sbCIsImdldEFsbEJ5VHlwZSIsImdldERpbWVuc2lvbkFuZFdhdGNoU2Nyb2xsIiwic2hvdWxkUHVibGlzaFVwZGF0ZSIsImNyZWF0ZURpbWVuc2lvbk1hcnNoYWwiLCJjb2xsZWN0aW9uIiwiZXhpc3RzIiwiY2hhbmdlIiwiZHJhZ1N0b3BwZWQiLCJ1bnN1YnNjcmliZSIsInN1YnNjcmliZXIiLCJzdWJzY3JpYmUiLCJjYW5TdGFydERyYWciLCJzY3JvbGxXaW5kb3ciLCJzY3JvbGxCeSIsImdldFNjcm9sbGFibGVEcm9wcGFibGVzIiwiZ2V0U2Nyb2xsYWJsZURyb3BwYWJsZU92ZXIiLCJtYXliZSIsImdldEJlc3RTY3JvbGxhYmxlRHJvcHBhYmxlIiwiZGVmYXVsdEF1dG9TY3JvbGxlck9wdGlvbnMiLCJzdGFydEZyb21QZXJjZW50YWdlIiwibWF4U2Nyb2xsQXRQZXJjZW50YWdlIiwibWF4UGl4ZWxTY3JvbGwiLCJlYXNlIiwiZHVyYXRpb25EYW1wZW5pbmciLCJzdG9wRGFtcGVuaW5nQXQiLCJhY2NlbGVyYXRlQXQiLCJkaXNhYmxlZCIsImdldERpc3RhbmNlVGhyZXNob2xkcyIsImNvbnRhaW5lciIsImdldEF1dG9TY3JvbGxlck9wdGlvbnMiLCJhdXRvU2Nyb2xsZXJPcHRpb25zIiwic3RhcnRTY3JvbGxpbmdGcm9tIiwibWF4U2Nyb2xsVmFsdWVBdCIsInRocmVzaG9sZHMiLCJnZXRQZXJjZW50YWdlIiwic3RhcnRPZlJhbmdlIiwiZW5kT2ZSYW5nZSIsInJhbmdlIiwiY3VycmVudEluUmFuZ2UiLCJtaW5TY3JvbGwiLCJnZXRWYWx1ZUZyb21EaXN0YW5jZSIsImRpc3RhbmNlVG9FZGdlIiwicGVyY2VudGFnZUZyb21NYXhTY3JvbGxWYWx1ZUF0IiwicGVyY2VudGFnZUZyb21TdGFydFNjcm9sbGluZ0Zyb20iLCJjZWlsIiwiZGFtcGVuVmFsdWVCeVRpbWUiLCJwcm9wb3NlZFNjcm9sbCIsImRyYWdTdGFydFRpbWUiLCJzdG9wQXQiLCJEYXRlIiwicnVuVGltZSIsImJldHdlZW5BY2NlbGVyYXRlQXRBbmRTdG9wQXRQZXJjZW50YWdlIiwiZ2V0VmFsdWUiLCJzaG91bGRVc2VUaW1lRGFtcGVuaW5nIiwiZ2V0U2Nyb2xsT25BeGlzIiwiZGlzdGFuY2VUb0VkZ2VzIiwiaXNDbG9zZXJUb0VuZCIsImFkanVzdEZvclNpemVMaW1pdHMiLCJpc1Rvb0JpZ1ZlcnRpY2FsbHkiLCJpc1Rvb0JpZ0hvcml6b250YWxseSIsImNsZWFuIiwiZ2V0U2Nyb2xsJDEiLCJyZXF1aXJlZCIsImxpbWl0ZWQiLCJzbWFsbGVzdFNpZ25lZCIsImdldE92ZXJsYXAiLCJnZXRSZW1haW5kZXIiLCJ0YXJnZXRTY3JvbGwiLCJvdmVybGFwIiwiY2FuUGFydGlhbGx5U2Nyb2xsIiwicmF3TWF4Iiwic21hbGxlc3RDaGFuZ2UiLCJjYW5TY3JvbGxXaW5kb3ciLCJnZXRXaW5kb3dPdmVybGFwIiwiY2FuU2Nyb2xsRHJvcHBhYmxlIiwiZ2V0RHJvcHBhYmxlT3ZlcmxhcCIsImdldFdpbmRvd1Njcm9sbENoYW5nZSIsImdldERyb3BwYWJsZVNjcm9sbENoYW5nZSIsImNyZWF0ZUZsdWlkU2Nyb2xsZXIiLCJzY2hlZHVsZVdpbmRvd1Njcm9sbCIsInNjaGVkdWxlRHJvcHBhYmxlU2Nyb2xsIiwidHJ5U2Nyb2xsIiwic3RhcnQkMSIsIndhc1Njcm9sbE5lZWRlZCIsImZha2VTY3JvbGxDYWxsYmFjayIsImNyZWF0ZUp1bXBTY3JvbGxlciIsIm1vdmVCeU9mZnNldCIsInNjcm9sbERyb3BwYWJsZUFzTXVjaEFzSXRDYW4iLCJ3aGF0VGhlRHJvcHBhYmxlQ2FuU2Nyb2xsIiwicmVtYWluZGVyIiwic2Nyb2xsV2luZG93QXNNdWNoQXNJdENhbiIsIndoYXRUaGVXaW5kb3dDYW5TY3JvbGwiLCJqdW1wU2Nyb2xsZXIiLCJkcm9wcGFibGVSZW1haW5kZXIiLCJ3aW5kb3dSZW1haW5kZXIiLCJjcmVhdGVBdXRvU2Nyb2xsZXIiLCJmbHVpZFNjcm9sbGVyIiwianVtcFNjcm9sbCIsInNjcm9sbGVyIiwicHJlZml4IiwiZHJhZ0hhbmRsZSIsImJhc2UiLCJjb250ZXh0SWQiLCJzY3JvbGxDb250YWluZXIiLCJtYWtlR2V0U2VsZWN0b3IiLCJjb250ZXh0IiwiYXR0cmlidXRlIiwiZ2V0U3R5bGVzIiwicnVsZXMiLCJwcm9wZXJ0eSIsInJ1bGUiLCJzdHlsZXMiLCJzZWxlY3RvciIsIm5vUG9pbnRlckV2ZW50cyIsImdldFN0eWxlcyQxIiwiZ2V0U2VsZWN0b3IiLCJkcmFnSGFuZGxlJDEiLCJncmFiQ3Vyc29yIiwiYWx3YXlzIiwiZHJvcEFuaW1hdGluZyIsImRyYWdnYWJsZSQxIiwidHJhbnNpdGlvbiIsInVzZXJDYW5jZWwiLCJkcm9wcGFibGUkMSIsImJvZHkiLCJ1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IiwiY3JlYXRlRWxlbWVudCIsImdldEhlYWQiLCJoZWFkIiwicXVlcnlTZWxlY3RvciIsImNyZWF0ZVN0eWxlRWwiLCJub25jZSIsInNldEF0dHJpYnV0ZSIsInVzZVN0eWxlTWFyc2hhbCIsImFsd2F5c1JlZiIsImR5bmFtaWNSZWYiLCJzZXREeW5hbWljU3R5bGUiLCJ0ZXh0Q29udGVudCIsInNldEFsd2F5c1N0eWxlIiwiZHluYW1pYyIsImFwcGVuZENoaWxkIiwicmVmIiwicmVtb3ZlQ2hpbGQiLCJxdWVyeVNlbGVjdG9yQWxsIiwicGFyZW50Tm9kZSIsIkFycmF5IiwiZnJvbSIsImdldFdpbmRvd0Zyb21FbCIsIm93bmVyRG9jdW1lbnQiLCJkZWZhdWx0VmlldyIsImlzSHRtbEVsZW1lbnQiLCJIVE1MRWxlbWVudCIsImZpbmREcmFnSGFuZGxlIiwicG9zc2libGUiLCJoYW5kbGUiLCJnZXRBdHRyaWJ1dGUiLCJ1c2VGb2N1c01hcnNoYWwiLCJlbnRyaWVzUmVmIiwicmVjb3JkUmVmIiwicmVzdG9yZUZvY3VzRnJhbWVSZWYiLCJpc01vdW50ZWRSZWYiLCJyZWdpc3RlciIsInVucmVnaXN0ZXIiLCJ0cnlHaXZlRm9jdXMiLCJ0cnlHaXZlRm9jdXNUbyIsImFjdGl2ZUVsZW1lbnQiLCJyZWRpcmVjdFRvIiwicmVjb3JkIiwiZm9jdXNlZCIsImNsZWFyRnJhbWVPblVubW91bnQiLCJjcmVhdGVSZWdpc3RyeSIsInN1YnNjcmliZXJzIiwiY2IiLCJub3RpZnkiLCJmaW5kRHJhZ2dhYmxlQnlJZCIsImdldERyYWdnYWJsZUJ5SWQiLCJkcmFnZ2FibGVBUEkiLCJ1bmlxdWVJZCIsImZpbmRCeUlkIiwiZmluZERyb3BwYWJsZUJ5SWQiLCJnZXREcm9wcGFibGVCeUlkIiwiZHJvcHBhYmxlQVBJIiwidXNlUmVnaXN0cnkiLCJ1bm1vdW50IiwidmVyc2lvbiIsInN0YXJ0c1dpdGgiLCJTdG9yZUNvbnRleHQiLCJjcmVhdGVDb250ZXh0IiwiZ2V0Qm9keUVsZW1lbnQiLCJ2aXN1YWxseUhpZGRlbiIsImJvcmRlciIsInBhZGRpbmciLCJvdmVyZmxvdyIsInZpc3VhbGx5SGlkZGVuJDEiLCJnZXRJZCIsInVzZUFubm91bmNlciIsInNldHVwIiwiY2xlYW51cCIsImNvdW50JDEiLCJkZWZhdWx0cyIsInNlcGFyYXRvciIsInJlc2V0RGVwcmVjYXRlZFVuaXF1ZUlkIiwidXNlRGVwcmVjYXRlZFVuaXF1ZUlkIiwidXNlVW5pcXVlSWQiLCJ1c2VJZCIsInVzZVVuaXF1ZUlkJDEiLCJnZXRFbGVtZW50SWQiLCJ1c2VIaWRkZW5UZXh0RWxlbWVudCIsInRleHQiLCJtb3VudCIsImRpc3BsYXkiLCJBcHBDb250ZXh0IiwicGVlckRlcGVuZGVuY2llcyIsInJlYWN0Iiwic2VtdmVyIiwiZ2V0VmVyc2lvbiIsImV4ZWMiLCJtYWpvciIsIm1pbm9yIiwicmF3IiwiaXNTYXRpc2ZpZWQiLCJleHBlY3RlZCIsImFjdHVhbCIsImNoZWNrUmVhY3RWZXJzaW9uIiwicGVlckRlcFZhbHVlIiwiYWN0dWFsVmFsdWUiLCJwZWVyRGVwIiwic3VmZml4IiwiY2hlY2tEb2N0eXBlIiwiZG9jdHlwZSIsInRvTG93ZXJDYXNlIiwicHVibGljSWQiLCJ1c2VEZXYiLCJ1c2VIb29rIiwidXNlRGV2U2V0dXBXYXJuaW5nIiwiaW5wdXRzIiwiZSIsInVzZVN0YXJ0dXBWYWxpZGF0aW9uIiwidXNlUHJldmlvdXMiLCJjcmVhdGUiLCJsb2NrIiwiaXNDbGFpbWVkIiwiY2xhaW0iLCJhYmFuZG9uIiwibmV3TG9jayIsInJlbGVhc2UiLCJ0cnlBYmFuZG9uIiwidGFiIiwiZW50ZXIiLCJlc2NhcGUiLCJzcGFjZSIsInBhZ2VVcCIsInBhZ2VEb3duIiwiYXJyb3dMZWZ0IiwiYXJyb3dVcCIsImFycm93UmlnaHQiLCJhcnJvd0Rvd24iLCJwcmV2ZW50ZWRLZXlzIiwicHJldmVudFN0YW5kYXJkS2V5RXZlbnRzIiwia2V5Q29kZSIsInN1cHBvcnRlZEV2ZW50TmFtZSIsInN1cHBvcnRlZCIsInN1cHBvcnRlZFBhZ2VWaXNpYmlsaXR5RXZlbnROYW1lIiwicHJpbWFyeUJ1dHRvbiIsInNsb3BweUNsaWNrVGhyZXNob2xkIiwiaXNTbG9wcHlDbGlja1RocmVzaG9sZEV4Y2VlZGVkIiwiYWJzIiwiaWRsZSQxIiwiZ2V0Q2FwdHVyZUJpbmRpbmdzIiwiZ2V0UGhhc2UiLCJzZXRQaGFzZSIsImJ1dHRvbiIsImNsaWVudFgiLCJjbGllbnRZIiwiYWN0aW9ucyIsInBlbmRpbmciLCJmbHVpZExpZnQiLCJzaG91bGRCbG9ja05leHRDbGljayIsInNob3VsZFJlc3BlY3RGb3JjZVByZXNzIiwidXNlTW91c2VTZW5zb3IiLCJhcGkiLCJwaGFzZVJlZiIsInVuYmluZEV2ZW50c1JlZiIsInN0YXJ0Q2FwdHVyZUJpbmRpbmciLCJvbk1vdXNlRG93biIsImRlZmF1bHRQcmV2ZW50ZWQiLCJjdHJsS2V5IiwibWV0YUtleSIsInNoaWZ0S2V5IiwiYWx0S2V5IiwiZmluZENsb3Nlc3REcmFnZ2FibGVJZCIsInRyeUdldExvY2siLCJzb3VyY2VFdmVudCIsInN0YXJ0UGVuZGluZ0RyYWciLCJwcmV2ZW50Rm9yY2VQcmVzc0JpbmRpbmciLCJmaW5kT3B0aW9uc0ZvckRyYWdnYWJsZSIsImNhbkdldExvY2siLCJsaXN0ZW5Gb3JDYXB0dXJlIiwiYmluZENhcHR1cmluZ0V2ZW50cyIsIm5vb3AkMSIsInNjcm9sbEp1bXBLZXlzIiwiZ2V0RHJhZ2dpbmdCaW5kaW5ncyIsInVzZUtleWJvYXJkU2Vuc29yIiwib25LZXlEb3duIiwicHJlRHJhZyIsImlzQ2FwdHVyaW5nIiwic25hcExpZnQiLCJ0cnlTdGFydENhcHR1cmUiLCJpZGxlIiwidGltZUZvckxvbmdQcmVzcyIsImZvcmNlUHJlc3NUaHJlc2hvbGQiLCJnZXRXaW5kb3dCaW5kaW5ncyIsImdldEhhbmRsZUJpbmRpbmdzIiwiaGFzTW92ZWQiLCJ0b3VjaGVzIiwidG91Y2giLCJpc0ZvcmNlUHJlc3MiLCJmb3JjZSIsInNob3VsZFJlc3BlY3QiLCJ1c2VUb3VjaFNlbnNvciIsIm9uVG91Y2hTdGFydCIsImxvbmdQcmVzc1RpbWVySWQiLCJ1bmJpbmRUYXJnZXQiLCJ1bmJpbmRXaW5kb3ciLCJzdGFydERyYWdnaW5nIiwid2Via2l0SGFjayIsInVzZVZhbGlkYXRlU2Vuc29ySG9va3MiLCJzZW5zb3JIb29rcyIsInByZXZpb3VzUmVmIiwiaW50ZXJhY3RpdmVUYWdOYW1lcyIsImlzQW5JbnRlcmFjdGl2ZUVsZW1lbnQiLCJwYXJlbnQiLCJoYXNBbkludGVyYWN0aXZlVGFnIiwiaW5jbHVkZXMiLCJ0YWdOYW1lIiwicGFyZW50RWxlbWVudCIsImlzRXZlbnRJbkludGVyYWN0aXZlRWxlbWVudCIsImdldEJvcmRlckJveENlbnRlclBvc2l0aW9uIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiaXNFbGVtZW50IiwiRWxlbWVudCIsInN1cHBvcnRlZE1hdGNoZXNOYW1lIiwiY2xvc2VzdFBvbnlmaWxsIiwiZmluZENsb3Nlc3REcmFnSGFuZGxlRnJvbUV2ZW50IiwidHJ5R2V0Q2xvc2VzdERyYWdnYWJsZUlkRnJvbUV2ZW50IiwiZmluZERyYWdnYWJsZSIsImlzTG9ja0FjdGl2ZSIsInNob3VsZFdhcm4iLCJjYW5TdGFydCIsImxvY2tBUEkiLCJ0cnlTdGFydCIsImZvcmNlU2Vuc29yU3RvcCIsInNob3VsZFN0YXJ0IiwiY2FuRHJhZ0ludGVyYWN0aXZlRWxlbWVudHMiLCJnZXRTaG91bGRSZXNwZWN0Rm9yY2VQcmVzcyIsInRyeURpc3BhdGNoIiwiZ2V0QWN0aW9uIiwidHJ5RGlzcGF0Y2hXaGVuRHJhZ2dpbmciLCJsaWZ0QWN0aW9uQXJncyIsIm1vdmUkMSIsImFib3J0UHJlRHJhZyIsInNob3VsZFJlbGVhc2UiLCJkZWZhdWx0U2Vuc29ycyIsInVzZVNlbnNvck1hcnNoYWwiLCJjdXN0b21TZW5zb3JzIiwiZW5hYmxlRGVmYXVsdFNlbnNvcnMiLCJ1c2VTZW5zb3JzIiwidHJ5QWJhbmRvbkxvY2siLCJsaXN0ZW5Ub1N0b3JlIiwiZm9yY2VTdG9wIiwidHJ5UmVsZWFzZUxvY2siLCJpc0xvY2tDbGFpbWVkIiwiY3JlYXRlUmVzcG9uZGVycyIsInQiLCJvbkJlZm9yZUNhcHVyZUNhbGxiYWNrIiwiY3JlYXRlQXV0b1Njcm9sbGVyT3B0aW9ucyIsImdldFN0b3JlIiwibGF6eVJlZiIsIkFwcCIsInNlbnNvcnMiLCJsYXp5U3RvcmVSZWYiLCJsYXN0UHJvcHNSZWYiLCJkcmFnSGFuZGxlVXNhZ2VJbnN0cnVjdGlvbnNJZCIsImxhenlEaXNwYXRjaCIsIm1hcnNoYWxDYWxsYmFja3MiLCJ0cnlSZXNldFN0b3JlIiwiYXBwQ2FsbGJhY2tzIiwiZ2V0Q2FuTGlmdCIsImdldElzTW92ZW1lbnRBbGxvd2VkIiwiYXBwQ29udGV4dCIsImNhbkxpZnQiLCJjb3VudCIsInJlc2V0RGVwcmVjYXRlZFVuaXF1ZUNvbnRleHRJZCIsInVzZURlcHJlY2F0ZWRVbmlxdWVDb250ZXh0SWQiLCJ1c2VVbmlxdWVDb250ZXh0SWQiLCJ1c2VVbmlxdWVDb250ZXh0SWQkMSIsInJlc2V0U2VydmVyQ29udGV4dCIsIkRyYWdEcm9wQ29udGV4dCIsInpJbmRleE9wdGlvbnMiLCJnZXREcmFnZ2luZ1RyYW5zaXRpb24iLCJzaG91bGRBbmltYXRlRHJhZ01vdmVtZW50IiwiZ2V0RHJhZ2dpbmdPcGFjaXR5IiwiaXNEcm9wQW5pbWF0aW5nIiwiZ2V0U2hvdWxkRHJhZ2dpbmdBbmltYXRlIiwiZ2V0RHJhZ2dpbmdTdHlsZSIsInRyYW5zZm9ybSIsImJveFNpemluZyIsInpJbmRleCIsInBvaW50ZXJFdmVudHMiLCJnZXRTZWNvbmRhcnlTdHlsZSIsInNlY29uZGFyeSIsInNob3VsZEFuaW1hdGVEaXNwbGFjZW1lbnQiLCJnZXRTdHlsZSQxIiwibWFwcGVkIiwiZ2V0RGltZW5zaW9uJDEiLCJjb21wdXRlZFN0eWxlcyIsImdldENvbXB1dGVkU3R5bGUiLCJ1c2VEcmFnZ2FibGVQdWJsaXNoZXIiLCJnZXREcmFnZ2FibGVSZWYiLCJwdWJsaXNoZWRSZWYiLCJpc0ZpcnN0UHVibGlzaFJlZiIsIkRyb3BwYWJsZUNvbnRleHQiLCJjaGVja0lzVmFsaWRJbm5lclJlZiIsInVzZVZhbGlkYXRpb24kMSIsImdldFJlZiIsImlzSW50ZWdlciIsInVzZUNsb25lUHJvcFZhbGlkYXRpb24iLCJpc0Nsb25lIiwiaW5pdGlhbFJlZiIsInVzZVJlcXVpcmVkQ29udGV4dCIsIkNvbnRleHQiLCJwcmV2ZW50SHRtbDVEbmQiLCJEcmFnZ2FibGUiLCJzZXRSZWYiLCJkcm9wQW5pbWF0aW9uRmluaXNoZWRBY3Rpb24iLCJmb3JQdWJsaXNoZXIiLCJkcmFnSGFuZGxlUHJvcHMiLCJ0YWJJbmRleCIsInJvbGUiLCJvbk1vdmVFbmQiLCJwcm9wZXJ0eU5hbWUiLCJvblRyYW5zaXRpb25FbmQiLCJpbm5lclJlZiIsImRyYWdnYWJsZVByb3BzIiwicnVicmljIiwiRnJhZ21lbnQiLCJzbmFwc2hvdCIsIkRyYWdnYWJsZSQxIiwiaXNTdHJpY3RFcXVhbCIsIndoYXRJc0RyYWdnZWRPdmVyRnJvbVJlc3VsdCIsImdldENvbWJpbmVXaXRoRnJvbVJlc3VsdCIsImdldENvbWJpbmVXaXRoRnJvbUltcGFjdCIsImdldERyYWdnYWJsZVNlbGVjdG9yIiwibWVtb2l6ZWRPZmZzZXQiLCJnZXRNZW1vaXplZFNuYXBzaG90IiwiZHJhZ2dpbmdPdmVyIiwiZHJvcEFuaW1hdGlvbiIsImNvbWJpbmVUYXJnZXRGb3IiLCJnZXRNZW1vaXplZFByb3BzIiwib3duUHJvcHMiLCJjdXJ2ZSIsImdldFNlY29uZGFyeVNuYXBzaG90IiwiYXRSZXN0IiwiZ2V0U2Vjb25kYXJ5U2VsZWN0b3IiLCJnZXRGYWxsYmFjayIsImdldFByb3BzIiwib3duSWQiLCJkcmFnZ2luZ0lkIiwidmlzdWFsRGlzcGxhY2VtZW50IiwiaXNBZnRlckNyaXRpY2FsSW5WaXJ0dWFsTGlzdCIsIm1ha2VNYXBTdGF0ZVRvUHJvcHMkMSIsImRyYWdnaW5nU2VsZWN0b3IiLCJzZWNvbmRhcnlTZWxlY3RvciIsIm1hcERpc3BhdGNoVG9Qcm9wcyQxIiwiQ29ubmVjdGVkRHJhZ2dhYmxlIiwiYXJlU3RhdGVQcm9wc0VxdWFsIiwiQ29ubmVjdGVkRHJhZ2dhYmxlJDEiLCJQcml2YXRlRHJhZ2dhYmxlIiwiZHJvcHBhYmxlQ29udGV4dCIsImlzVXNpbmdDbG9uZUZvciIsIlB1YmxpY0RyYWdnYWJsZSIsImlzRHJhZ0Rpc2FibGVkIiwiZGlzYWJsZUludGVyYWN0aXZlRWxlbWVudEJsb2NraW5nIiwiaXNFcXVhbCIsImlzU2Nyb2xsIiwiaXNBdXRvIiwiaXNFaXRoZXIiLCJvdmVyZmxvd1giLCJvdmVyZmxvd1kiLCJpc0JvdGgiLCJpc0VsZW1lbnRTY3JvbGxhYmxlIiwiaXNCb2R5U2Nyb2xsYWJsZSIsImh0bWwiLCJodG1sU3R5bGUiLCJodG1sT3ZlcmZsb3ciLCJnZXRDbG9zZXN0U2Nyb2xsYWJsZSIsImNoZWNrRm9yTmVzdGVkU2Nyb2xsQ29udGFpbmVycyIsImFub3RoZXJTY3JvbGxQYXJlbnQiLCJnZXRTY3JvbGwiLCJzY3JvbGxMZWZ0Iiwic2Nyb2xsVG9wIiwiZ2V0SXNGaXhlZCIsImdldEVudiIsImNsb3Nlc3RTY3JvbGxhYmxlIiwiZ2V0RHJvcHBhYmxlRGltZW5zaW9uIiwic2Nyb2xsU2l6ZSIsImZyYW1lQ2xpZW50IiwicGFkZGluZ0JveCIsImdldENsaWVudCIsInRhcmdldFJlZiIsImVudiIsImlzRHJvcERpc2FibGVkIiwiaW1tZWRpYXRlIiwiZGVsYXllZCIsImdldExpc3RlbmVyT3B0aW9ucyIsImdldENsb3Nlc3RTY3JvbGxhYmxlRnJvbURyYWciLCJ1c2VEcm9wcGFibGVQdWJsaXNoZXIiLCJ3aGlsZURyYWdnaW5nUmVmIiwicHVibGlzaGVkRGVzY3JpcHRvclJlZiIsIm1lbW9pemVkVXBkYXRlU2Nyb2xsIiwiZ2V0Q2xvc2VzdFNjcm9sbCIsInNjaGVkdWxlU2Nyb2xsVXBkYXRlIiwib25DbG9zZXN0U2Nyb2xsIiwiZ2V0RHJvcHBhYmxlUmVmIiwiaWdub3JlQ29udGFpbmVyQ2xpcHBpbmciLCJyZW1vdmVBdHRyaWJ1dGUiLCJub29wIiwiZW1wdHkiLCJnZXRTaXplIiwiaXNBbmltYXRpbmdPcGVuT25Nb3VudCIsImFuaW1hdGUiLCJnZXRTdHlsZSIsIm1hcmdpblRvcCIsIm1hcmdpblJpZ2h0IiwibWFyZ2luQm90dG9tIiwibWFyZ2luTGVmdCIsImZsZXhTaHJpbmsiLCJmbGV4R3JvdyIsIlBsYWNlaG9sZGVyIiwiYW5pbWF0ZU9wZW5UaW1lclJlZiIsInRyeUNsZWFyQW5pbWF0ZU9wZW5UaW1lciIsIm9uQ2xvc2UiLCJzZXRJc0FuaW1hdGluZ09wZW5Pbk1vdW50Iiwib25TaXplQ2hhbmdlRW5kIiwiUGxhY2Vob2xkZXIkMSIsIm1lbW8iLCJpc0Jvb2xlYW4iLCJydW5DaGVja3MiLCJjaGVja3MiLCJjaGVjayIsImJvb2xlYW4iLCJzdGFuZGFyZCIsImdldFBsYWNlaG9sZGVyUmVmIiwidmlydHVhbCIsImhhc0Nsb25lIiwicmVuZGVyQ2xvbmUiLCJoYXNOb1BsYWNlaG9sZGVyIiwidXNlVmFsaWRhdGlvbiIsIkFuaW1hdGVJbk91dCIsIlB1cmVDb21wb25lbnQiLCJvbiIsImdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyIsIkRyb3BwYWJsZSIsImRyb3BwYWJsZVJlZiIsInBsYWNlaG9sZGVyUmVmIiwidXNlQ2xvbmUiLCJnZXRDb250YWluZXJGb3JDbG9uZSIsInNldERyb3BwYWJsZVJlZiIsInNldFBsYWNlaG9sZGVyUmVmIiwib25QbGFjZWhvbGRlclRyYW5zaXRpb25FbmQiLCJzaG91bGRBbmltYXRlUGxhY2Vob2xkZXIiLCJkcm9wcGFibGVQcm9wcyIsImdldENsb25lIiwibm9kZSIsImRyYWdnYWJsZVByb3ZpZGVkIiwiZHJhZ2dhYmxlU25hcHNob3QiLCJjcmVhdGVQb3J0YWwiLCJEcm9wcGFibGUkMSIsImdldEJvZHkiLCJkZWZhdWx0UHJvcHMiLCJhdHRhY2hEZWZhdWx0UHJvcHNUb093blByb3BzIiwibWVyZ2VkUHJvcHMiLCJkZWZhdWx0UHJvcEtleSIsImlzTWF0Y2hpbmdUeXBlIiwiZ2V0RHJhZ2dhYmxlIiwibWFrZU1hcFN0YXRlVG9Qcm9wcyIsImlkbGVXaXRoQW5pbWF0aW9uIiwiaXNEcmFnZ2luZ092ZXIiLCJkcmFnZ2luZ092ZXJXaXRoIiwiZHJhZ2dpbmdGcm9tVGhpc1dpdGgiLCJpc1VzaW5nUGxhY2Vob2xkZXIiLCJpZGxlV2l0aG91dEFuaW1hdGlvbiIsImdldERyYWdnYWJsZVJ1YnJpYyIsImdldE1hcFByb3BzIiwiaXNEcmFnZ2luZ092ZXJGb3JDb25zdW1lciIsImlzRHJhZ2dpbmdPdmVyRm9ySW1wYWN0IiwiaXNIb21lIiwib3duUHJvcHNXaXRoRGVmYXVsdFByb3BzIiwid2FzQ29tYmluaW5nIiwibWFwRGlzcGF0Y2hUb1Byb3BzIiwiQ29ubmVjdGVkRHJvcHBhYmxlIiwic3RhdGVQcm9wcyIsImRpc3BhdGNoUHJvcHMiLCJDb25uZWN0ZWREcm9wcGFibGUkMSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@hello-pangea/dnd/dist/dnd.esm.js\n");

/***/ })

};
;